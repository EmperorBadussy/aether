<!--
  ╔══════════════════════════════════════════════════════════════════╗
  ║  AETHER — Audio Engine for Total Harmonic Experience & Rendering ║
  ║  Renderer Process (Single-File Application)                      ║
  ╠══════════════════════════════════════════════════════════════════╣
  ║                                                                  ║
  ║  This file IS the entire application — CSS, HTML, and JS.        ║
  ║  ~5700 lines of hand-crafted code. No frameworks. No build step. ║
  ║                                                                  ║
  ║  SECTIONS:                                                       ║
  ║  ├─ CSS (~1500 lines) — OLED Tron Purple design system           ║
  ║  │   ├─ CSS Variables & Theming                                  ║
  ║  │   ├─ Layout (sidebar, content, now-playing bar)               ║
  ║  │   ├─ Vertical/Horizontal orientation modes                    ║
  ║  │   ├─ Animations & Transitions                                 ║
  ║  │   └─ Responsive breakpoints (320px to 4K)                     ║
  ║  ├─ HTML (~200 lines) — Semantic structure                       ║
  ║  │   ├─ Title bar (frameless window controls)                    ║
  ║  │   ├─ Sidebar (library nav, playlists)                         ║
  ║  │   ├─ Content area (dynamic views)                             ║
  ║  │   ├─ Visualizer panel (canvas)                                ║
  ║  │   └─ Now-playing bar (controls, seek, info)                   ║
  ║  └─ JavaScript (~4000 lines) — Application logic                 ║
  ║      ├─ MD5 hasher (Subsonic auth)                               ║
  ║      ├─ Subsonic API client                                      ║
  ║      ├─ Audio engine (Web Audio API pipeline)                    ║
  ║      ├─ Library views (albums, artists, genres, binaural, search) ║
  ║      ├─ Rhythmic Binaural Brainwave Layering Engine              ║
  ║      ├─ Queue management & playback                              ║
  ║      ├─ Settings persistence (localStorage)                      ║
  ║      ├─ 17 Visualizer scenes (Canvas 2D)                         ║
  ║      ├─ Beat detection & frequency band analysis                 ║
  ║      └─ Keyboard shortcuts & navigation                          ║
  ║                                                                  ║
  ║  DEVNOTES:                                                       ║
  ║  - Credentials in SUBSONIC object are local defaults only        ║
  ║  - Users configure real creds via Settings panel → localStorage  ║
  ║  - All visualizers use requestAnimationFrame for 60fps render    ║
  ║  - Audio analysis runs in separate rAF loop for decoupling       ║
  ║  - Splash screen auto-dismisses after 2s or on first API success ║
  ║  - Context menus are position-clamped to viewport bounds         ║
  ║  - escHtml() utility available for XSS-safe innerHTML injection  ║
  ║                                                                  ║
  ╚══════════════════════════════════════════════════════════════════╝
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AETHER</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg-void: #000000;
  --bg-surface: #09090F;
  --bg-raised: #0F0F1A;
  --bg-input: #12121F;
  --purple-dim: #362050;
  --purple-muted: #6B42A0;
  --purple-core: #7B2FBE;
  --purple-bright: #9D4EDD;
  --purple-vivid: #B76EFF;
  --purple-hot: #D4A0FF;
  --purple-white: #EED4FF;
  --glow-subtle: 0 0 10px rgba(157,78,221,0.15);
  --glow-medium: 0 0 20px rgba(157,78,221,0.25), 0 0 40px rgba(123,47,190,0.15);
  --glow-intense: 0 0 20px rgba(157,78,221,0.4), 0 0 60px rgba(123,47,190,0.25), 0 0 100px rgba(123,47,190,0.1);
  --glow-text: 0 0 10px rgba(183,110,255,0.8), 0 0 20px rgba(157,78,221,0.3);
  --glow-neon: 0 0 4px #B76EFF, 0 0 12px rgba(183,110,255,0.5), 0 0 30px rgba(157,78,221,0.3), 0 0 60px rgba(123,47,190,0.15);
  --cyan-dim: #0A3D4A;
  --cyan-muted: #0E6377;
  --cyan-core: #00B4D8;
  --cyan-bright: #00DCF5;
  --cyan-vivid: #48F2FF;
  --cyan-glow: 0 0 10px rgba(0, 220, 245, 0.3), 0 0 25px rgba(0, 180, 216, 0.15);
  --magenta-dim: #3D0A2A;
  --magenta-muted: #9B0054;
  --magenta-core: #D4147A;
  --magenta-bright: #FF2D7B;
  --magenta-vivid: #FF6BA8;
  --magenta-soft: #FFB3D4;
  --magenta-glow: 0 0 10px rgba(255, 45, 123, 0.3), 0 0 25px rgba(212, 20, 122, 0.15);
  --font-display: 'Orbitron', sans-serif;
  --font-body: 'Rajdhani', sans-serif;
  --font-mono: 'JetBrains Mono', monospace;
  --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
  --ease-bounce: cubic-bezier(0.34, 1.56, 0.64, 1);
  --sidebar-width: 240px;
  --sidebar-collapsed: 56px;
  --titlebar-h: 36px;
  --nowplaying-h: 90px;
}
*, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }
::selection { background:rgba(123,47,190,0.4); color:var(--purple-white); }
::-webkit-scrollbar { width:4px; }
::-webkit-scrollbar-track { background:var(--bg-void); }
::-webkit-scrollbar-thumb { background:var(--purple-muted); border-radius:2px; }
::-webkit-scrollbar-thumb:hover { background:var(--purple-bright); }
html, body { height:100%; overflow:hidden; background:var(--bg-void); color:var(--purple-white); font-family:var(--font-body); -webkit-font-smoothing:antialiased; }

/* TITLEBAR */
.titlebar { position:fixed; top:0; left:0; right:0; height:var(--titlebar-h); background:var(--bg-surface); border-bottom:1px solid var(--purple-dim); display:flex; align-items:center; justify-content:space-between; -webkit-app-region:drag; z-index:9999; padding-left:14px; user-select:none; }
.titlebar-left { display:flex; align-items:center; gap:8px; -webkit-app-region:drag; }
.titlebar-logo, .beat-dot { -webkit-app-region:drag; }
.titlebar-logo { font-family:var(--font-display); font-weight:800; font-size:0.6rem; color:var(--purple-vivid); text-shadow:var(--glow-text); letter-spacing:0.15em; }
.titlebar-logo .logo-p { display:inline-flex; align-items:center; justify-content:center; width:20px; height:20px; border:1.5px solid var(--purple-bright); border-radius:4px; font-size:0.5rem; box-shadow:var(--glow-subtle); margin-right:6px; }
.titlebar-controls { display:flex; -webkit-app-region:no-drag; height:100%; }
.tb-btn { width:46px; height:var(--titlebar-h); border:none; background:transparent; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:background 0.15s; }
.tb-btn svg { width:10px; height:10px; stroke:var(--purple-muted); fill:none; stroke-width:1.5; transition:stroke 0.15s; }
.tb-btn:hover svg { stroke:var(--purple-white); }
.tb-btn:hover { background:rgba(123,47,190,0.2); }
.tb-btn.close:hover { background:rgba(232,17,35,0.9); }

/* APP SHELL */
.app-shell { position:fixed; top:var(--titlebar-h); left:0; right:0; bottom:0; display:grid; grid-template-columns:var(--sidebar-collapsed) 1fr; grid-template-rows:1fr var(--nowplaying-h); transition:grid-template-columns 0.3s var(--ease-smooth); }
.app-shell.sidebar-expanded { grid-template-columns:var(--sidebar-width) 1fr; }

/* VERTICAL ORIENTATION MODE */
body.vertical-mode .app-shell { grid-template-columns:1fr; grid-template-rows:1fr var(--nowplaying-h); }
body.vertical-mode .sidebar { position:fixed; bottom:var(--nowplaying-h); left:0; right:0; height:auto; max-height:60vh; z-index:300; border-right:none; border-top:1px solid var(--purple-dim); transform:translateY(100%); transition:transform 0.3s var(--ease-smooth); flex-direction:row; flex-wrap:wrap; }
body.vertical-mode .app-shell.sidebar-expanded .sidebar { transform:translateY(0); }
body.vertical-mode .sidebar-nav { flex-direction:row; flex-wrap:wrap; padding:8px; gap:4px; }
body.vertical-mode .nav-item { padding:8px 16px; }
body.vertical-mode .nav-item-label { opacity:1; pointer-events:auto; }
body.vertical-mode .sidebar-section-label { opacity:1; }
body.vertical-mode .playlist-name { opacity:1; }
body.vertical-mode .playlist-count { opacity:1; }
body.vertical-mode .main-content { grid-column:1; }
body.vertical-mode .now-playing { grid-column:1; grid-template-columns:1fr; padding:8px 12px; gap:8px; }
body.vertical-mode .np-left { justify-content:center; }
body.vertical-mode .np-center { order:-1; }
body.vertical-mode .np-right { justify-content:center; }
body.vertical-mode .visualizer-panel { height:40vh; margin:12px; }
body.vertical-mode .album-grid { grid-template-columns:repeat(auto-fill, minmax(130px, 1fr)); gap:12px; }
body.vertical-mode .content-header { flex-direction:column; align-items:center; gap:8px; }
body.vertical-mode .content-header-right { position:static; transform:none; }
body.vertical-mode .track-row { grid-template-columns:30px 2fr 1fr 60px; }
body.vertical-mode .track-list-header { grid-template-columns:30px 2fr 1fr 60px; }

/* SIDEBAR */
.sidebar { grid-row:1/-1; background:var(--bg-surface); border-right:1px solid var(--purple-dim); display:flex; flex-direction:column; overflow:hidden; z-index:100; }
.sidebar-toggle { width:100%; height:44px; border:none; background:transparent; cursor:pointer; display:flex; align-items:center; justify-content:center; border-bottom:1px solid rgba(42,27,61,0.3); transition:background 0.2s; flex-shrink:0; }
.sidebar-toggle:hover { background:var(--bg-raised); }
.sidebar-toggle svg { width:18px; height:18px; stroke:var(--purple-muted); fill:none; stroke-width:1.5; transition:stroke 0.2s,transform 0.3s; }
.sidebar-toggle:hover svg { stroke:var(--purple-bright); }
.app-shell.sidebar-expanded .sidebar-toggle svg { transform:rotate(180deg); }
.sidebar-nav { flex:1; display:flex; flex-direction:column; gap:2px; padding:8px 6px; overflow-y:auto; }
.nav-item { display:flex; align-items:center; gap:12px; padding:10px; border-radius:8px; cursor:pointer; transition:background 0.2s, box-shadow 0.2s; text-decoration:none; color:var(--purple-hot); position:relative; white-space:nowrap; overflow:hidden; }
.nav-item:hover { background:var(--bg-raised); }
.nav-item.active { background:rgba(123,47,190,0.12); }
.nav-item.active::before { content:''; position:absolute; left:0; top:4px; bottom:4px; width:3px; background:var(--purple-bright); border-radius:0 2px 2px 0; box-shadow:0 0 10px rgba(157,78,221,0.5); animation:nav-indicator-in 0.4s var(--ease-bounce); }
@keyframes nav-indicator-in { from { transform:scaleY(0); opacity:0; } to { transform:scaleY(1); opacity:1; } }
.nav-item svg { width:20px; height:20px; stroke:var(--purple-muted); fill:none; stroke-width:1.5; flex-shrink:0; transition:stroke 0.2s; }
.nav-item:hover svg, .nav-item.active svg { stroke:var(--purple-bright); }
.nav-item-label { font-family:var(--font-body); font-weight:500; font-size:0.9rem; opacity:0; transition:opacity 0.2s; pointer-events:none; }
.app-shell.sidebar-expanded .nav-item-label { opacity:1; pointer-events:auto; }
.sidebar-divider { height:1px; background:var(--purple-dim); margin:8px 10px; flex-shrink:0; }
.sidebar-section-label { font-family:var(--font-mono); font-size:0.55rem; color:var(--purple-muted); letter-spacing:0.15em; padding:8px 12px 4px; text-transform:uppercase; opacity:0; transition:opacity 0.2s; white-space:nowrap; }
.app-shell.sidebar-expanded .sidebar-section-label { opacity:1; }
.playlist-item { display:flex; align-items:center; gap:10px; padding:7px 10px; border-radius:6px; cursor:pointer; transition:background 0.2s; white-space:nowrap; overflow:hidden; }
.playlist-item:hover { background:var(--bg-raised); }
.playlist-dot { width:8px; height:8px; border-radius:50%; background:var(--purple-muted); flex-shrink:0; }
.playlist-name { font-size:0.85rem; color:var(--purple-hot); opacity:0; transition:opacity 0.2s; }
.app-shell.sidebar-expanded .playlist-name { opacity:1; }
.playlist-count { margin-left:auto; font-family:var(--font-mono); font-size:0.6rem; color:var(--purple-muted); background:var(--bg-raised); padding:1px 6px; border-radius:4px; opacity:0; transition:opacity 0.2s; }
.app-shell.sidebar-expanded .playlist-count { opacity:1; }
.create-playlist-btn { display:flex; align-items:center; gap:10px; padding:7px 10px; border-radius:6px; cursor:pointer; transition:background 0.2s; white-space:nowrap; overflow:hidden; border:1px dashed var(--purple-dim); background:transparent; color:var(--purple-muted); font-family:var(--font-body); font-size:0.85rem; margin-top:4px; width:100%; }
.create-playlist-btn:hover { background:var(--bg-raised); border-color:var(--purple-muted); color:var(--purple-hot); }
.create-playlist-btn svg { width:16px; height:16px; stroke:currentColor; fill:none; stroke-width:1.5; flex-shrink:0; }
.create-playlist-label { opacity:0; transition:opacity 0.2s; }
.app-shell.sidebar-expanded .create-playlist-label { opacity:1; }

/* MAIN CONTENT */
.main-content { background:var(--bg-void); overflow-y:auto; overflow-x:hidden; position:relative; }
.content-header { padding:16px 28px 12px; display:flex; align-items:center; justify-content:center; gap:16px; flex-wrap:wrap; position:relative; }
.content-title { font-family:var(--font-display); font-weight:700; font-size:1.1rem; color:var(--purple-white); text-shadow:var(--glow-text); letter-spacing:0.1em; text-transform:uppercase; }
.content-header-right { position:absolute; right:28px; top:50%; transform:translateY(-50%); display:flex; align-items:center; gap:12px; }
.view-toggles { display:flex; gap:4px; background:var(--bg-surface); border:1px solid var(--purple-dim); border-radius:8px; padding:3px; }
.view-btn { border:none; background:transparent; padding:6px 10px; border-radius:6px; cursor:pointer; transition:background 0.2s, color 0.2s, transform 0.1s; display:flex; align-items:center; }
.view-btn svg { width:16px; height:16px; stroke:var(--purple-muted); fill:none; stroke-width:1.5; }
.view-btn.active { background:rgba(123,47,190,0.2); }
.view-btn.active svg { stroke:var(--purple-bright); }
.view-btn:hover svg { stroke:var(--purple-vivid); }
.view-btn:active { transform:scale(0.94); }
.search-bar { display:flex; align-items:center; gap:8px; background:var(--bg-input); border:1px solid var(--purple-dim); border-radius:8px; padding:8px 14px; transition:border-color 0.2s, box-shadow 0.2s; max-width:300px; flex:1; }
.search-bar:focus-within { border-color:var(--purple-bright); box-shadow:var(--glow-subtle); }
.search-bar svg { width:16px; height:16px; stroke:var(--purple-muted); fill:none; stroke-width:1.5; flex-shrink:0; }
.search-bar input { background:none; border:none; outline:none; color:var(--purple-white); font-family:var(--font-body); font-size:0.9rem; width:100%; }
.search-bar input::placeholder { color:var(--purple-muted); }

/* VISUALIZER */
.visualizer-panel { margin:20px 28px; border-radius:16px; overflow:hidden; border:1px solid var(--purple-dim); position:relative; height:280px; background:var(--bg-void); cursor:pointer; transition:box-shadow 0.3s; }
.visualizer-panel:hover { box-shadow:var(--glow-medium); }
.visualizer-panel canvas { width:100%; height:100%; display:block; }
.viz-label { position:absolute; top:12px; left:16px; font-family:var(--font-mono); font-size:0.6rem; color:var(--purple-muted); letter-spacing:0.12em; z-index:2; pointer-events:none; }
.viz-scene-name { position:absolute; top:12px; right:16px; font-family:var(--font-display); font-weight:600; font-size:0.65rem; color:var(--purple-bright); letter-spacing:0.1em; z-index:2; text-shadow:var(--glow-text); }
.viz-expand { position:absolute; bottom:12px; right:16px; width:32px; height:32px; border-radius:6px; background:rgba(9,9,15,0.7); border:1px solid var(--purple-dim); display:flex; align-items:center; justify-content:center; cursor:pointer; transition:background 0.2s, border-color 0.2s, box-shadow 0.2s, transform 0.1s; z-index:2; }
.viz-expand:hover { border-color:var(--purple-bright); box-shadow:var(--glow-subtle); background:rgba(15,15,26,0.9); }
.viz-expand:active { transform:scale(0.94); }
.viz-expand svg { width:14px; height:14px; stroke:var(--purple-muted); fill:none; stroke-width:1.5; }
.viz-expand:hover svg { stroke:var(--purple-bright); }
.viz-fullscreen {
  position: fixed !important;
  inset: 0 !important;
  z-index: 500 !important;
  margin: 0 !important;
  border-radius: 0 !important;
  border: none !important;
  height: 100vh !important;
}
.viz-fullscreen .viz-label, .viz-fullscreen .viz-scene-name { top: 20px; }
.viz-fullscreen-controls {
  position: fixed;
  bottom: 0; left: 0; right: 0;
  z-index: 501;
  background: rgba(9,9,15,0.8);
  backdrop-filter: blur(20px) saturate(1.2);
  border-top: 1px solid var(--purple-dim);
  padding: 12px 24px;
  display: none;
  align-items: center;
  justify-content: center;
  gap: 20px;
}
.viz-fullscreen .viz-fullscreen-controls { display: flex; }

/* SECTION HEADERS */
.section-header { padding:20px 28px 10px; display:flex; align-items:center; justify-content:space-between; }
.section-title { font-family:var(--font-display); font-weight:600; font-size:0.9rem; color:var(--purple-white); letter-spacing:0.06em; text-shadow:var(--glow-text); }
.section-see-all { font-family:var(--font-mono); font-size:0.65rem; color:var(--purple-muted); cursor:pointer; transition:color 0.2s; letter-spacing:0.08em; }
.section-see-all:hover { color:var(--purple-vivid); }

/* ALBUM GRID */
.album-grid { display:grid; grid-template-columns:repeat(auto-fill, minmax(170px, 1fr)); gap:20px; padding:10px 28px 20px; }
.album-grid.bottom-pad { padding-bottom:120px; }
.album-card { cursor:pointer; transition:transform 0.25s var(--ease-smooth), box-shadow 0.25s; }
.album-card:hover { transform:translateY(-6px) perspective(800px) rotateY(3deg) rotateX(-2deg); }
.album-art { aspect-ratio:1; border-radius:12px; overflow:hidden; position:relative; border:1px solid var(--purple-dim); transition:border-color 0.2s, box-shadow 0.2s; }
.album-card:hover .album-art { border-color:var(--purple-muted); box-shadow:var(--glow-medium); }
.album-art img { width:100%; height:100%; object-fit:cover; display:block; }
.album-art-bg { width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:linear-gradient(135deg, var(--purple-core), var(--purple-dim)); }
.album-art-icon svg { width:40px; height:40px; stroke:var(--purple-dim); fill:none; stroke-width:1; }
.album-play-overlay { position:absolute; inset:0; background:rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; opacity:0; transition:opacity 0.25s; }
.album-card:hover .album-play-overlay { opacity:1; }
.genre-card:hover { transform:translateY(-3px); border-color:var(--purple-bright) !important; box-shadow:0 0 20px rgba(157,78,221,0.2), 0 0 40px rgba(157,78,221,0.08); }
.album-play-btn { width:48px; height:48px; border-radius:50%; background:var(--purple-bright); display:flex; align-items:center; justify-content:center; box-shadow:var(--glow-intense); transform:scale(0.8); transition:transform 0.25s var(--ease-bounce); }
.album-card:hover .album-play-btn { transform:scale(1); }
.album-play-btn svg { width:20px; height:20px; fill:var(--purple-white); stroke:none; margin-left:2px; }
.album-info { padding:10px 4px; }
.album-name { font-family:var(--font-display); font-weight:600; font-size:0.7rem; color:var(--purple-white); letter-spacing:0.03em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-bottom:2px; }
.album-artist { font-family:var(--font-body); font-size:0.8rem; color:var(--purple-bright); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

/* TRACK LIST */
.track-list-container { padding:0 28px 120px; }
.track-list-header { display:grid; grid-template-columns:40px 2fr 1.5fr 1fr 80px 80px; padding:8px 12px; border-bottom:1px solid var(--purple-dim); margin-bottom:4px; gap:12px; align-items:center; }
.track-list-header span { font-family:var(--font-mono); font-size:0.65rem; color:var(--purple-muted); letter-spacing:0.1em; text-transform:uppercase; cursor:pointer; transition:color 0.2s; display:flex; align-items:center; gap:4px; }
.track-list-header span:hover { color:var(--purple-vivid); }
.sort-arrow { font-size:0.5rem; }
.track-row { display:grid; grid-template-columns:40px 2fr 1.5fr 1fr 80px 80px; padding:10px 12px; border-radius:8px; cursor:pointer; transition:background 0.15s, box-shadow 0.15s, opacity 0.3s, transform 0.3s; gap:12px; align-items:center; }
.track-row:hover { background:var(--bg-raised); box-shadow:var(--glow-subtle); }
.track-row.playing { background:rgba(123,47,190,0.1); }
.track-row.track-enter { animation:track-slide-in 0.35s var(--ease-smooth) both; }
@keyframes track-slide-in { from { opacity:0; transform:translateX(30px); } to { opacity:1; transform:translateX(0); } }
.track-num { font-family:var(--font-mono); font-size:0.75rem; color:var(--purple-bright); text-align:center; }
.track-row.playing .track-num { display:none; }
.eq-bars { display:none; align-items:flex-end; justify-content:center; gap:2px; height:16px; }
.track-row.playing .eq-bars { display:flex; }
.eq-bar { width:3px; background:var(--purple-bright); border-radius:1px; animation:eq-anim 0.5s infinite alternate; }
.eq-bar:nth-child(1) { height:6px; animation-delay:0s; }
.eq-bar:nth-child(2) { height:12px; animation-delay:0.15s; }
.eq-bar:nth-child(3) { height:8px; animation-delay:0.3s; }
.eq-bar:nth-child(4) { height:14px; animation-delay:0.1s; }
@keyframes eq-anim { 0% { height:4px; } 100% { height:16px; } }
.track-title-cell { display:flex; align-items:center; gap:10px; min-width:0; }
.track-art-small { width:36px; height:36px; border-radius:6px; flex-shrink:0; background:linear-gradient(135deg, var(--purple-core), var(--purple-dim)); overflow:hidden; }
.track-art-small img { width:100%; height:100%; object-fit:cover; display:block; }
.track-title-text { min-width:0; }
.track-title { font-family:var(--font-body); font-weight:600; font-size:0.9rem; color:var(--purple-white); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.track-row.playing .track-title { color:var(--purple-vivid); text-shadow:var(--glow-text); }
.track-artist-sub { font-size:0.75rem; color:var(--purple-bright); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.track-album { font-size:0.85rem; color:var(--purple-hot); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; opacity:0.7; }
.track-format { font-family:var(--font-mono); font-size:0.65rem; color:var(--purple-bright); text-align:center; }
.track-format.lossless { color:var(--purple-vivid); }
.track-duration { font-family:var(--font-mono); font-size:0.75rem; color:var(--purple-bright); text-align:right; }

/* NOW PLAYING BAR */
.now-playing { grid-column:2; background:var(--bg-surface); border-top:1px solid var(--purple-dim); display:grid; grid-template-columns:260px 1fr 200px; align-items:center; padding:0 20px; gap:16px; z-index:100; }
.np-left { display:flex; align-items:center; gap:12px; min-width:0; }
.np-art { width:52px; height:52px; border-radius:8px; background:linear-gradient(135deg, var(--purple-core), var(--purple-dim)); box-shadow:0 0 16px rgba(157,78,221,0.3); flex-shrink:0; overflow:hidden; transition:transform 0.3s; }
.np-art img { width:100%; height:100%; object-fit:cover; display:block; }
.np-art.rotating img { animation:art-rotate 30s linear infinite; }
.np-art.rotating-paused img { animation:art-rotate 30s linear infinite; animation-play-state:paused; }
@keyframes art-rotate { from { transform:rotate(0deg); } to { transform:rotate(360deg); } }
@keyframes art-glow-pulse { 0%,100% { box-shadow:0 0 12px rgba(157,78,221,0.2); } 50% { box-shadow:0 0 20px rgba(157,78,221,0.5); } }
.np-info { min-width:0; }
.np-title { font-family:var(--font-display); font-weight:600; font-size:0.8rem; color:var(--purple-white); text-shadow:var(--glow-text); letter-spacing:0.04em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.np-artist { font-family:var(--font-body); font-size:0.85rem; color:var(--purple-vivid); cursor:pointer; transition:color 0.2s; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.np-artist:hover { color:var(--purple-white); }
.np-album { font-family:var(--font-body); font-size:0.75rem; color:var(--purple-bright); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.np-center { display:flex; flex-direction:column; align-items:center; gap:8px; }
.transport { display:flex; align-items:center; gap:16px; }
.transport-btn { width:32px; height:32px; border:none; background:transparent; cursor:pointer; display:flex; align-items:center; justify-content:center; border-radius:50%; transition:background 0.2s, transform 0.1s; }
.transport-btn svg { width:16px; height:16px; stroke:var(--purple-muted); fill:none; stroke-width:1.5; transition:stroke 0.2s; }
.transport-btn:hover svg { stroke:var(--purple-vivid); }
.transport-btn:active { transform:scale(0.94); }
.transport-btn.active svg { stroke:var(--purple-bright); }
.transport-btn.shuffle.active svg, .transport-btn.repeat.active svg { stroke:var(--purple-vivid); filter:drop-shadow(0 0 4px rgba(183,110,255,0.6)); }
.play-btn { width:42px; height:42px; border:none; border-radius:50%; background:var(--purple-bright); cursor:pointer; display:flex; align-items:center; justify-content:center; box-shadow:0 0 20px rgba(157,78,221,0.5); transition:background 0.2s, box-shadow 0.2s, transform 0.15s; }
.play-btn:hover { background:var(--purple-vivid); box-shadow:var(--glow-intense); }
.play-btn:active { transform:scale(0.94); }
.play-btn svg { width:18px; height:18px; fill:var(--purple-white); stroke:none; }
.play-btn .pause-icon { display:none; }
.play-btn.playing .play-icon { display:none; }
.play-btn.playing .pause-icon { display:block; }
.seek-container { width:100%; max-width:600px; display:flex; align-items:center; gap:8px; }
.seek-time { font-family:var(--font-mono); font-size:0.6rem; color:var(--purple-bright); min-width:36px; text-align:center; }
.waveform-container { flex:1; height:28px; display:flex; align-items:flex-end; gap:1px; cursor:pointer; position:relative; overflow:hidden; }
.waveform-bar { flex:1; background:var(--purple-dim); border-radius:1px 1px 0 0; min-width:2px; transition:background 0.1s; }
.waveform-bar.played { background:var(--purple-bright); }
.waveform-bar:hover { background:var(--purple-vivid) !important; }
.waveform-container::after { content:''; position:absolute; top:0; left:0; width:60px; height:100%; background:linear-gradient(90deg, rgba(183,110,255,0.15), transparent); animation:shimmer 3s infinite linear; pointer-events:none; }
@keyframes shimmer { 0% { left:-60px; } 100% { left:100%; } }
.np-right { display:flex; align-items:center; justify-content:flex-end; gap:12px; }
.volume-group { display:flex; align-items:center; gap:8px; }
.volume-btn { border:none; background:none; cursor:pointer; display:flex; align-items:center; justify-content:center; transition:transform 0.1s; }
.volume-btn:active { transform:scale(0.94); }
.volume-btn svg { width:16px; height:16px; stroke:var(--purple-muted); fill:none; stroke-width:1.5; transition:stroke 0.2s; }
.volume-btn:hover svg { stroke:var(--purple-vivid); }
.volume-slider { -webkit-appearance:none; width:80px; height:4px; background:var(--purple-dim); border-radius:2px; outline:none; cursor:pointer; }
.volume-slider::-webkit-slider-thumb { -webkit-appearance:none; width:12px; height:12px; border-radius:50%; background:var(--purple-bright); box-shadow:0 0 6px rgba(157,78,221,0.5); cursor:pointer; transition:transform 0.15s; }
.volume-slider::-webkit-slider-thumb:hover { transform:scale(1.3); }
.quality-badge { font-family:var(--font-mono); font-size:0.55rem; color:var(--purple-bright); border:1px solid var(--purple-dim); border-radius:4px; padding:2px 6px; letter-spacing:0.05em; white-space:nowrap; }

/* SEARCH OVERLAY */
.search-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.85); backdrop-filter:blur(30px) saturate(1.2); z-index:9998; display:flex; align-items:flex-start; justify-content:center; padding-top:15vh; opacity:0; pointer-events:none; transition:opacity 0.3s; }
.search-overlay.open { opacity:1; pointer-events:all; }
.search-modal { width:90%; max-width:580px; transform:scale(0.92) translateY(10px); transition:transform 0.3s var(--ease-smooth), filter 0.3s; filter:blur(4px); }
.search-overlay.open .search-modal { transform:scale(1) translateY(0); filter:blur(0); }
.search-modal-input { width:100%; padding:16px 20px; background:var(--bg-surface); border:1px solid var(--purple-dim); border-radius:12px; font-family:var(--font-display); font-weight:500; font-size:1.1rem; color:var(--purple-white); outline:none; transition:border-color 0.2s, box-shadow 0.2s; }
.search-modal-input::placeholder { color:var(--purple-muted); }
.search-modal-input:focus { border-color:var(--purple-bright); box-shadow:var(--glow-medium); }
.search-results { max-height:400px; overflow-y:auto; margin-top:8px; background:var(--bg-surface); border:1px solid var(--purple-dim); border-radius:12px; display:none; }
.search-results.has-results { display:block; }
.search-result-section { padding:8px 0; }
.search-result-section-title { font-family:var(--font-mono); font-size:0.6rem; color:var(--purple-muted); letter-spacing:0.12em; padding:4px 16px; text-transform:uppercase; }
.search-result-item { display:flex; align-items:center; gap:10px; padding:8px 16px; cursor:pointer; transition:background 0.15s; }
.search-result-item:hover { background:var(--bg-raised); }
.search-result-art { width:36px; height:36px; border-radius:6px; overflow:hidden; flex-shrink:0; background:linear-gradient(135deg, var(--purple-core), var(--purple-dim)); }
.search-result-art img { width:100%; height:100%; object-fit:cover; }
.search-result-info { min-width:0; flex:1; }
.search-result-title { font-size:0.9rem; color:var(--purple-white); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.search-result-sub { font-size:0.75rem; color:var(--purple-muted); }
.search-hint { font-family:var(--font-mono); font-size:0.6rem; color:var(--purple-muted); text-align:center; margin-top:12px; letter-spacing:0.08em; }

/* QUEUE PANEL */
.queue-panel { position:fixed; top:var(--titlebar-h); right:-340px; bottom:var(--nowplaying-h); width:340px; background:var(--bg-surface); border-left:1px solid var(--purple-dim); z-index:200; transition:right 0.35s var(--ease-smooth); display:flex; flex-direction:column; overflow:hidden; }
.queue-panel.open { right:0; }
.queue-header { padding:16px 20px; border-bottom:1px solid var(--purple-dim); display:flex; align-items:center; justify-content:space-between; }
.queue-title { font-family:var(--font-display); font-weight:600; font-size:0.85rem; color:var(--purple-white); letter-spacing:0.08em; }
.queue-close { width:28px; height:28px; border:none; background:transparent; cursor:pointer; display:flex; align-items:center; justify-content:center; border-radius:6px; transition:background 0.2s, transform 0.1s; }
.queue-close:hover { background:var(--bg-raised); }
.queue-close:active { transform:scale(0.94); }
.queue-close svg { width:14px; height:14px; stroke:var(--purple-muted); fill:none; stroke-width:1.5; }
.queue-now { padding:12px 20px; border-bottom:1px solid rgba(42,27,61,0.3); }
.queue-now-label { font-family:var(--font-mono); font-size:0.55rem; color:var(--purple-bright); letter-spacing:0.15em; margin-bottom:8px; }
.queue-now-track { display:flex; align-items:center; gap:10px; }
.queue-now-art { width:40px; height:40px; border-radius:6px; background:linear-gradient(135deg, var(--purple-core), var(--purple-dim)); flex-shrink:0; overflow:hidden; }
.queue-now-art img { width:100%; height:100%; object-fit:cover; }
.queue-now-info .queue-track-title { font-family:var(--font-body); font-weight:600; font-size:0.85rem; color:var(--purple-vivid); }
.queue-now-info .queue-track-artist { font-size:0.75rem; color:var(--purple-muted); }
.queue-list { flex:1; overflow-y:auto; padding:8px 12px; }
.queue-list-label { font-family:var(--font-mono); font-size:0.55rem; color:var(--purple-muted); letter-spacing:0.12em; padding:8px; }
.queue-item { display:flex; align-items:center; gap:10px; padding:8px; border-radius:6px; cursor:pointer; transition:background 0.15s; }
.queue-item:hover { background:var(--bg-raised); }
.queue-item-art { width:34px; height:34px; border-radius:5px; background:linear-gradient(135deg, var(--purple-dim), var(--bg-raised)); flex-shrink:0; overflow:hidden; }
.queue-item-art img { width:100%; height:100%; object-fit:cover; }
.queue-item-info { min-width:0; flex:1; }
.queue-item-title { font-size:0.8rem; color:var(--purple-white); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.queue-item-artist { font-size:0.7rem; color:var(--purple-muted); }
.queue-item-dur { font-family:var(--font-mono); font-size:0.6rem; color:var(--purple-muted); }

/* CONTEXT MENU */
.context-menu { position:fixed; background:var(--bg-surface); border:1px solid var(--purple-dim); border-radius:8px; padding:4px; min-width:180px; z-index:10000; box-shadow:0 8px 32px rgba(0,0,0,0.6); display:none; }
.context-menu.visible { display:block; animation:ctx-in 0.15s var(--ease-smooth); }
@keyframes ctx-in { from { opacity:0; transform:scale(0.95); } to { opacity:1; transform:scale(1); } }
.context-menu-item { padding:8px 12px; font-family:var(--font-body); font-size:0.85rem; color:var(--purple-hot); border-radius:6px; cursor:pointer; transition:background 0.15s; display:flex; align-items:center; gap:8px; position:relative; }
.context-menu-item:hover { background:var(--bg-raised); }
.context-menu-item svg { width:14px; height:14px; stroke:var(--purple-muted); fill:none; stroke-width:1.5; }
.context-submenu { position:absolute; left:100%; top:0; background:var(--bg-surface); border:1px solid var(--purple-dim); border-radius:8px; padding:4px; min-width:160px; display:none; box-shadow:0 8px 32px rgba(0,0,0,0.6); }
.context-menu-item:hover .context-submenu { display:block; }
.context-submenu-item { padding:6px 12px; font-size:0.8rem; color:var(--purple-hot); border-radius:4px; cursor:pointer; transition:background 0.15s; white-space:nowrap; }
.context-submenu-item:hover { background:var(--bg-raised); }

/* TOAST SYSTEM */
.toast-container { position:fixed; top:calc(var(--titlebar-h) + 12px); right:12px; z-index:10001; display:flex; flex-direction:column; gap:8px; pointer-events:none; }
.toast { background:var(--bg-surface); border:1px solid var(--purple-dim); border-radius:8px; padding:10px 16px; min-width:250px; max-width:350px; pointer-events:auto; animation:toast-in 0.35s var(--ease-smooth); position:relative; overflow:hidden; }
.toast.removing { animation:toast-out 0.3s var(--ease-smooth) forwards; }
@keyframes toast-in { from { opacity:0; transform:translateX(100px); } to { opacity:1; transform:translateX(0); } }
@keyframes toast-out { from { opacity:1; transform:translateX(0); } to { opacity:0; transform:translateX(100px); } }
.toast-text { font-family:var(--font-body); font-size:0.85rem; color:var(--purple-white); }
.toast-progress { position:absolute; bottom:0; left:0; height:2px; background:var(--purple-bright); animation:toast-progress 3s linear forwards; }
@keyframes toast-progress { from { width:100%; } to { width:0%; } }

/* CONTENT FADE TRANSITION */
.content-fade-out { animation:content-out 0.15s var(--ease-smooth) forwards; }
.content-fade-in { animation:content-in 0.3s var(--ease-smooth) forwards; }
@keyframes content-out { from { opacity:1; } to { opacity:0; } }
@keyframes content-in { from { opacity:0; } to { opacity:1; } }

/* HIDDEN */
.view-hidden { display:none !important; }

/* BUTTON PRESS */
button:active, .album-card:active { transform:scale(0.94); transition-duration:0.1s; }
.album-card:active { transform:scale(0.97); }

/* RESPONSIVE */
@media (max-width:900px) { .now-playing { grid-template-columns:200px 1fr 120px; } .album-grid { grid-template-columns:repeat(auto-fill, minmax(140px, 1fr)); } }
@media (max-width:600px) { .now-playing { grid-template-columns:1fr; grid-template-rows:auto auto auto; gap:6px; padding:8px 14px; } :root { --nowplaying-h:140px; } .np-center { width:100%; } .np-right { justify-content:center; } .track-list-header,.track-row { grid-template-columns:30px 2fr 80px; } .track-album,.track-format { display:none; } }

/* Beat-reactive properties (set by JS) */
.main-content::before {
  content: '';
  position: fixed;
  top: 50%; left: 50%;
  width: 100vw; height: 100vh;
  transform: translate(-50%, -50%);
  background: radial-gradient(ellipse at center, rgba(0,180,216, calc(var(--beat, 0) * 0.06)) 0%, transparent 70%);
  pointer-events: none;
  z-index: 0;
  transition: background 0.1s;
}

.now-playing {
  border-top: 1px solid var(--purple-dim);
  box-shadow: 0 calc(-1px - var(--beat, 0) * 3px) calc(6px + var(--beat, 0) * 20px) rgba(0, 200, 240, calc(0.05 + var(--beat, 0) * 0.25));
  transition: box-shadow 0.08s;
}

.np-art {
  box-shadow: 0 0 calc(12px + var(--bass, 0) * 30px) rgba(0, 220, 255, calc(0.1 + var(--bass, 0) * 0.5)), 0 0 calc(6px + var(--bass, 0) * 15px) rgba(157, 78, 221, calc(0.2 + var(--bass, 0) * 0.3));
  transition: box-shadow 0.08s;
}

.sidebar {
  border-right: 1px solid var(--purple-dim);
  box-shadow: calc(1px + var(--energy, 0) * 3px) 0 calc(4px + var(--energy, 0) * 12px) rgba(157, 78, 221, calc(0.05 + var(--energy, 0) * 0.15));
  transition: box-shadow 0.12s;
}

.titlebar .logo-p {
  box-shadow: 0 0 calc(4px + var(--beat, 0) * 12px) rgba(0, 220, 245, calc(0.1 + var(--beat, 0) * 0.6));
  transition: box-shadow 0.08s;
}

.beat-dot {
  width: 6px; height: 6px;
  border-radius: 50%;
  background: var(--cyan-bright);
  box-shadow: 0 0 calc(4px + var(--beat, 0) * 10px) rgba(0, 220, 245, calc(0.3 + var(--beat, 0) * 0.7));
  transition: box-shadow 0.05s, transform 0.05s;
  transform: scale(calc(0.8 + var(--beat, 0) * 0.6));
}

.track-format.lossless {
  color: var(--cyan-bright) !important;
  border-color: var(--cyan-dim) !important;
}

.quality-badge.lossless-badge {
  color: var(--cyan-bright);
  border-color: var(--cyan-dim);
}

.viz-scene-name {
  color: var(--cyan-bright) !important;
  text-shadow: 0 0 8px rgba(0, 220, 245, 0.5) !important;
}

.waveform-bar.played {
  background: linear-gradient(to top, var(--purple-bright), var(--cyan-core)) !important;
}

.eq-bar:nth-child(even) {
  background: var(--cyan-bright);
}

/* ============ VISUAL PREMIUM UPGRADE ============ */

/* FILM GRAIN OVERLAY — atmospheric texture */
body::after {
  content: '';
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 99999;
  opacity: 0.025;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
  background-size: 128px 128px;
  mix-blend-mode: overlay;
  animation: grain-drift 8s steps(10) infinite;
}
@keyframes grain-drift {
  0%, 100% { transform: translate(0, 0); }
  10% { transform: translate(-5%, -10%); }
  20% { transform: translate(-15%, 5%); }
  30% { transform: translate(7%, -25%); }
  40% { transform: translate(-5%, 25%); }
  50% { transform: translate(-15%, 10%); }
  60% { transform: translate(15%, 0%); }
  70% { transform: translate(0%, 15%); }
  80% { transform: translate(3%, 25%); }
  90% { transform: translate(-10%, 10%); }
}

/* ANIMATED GRADIENT BORDER on visualizer panel */
.visualizer-panel {
  position: relative;
  border: none !important;
  background: var(--bg-void);
}
.visualizer-panel::before {
  content: '';
  position: absolute;
  inset: -1px;
  border-radius: 17px;
  padding: 1px;
  background: linear-gradient(
    var(--border-angle, 0deg),
    var(--purple-dim) 0%,
    var(--purple-core) 25%,
    var(--cyan-core) 50%,
    var(--purple-core) 75%,
    var(--purple-dim) 100%
  );
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  z-index: 1;
  pointer-events: none;
  animation: border-rotate 4s linear infinite;
  opacity: 0.6;
  transition: opacity 0.3s;
}
.visualizer-panel:hover::before {
  opacity: 1;
}
@property --border-angle {
  syntax: '<angle>';
  initial-value: 0deg;
  inherits: false;
}
@keyframes border-rotate {
  to { --border-angle: 360deg; }
}

/* VISUALIZER PANEL — beat-reactive outer glow */
.visualizer-panel {
  box-shadow:
    0 0 calc(8px + var(--bass, 0) * 30px) rgba(0, 220, 245, calc(0.05 + var(--bass, 0) * 0.2)),
    0 0 calc(20px + var(--bass, 0) * 60px) rgba(123, 47, 190, calc(0.05 + var(--bass, 0) * 0.15)),
    inset 0 0 60px rgba(0, 0, 0, 0.5) !important;
  transition: box-shadow 0.08s !important;
}

/* ALBUM CARDS — premium hover with glow bleed */
.album-card {
  position: relative;
}
.album-card::after {
  content: '';
  position: absolute;
  inset: -8px;
  border-radius: 20px;
  background: radial-gradient(ellipse at center, rgba(157, 78, 221, 0.15), transparent 70%);
  opacity: 0;
  transition: opacity 0.4s;
  pointer-events: none;
  z-index: -1;
}
.album-card:hover::after {
  opacity: 1;
}
.album-card:hover .album-art {
  border-color: var(--purple-bright) !important;
  box-shadow: 0 0 20px rgba(157, 78, 221, 0.4), 0 0 50px rgba(123, 47, 190, 0.2), 0 4px 20px rgba(0, 0, 0, 0.5) !important;
}

/* TRACK ROW — playing state glow + animated left edge */
.track-row.playing {
  background: linear-gradient(90deg, rgba(123, 47, 190, 0.15) 0%, rgba(0, 220, 245, 0.03) 30%, transparent 100%) !important;
  border-left: 2px solid var(--purple-bright);
  box-shadow: inset 4px 0 16px rgba(157, 78, 221, 0.2), 0 0 12px rgba(157, 78, 221, 0.08);
}
.track-row:hover {
  background: linear-gradient(90deg, rgba(15, 15, 26, 0.8) 0%, var(--bg-raised) 100%) !important;
  box-shadow: 0 0 16px rgba(157, 78, 221, 0.1), var(--glow-subtle) !important;
}

/* NOW PLAYING BAR — glass gradient background */
.now-playing {
  background: linear-gradient(180deg, var(--bg-surface) 0%, rgba(9, 9, 15, 0.95) 100%) !important;
  backdrop-filter: blur(20px) saturate(1.3);
}

/* PLAY BUTTON — breathing glow pulse when playing */
.play-btn.playing {
  animation: play-glow-breathe 2s ease-in-out infinite;
}
@keyframes play-glow-breathe {
  0%, 100% { box-shadow: 0 0 20px rgba(157, 78, 221, 0.5), 0 0 40px rgba(123, 47, 190, 0.2); }
  50% { box-shadow: 0 0 30px rgba(0, 220, 245, 0.4), 0 0 60px rgba(157, 78, 221, 0.3), 0 0 80px rgba(123, 47, 190, 0.15); }
}

/* TRANSPORT BUTTONS — glow on hover */
.transport-btn:hover {
  background: rgba(123, 47, 190, 0.15);
  box-shadow: 0 0 12px rgba(157, 78, 221, 0.3);
}
.transport-btn:hover svg {
  filter: drop-shadow(0 0 4px rgba(183, 110, 255, 0.5));
}

/* QUEUE PANEL — glassmorphism */
.queue-panel {
  background: rgba(9, 9, 15, 0.85) !important;
  backdrop-filter: blur(24px) saturate(1.3);
  border-left-color: rgba(42, 27, 61, 0.6) !important;
  box-shadow: -8px 0 40px rgba(0, 0, 0, 0.5), -2px 0 20px rgba(123, 47, 190, 0.1);
}

/* CONTEXT MENU — glassmorphism + glow */
.context-menu {
  background: rgba(9, 9, 15, 0.9) !important;
  backdrop-filter: blur(24px) saturate(1.3);
  box-shadow: 0 8px 40px rgba(0, 0, 0, 0.7), 0 0 20px rgba(123, 47, 190, 0.1), 0 0 1px rgba(157, 78, 221, 0.3) !important;
}
.context-menu-item:hover {
  background: rgba(123, 47, 190, 0.1) !important;
}

/* SIDEBAR — subtle inner glow and better active states */
.sidebar {
  background: linear-gradient(180deg, var(--bg-surface) 0%, rgba(9, 9, 15, 0.98) 100%) !important;
}
.nav-item.active {
  background: linear-gradient(90deg, rgba(123, 47, 190, 0.18) 0%, transparent 100%) !important;
}
.nav-item.active::before {
  box-shadow: 0 0 14px rgba(0, 220, 245, 0.5), 0 0 30px rgba(157, 78, 221, 0.3) !important;
  background: linear-gradient(180deg, var(--cyan-core), var(--purple-bright)) !important;
}
.nav-item:hover {
  background: linear-gradient(90deg, rgba(123, 47, 190, 0.08) 0%, transparent 100%) !important;
}

/* SEARCH BAR — floating glow on focus */
.search-bar:focus-within {
  border-color: var(--purple-bright) !important;
  box-shadow: 0 0 16px rgba(157, 78, 221, 0.3), 0 0 40px rgba(123, 47, 190, 0.1), var(--glow-subtle) !important;
}

/* SEARCH OVERLAY — more dramatic glass */
.search-overlay {
  background: rgba(0, 0, 0, 0.9) !important;
  backdrop-filter: blur(40px) saturate(1.4) !important;
}

/* TITLEBAR — subtle gradient */
.titlebar {
  background: linear-gradient(90deg, var(--bg-surface) 0%, rgba(15, 15, 26, 0.95) 50%, var(--bg-surface) 100%) !important;
  border-bottom: 1px solid rgba(42, 27, 61, 0.5) !important;
}

/* WAVEFORM — glowing played bars */
.waveform-container {
  filter: drop-shadow(0 0 2px rgba(157, 78, 221, 0.3));
}
.waveform-bar.played {
  box-shadow: 0 0 4px rgba(0, 180, 216, 0.4);
}

/* VOLUME SLIDER — glow track + cyan accent */
.volume-slider {
  background: linear-gradient(90deg, var(--purple-muted), var(--purple-dim)) !important;
}
.volume-slider::-webkit-slider-thumb {
  background: linear-gradient(135deg, var(--purple-bright), var(--cyan-core)) !important;
  box-shadow: 0 0 8px rgba(0, 220, 245, 0.4), 0 0 16px rgba(157, 78, 221, 0.3) !important;
}

/* QUALITY BADGE — subtle glow */
.quality-badge {
  box-shadow: 0 0 8px rgba(42, 27, 61, 0.3);
  transition: box-shadow 0.2s, border-color 0.2s;
}
.quality-badge:hover {
  border-color: var(--purple-muted);
  box-shadow: 0 0 12px rgba(157, 78, 221, 0.2);
}

/* TOAST — glass with glow edge */
.toast {
  background: rgba(9, 9, 15, 0.9) !important;
  backdrop-filter: blur(20px) saturate(1.3);
  border-color: rgba(157, 78, 221, 0.3) !important;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5), 0 0 1px rgba(157, 78, 221, 0.4);
}

/* CONTENT TITLE — glow accent line */
.content-title {
  position: relative;
  padding-bottom: 8px;
}
.content-title::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 50px;
  height: 1.5px;
  background: linear-gradient(90deg, transparent, var(--purple-bright), var(--cyan-core), var(--purple-bright), transparent);
  border-radius: 1px;
  box-shadow: 0 0 8px rgba(0, 220, 245, 0.3);
}

/* ALBUM PLAY OVERLAY — more cinematic */
.album-play-overlay {
  background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.75) 100%) !important;
}
.album-play-btn {
  background: linear-gradient(135deg, var(--purple-bright), var(--cyan-core)) !important;
  box-shadow: 0 0 30px rgba(0, 220, 245, 0.4), 0 0 60px rgba(157, 78, 221, 0.3) !important;
}

/* NP ART — ambient color bleed */
.np-art::after {
  content: '';
  position: absolute;
  inset: -20px;
  background: radial-gradient(ellipse at center,
    rgba(157, 78, 221, calc(0.15 + var(--bass, 0) * 0.3)),
    transparent 70%
  );
  pointer-events: none;
  z-index: -1;
  transition: background 0.1s;
}
.np-left { position: relative; overflow: visible; }

/* SECTION HEADERS — more premium */
.section-title {
  position: relative;
}

/* EQ BARS — taller, more dramatic */
.eq-bar { min-height: 2px; transition: height 0.1s; }

/* SCROLLBAR — glow on hover */
::-webkit-scrollbar-thumb:hover {
  box-shadow: 0 0 6px rgba(157, 78, 221, 0.5);
}

/* Floating ambient particles canvas */
#ambientParticles {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 1;
  opacity: 0.4;
}

/* SETTINGS/CREATE MODAL inputs — glow focus */
#settingsOverlay input:focus,
#settingsOverlay select:focus,
#createPlaylistModal input:focus {
  border-color: var(--purple-bright) !important;
  box-shadow: 0 0 12px rgba(157, 78, 221, 0.3), var(--glow-subtle) !important;
}

/* PLAYLIST DOT — pulse animation */
.playlist-dot {
  animation: playlist-dot-pulse 3s ease-in-out infinite;
}
.playlist-dot:nth-child(1) { animation-delay: 0s; }
.playlist-dot:nth-child(2) { animation-delay: 0.5s; }
@keyframes playlist-dot-pulse {
  0%, 100% { box-shadow: none; opacity: 0.6; }
  50% { box-shadow: 0 0 6px rgba(157, 78, 221, 0.5); opacity: 1; }
}

/* SECTION DIVIDERS — gradient lines */
.sidebar-divider {
  background: linear-gradient(90deg, transparent, var(--purple-dim), transparent) !important;
}

/* Track list header — subtle glow underline */
.track-list-header {
  border-bottom: 1px solid transparent !important;
  background-image: linear-gradient(var(--bg-void), var(--bg-void)), linear-gradient(90deg, transparent, var(--purple-dim), var(--cyan-dim), var(--purple-dim), transparent);
  background-origin: border-box;
  background-clip: padding-box, border-box;
  border-bottom: 1px solid var(--purple-dim) !important;
}

/* ============ BEAT-REACTIVE AURAS + MAGENTA ACCENTS ============ */

/* CONTENT TITLE — breathing text aura that pulses with beat */
.content-title {
  text-shadow:
    0 0 calc(4px + var(--beat, 0) * 16px) rgba(183, 110, 255, calc(0.3 + var(--beat, 0) * 0.6)),
    0 0 calc(8px + var(--beat, 0) * 30px) rgba(255, 45, 123, calc(0.05 + var(--beat, 0) * 0.2)),
    0 0 calc(2px + var(--energy, 0) * 8px) rgba(0, 220, 245, calc(0.05 + var(--energy, 0) * 0.15)) !important;
  transition: text-shadow 0.08s !important;
}
.content-title::after {
  background: linear-gradient(90deg, var(--purple-bright), var(--magenta-bright), var(--cyan-core), transparent) !important;
}

/* SECTION TITLES — soft aura pulse */
.section-title {
  text-shadow:
    0 0 calc(3px + var(--energy, 0) * 10px) rgba(183, 110, 255, calc(0.2 + var(--energy, 0) * 0.4)),
    0 0 calc(6px + var(--beat, 0) * 16px) rgba(255, 45, 123, calc(0.02 + var(--beat, 0) * 0.12)) !important;
  transition: text-shadow 0.1s !important;
}

/* NOW PLAYING TITLE — prominent beat aura */
.np-title {
  text-shadow:
    0 0 calc(4px + var(--beat, 0) * 14px) rgba(183, 110, 255, calc(0.4 + var(--beat, 0) * 0.5)),
    0 0 calc(8px + var(--bass, 0) * 20px) rgba(255, 45, 123, calc(0.05 + var(--bass, 0) * 0.25)),
    0 0 calc(2px + var(--high, 0) * 8px) rgba(0, 220, 245, calc(0.05 + var(--high, 0) * 0.15)) !important;
  transition: text-shadow 0.06s !important;
}

/* NP ARTIST — soft magenta glow */
.np-artist {
  text-shadow:
    0 0 calc(3px + var(--mid, 0) * 8px) rgba(255, 107, 168, calc(0.1 + var(--mid, 0) * 0.3)) !important;
  transition: text-shadow 0.1s !important;
}

/* TITLEBAR LOGO — triple-color aura */
.titlebar-logo {
  text-shadow:
    0 0 calc(3px + var(--beat, 0) * 10px) rgba(183, 110, 255, calc(0.3 + var(--beat, 0) * 0.5)),
    0 0 calc(6px + var(--beat, 0) * 18px) rgba(255, 45, 123, calc(0.05 + var(--beat, 0) * 0.2)),
    0 0 calc(1px + var(--energy, 0) * 6px) rgba(0, 220, 245, calc(0.05 + var(--energy, 0) * 0.1)) !important;
  transition: text-shadow 0.08s !important;
}

/* LOGO P BOX — magenta-tinged glow on beat */
.titlebar .logo-p {
  box-shadow:
    0 0 calc(4px + var(--beat, 0) * 12px) rgba(0, 220, 245, calc(0.1 + var(--beat, 0) * 0.4)),
    0 0 calc(2px + var(--beat, 0) * 8px) rgba(255, 45, 123, calc(0.05 + var(--beat, 0) * 0.25)),
    inset 0 0 calc(2px + var(--beat, 0) * 4px) rgba(255, 45, 123, calc(0.02 + var(--beat, 0) * 0.1)) !important;
  border-color: rgba(255, 45, 123, calc(0.2 + var(--beat, 0) * 0.5));
  transition: box-shadow 0.06s, border-color 0.06s !important;
}

/* SIDEBAR NAV ITEMS — soft aura on active */
.nav-item.active {
  box-shadow:
    inset 3px 0 calc(8px + var(--energy, 0) * 16px) rgba(255, 45, 123, calc(0.04 + var(--energy, 0) * 0.1)),
    inset 0 0 calc(12px + var(--energy, 0) * 20px) rgba(157, 78, 221, calc(0.03 + var(--energy, 0) * 0.08));
  transition: box-shadow 0.12s !important;
}

/* SIDEBAR — soft magenta edge glow mixed with purple */
.sidebar {
  box-shadow:
    calc(1px + var(--energy, 0) * 3px) 0 calc(4px + var(--energy, 0) * 12px) rgba(157, 78, 221, calc(0.05 + var(--energy, 0) * 0.12)),
    calc(0.5px + var(--bass, 0) * 2px) 0 calc(8px + var(--bass, 0) * 16px) rgba(255, 45, 123, calc(0.02 + var(--bass, 0) * 0.06)) !important;
  transition: box-shadow 0.1s !important;
}

/* NOW PLAYING BAR — magenta accent in the glow */
.now-playing {
  box-shadow:
    0 calc(-1px - var(--beat, 0) * 3px) calc(6px + var(--beat, 0) * 20px) rgba(0, 200, 240, calc(0.05 + var(--beat, 0) * 0.2)),
    0 calc(-1px - var(--bass, 0) * 2px) calc(10px + var(--bass, 0) * 25px) rgba(255, 45, 123, calc(0.02 + var(--bass, 0) * 0.1)),
    0 -1px calc(4px + var(--energy, 0) * 10px) rgba(157, 78, 221, calc(0.05 + var(--energy, 0) * 0.1)) !important;
  transition: box-shadow 0.06s !important;
}

/* NP ART — magenta/cyan/purple triple halo */
.np-art {
  box-shadow:
    0 0 calc(12px + var(--bass, 0) * 30px) rgba(0, 220, 255, calc(0.08 + var(--bass, 0) * 0.35)),
    0 0 calc(8px + var(--bass, 0) * 20px) rgba(255, 45, 123, calc(0.05 + var(--bass, 0) * 0.2)),
    0 0 calc(6px + var(--bass, 0) * 15px) rgba(157, 78, 221, calc(0.15 + var(--bass, 0) * 0.25)) !important;
  transition: box-shadow 0.06s !important;
}

/* VISUALIZER PANEL — triple-color reactive border glow */
.visualizer-panel {
  box-shadow:
    0 0 calc(8px + var(--bass, 0) * 30px) rgba(0, 220, 245, calc(0.04 + var(--bass, 0) * 0.15)),
    0 0 calc(12px + var(--bass, 0) * 40px) rgba(255, 45, 123, calc(0.02 + var(--bass, 0) * 0.08)),
    0 0 calc(20px + var(--bass, 0) * 60px) rgba(123, 47, 190, calc(0.04 + var(--bass, 0) * 0.12)),
    inset 0 0 60px rgba(0, 0, 0, 0.5) !important;
  transition: box-shadow 0.06s !important;
}

/* PLAY BUTTON — magenta accent glow when playing */
.play-btn.playing {
  animation: play-glow-breathe-v2 2s ease-in-out infinite !important;
}
@keyframes play-glow-breathe-v2 {
  0%, 100% {
    box-shadow: 0 0 20px rgba(157, 78, 221, 0.5), 0 0 40px rgba(123, 47, 190, 0.2);
  }
  33% {
    box-shadow: 0 0 25px rgba(0, 220, 245, 0.4), 0 0 50px rgba(157, 78, 221, 0.25), 0 0 70px rgba(123, 47, 190, 0.1);
  }
  66% {
    box-shadow: 0 0 25px rgba(255, 45, 123, 0.35), 0 0 50px rgba(157, 78, 221, 0.2), 0 0 70px rgba(212, 20, 122, 0.1);
  }
}

/* ALBUM CARDS — magenta hover accent */
.album-card:hover .album-art {
  box-shadow:
    0 0 20px rgba(157, 78, 221, 0.35),
    0 0 40px rgba(255, 45, 123, 0.1),
    0 0 50px rgba(123, 47, 190, 0.15),
    0 4px 20px rgba(0, 0, 0, 0.5) !important;
}
.album-card::after {
  background: radial-gradient(ellipse at center, rgba(255, 45, 123, 0.06), rgba(157, 78, 221, 0.1), transparent 70%) !important;
}

/* ALBUM PLAY BUTTON — magenta gradient */
.album-play-btn {
  background: linear-gradient(135deg, var(--purple-bright), var(--magenta-bright), var(--cyan-core)) !important;
  box-shadow: 0 0 30px rgba(255, 45, 123, 0.3), 0 0 60px rgba(157, 78, 221, 0.2) !important;
}

/* TRACK ROW — playing state with magenta accent */
.track-row.playing {
  background: linear-gradient(90deg, rgba(255, 45, 123, 0.06) 0%, rgba(123, 47, 190, 0.12) 15%, rgba(0, 220, 245, 0.02) 40%, transparent 100%) !important;
  border-left: 2px solid var(--magenta-bright) !important;
  box-shadow:
    inset 4px 0 16px rgba(255, 45, 123, 0.1),
    inset 0 0 20px rgba(157, 78, 221, 0.05),
    0 0 calc(6px + var(--beat, 0) * 12px) rgba(255, 45, 123, calc(0.02 + var(--beat, 0) * 0.08)) !important;
  transition: box-shadow 0.08s !important;
}

/* CURRENTLY PLAYING TRACK TITLE — aura pulse */
.track-row.playing .track-title {
  text-shadow:
    0 0 calc(4px + var(--beat, 0) * 10px) rgba(183, 110, 255, calc(0.3 + var(--beat, 0) * 0.5)),
    0 0 calc(2px + var(--beat, 0) * 6px) rgba(255, 45, 123, calc(0.05 + var(--beat, 0) * 0.15)) !important;
  transition: text-shadow 0.08s !important;
}

/* QUEUE PANEL HEADER — magenta accent */
.queue-title {
  text-shadow:
    0 0 calc(3px + var(--energy, 0) * 8px) rgba(183, 110, 255, calc(0.2 + var(--energy, 0) * 0.3)),
    0 0 calc(6px + var(--beat, 0) * 12px) rgba(255, 45, 123, calc(0.03 + var(--beat, 0) * 0.1));
  transition: text-shadow 0.1s;
}

/* QUEUE NOW PLAYING — reactive glow */
.queue-now {
  box-shadow:
    inset 0 0 calc(8px + var(--bass, 0) * 20px) rgba(255, 45, 123, calc(0.02 + var(--bass, 0) * 0.06)),
    inset 0 0 calc(12px + var(--energy, 0) * 16px) rgba(157, 78, 221, calc(0.02 + var(--energy, 0) * 0.05));
  transition: box-shadow 0.1s;
}

/* WAVEFORM SEEK BAR — magenta shimmer */
.waveform-container::after {
  background: linear-gradient(90deg, rgba(255, 45, 123, 0.15), rgba(0, 220, 245, 0.1), transparent) !important;
}

/* WAVEFORM PLAYED BARS — purple-magenta-cyan gradient */
.waveform-bar.played {
  background: linear-gradient(to top, var(--purple-bright), var(--magenta-bright), var(--cyan-core)) !important;
}

/* SEARCH MODAL INPUT — magenta focus glow */
.search-modal-input:focus {
  box-shadow:
    0 0 16px rgba(157, 78, 221, 0.3),
    0 0 30px rgba(255, 45, 123, 0.08),
    var(--glow-subtle) !important;
}

/* SIDEBAR DIVIDERS — magenta center */
.sidebar-divider {
  background: linear-gradient(90deg, transparent, var(--purple-dim), var(--magenta-dim), var(--purple-dim), transparent) !important;
}

/* PLAYLIST DOT — magenta variants */
.playlist-dot:nth-child(3n) {
  background: var(--magenta-muted) !important;
}
.playlist-dot:nth-child(3n+1) {
  background: var(--purple-bright) !important;
}

/* VOLUME SLIDER — magenta center in gradient */
.volume-slider::-webkit-slider-thumb {
  background: linear-gradient(135deg, var(--purple-bright), var(--magenta-bright), var(--cyan-core)) !important;
  box-shadow:
    0 0 8px rgba(255, 45, 123, 0.3),
    0 0 16px rgba(157, 78, 221, 0.2) !important;
}

/* TOAST — magenta progress bar */
.toast-progress {
  background: linear-gradient(90deg, var(--purple-bright), var(--magenta-bright), var(--cyan-core)) !important;
}

/* SETTINGS SECTION TITLES — magenta instead of cyan */
#settingsOverlay [style*="cyan-bright"] {
  color: var(--magenta-bright) !important;
}

/* BEAT DOT — alternates cyan/magenta based on beat */
.beat-dot {
  background: linear-gradient(135deg, var(--cyan-bright), var(--magenta-bright)) !important;
  box-shadow:
    0 0 calc(4px + var(--beat, 0) * 10px) rgba(0, 220, 245, calc(0.2 + var(--beat, 0) * 0.4)),
    0 0 calc(3px + var(--beat, 0) * 8px) rgba(255, 45, 123, calc(0.15 + var(--beat, 0) * 0.3)) !important;
}

/* TRANSPORT BUTTONS — magenta hover glow */
.transport-btn:hover {
  box-shadow: 0 0 12px rgba(255, 45, 123, 0.15), 0 0 8px rgba(157, 78, 221, 0.2) !important;
}

/* CONTENT HEADER UNDERLINE — animated gradient with magenta */
.content-title::after {
  width: calc(40px + var(--energy, 0) * 40px) !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  background: linear-gradient(90deg,
    transparent,
    rgba(157, 78, 221, calc(0.8 + var(--beat, 0) * 0.2)),
    rgba(255, 45, 123, calc(0.4 + var(--beat, 0) * 0.4)),
    rgba(0, 220, 245, calc(0.3 + var(--energy, 0) * 0.4)),
    transparent
  ) !important;
  box-shadow: 0 0 calc(4px + var(--beat, 0) * 10px) rgba(255, 45, 123, calc(0.2 + var(--beat, 0) * 0.4)) !important;
  transition: width 0.15s, box-shadow 0.08s, background 0.08s !important;
}

/* MAIN CONTENT — ambient beat wash with magenta */
.main-content::before {
  background: radial-gradient(ellipse at center,
    rgba(255, 45, 123, calc(var(--beat, 0) * 0.03)) 0%,
    rgba(0, 180, 216, calc(var(--beat, 0) * 0.04)) 30%,
    rgba(157, 78, 221, calc(var(--energy, 0) * 0.02)) 60%,
    transparent 80%
  ) !important;
}

/* EQ BARS — magenta on every 3rd */
.eq-bar:nth-child(3n) {
  background: var(--magenta-bright) !important;
}

/* NAV ITEM ACTIVE INDICATOR — magenta-to-cyan gradient */
.nav-item.active::before {
  background: linear-gradient(180deg, var(--magenta-bright), var(--cyan-core), var(--purple-bright)) !important;
  box-shadow: 0 0 10px rgba(255, 45, 123, 0.4), 0 0 20px rgba(0, 220, 245, 0.2), 0 0 30px rgba(157, 78, 221, 0.15) !important;
}

/* LOSSLESS BADGE — magenta border accent */
.quality-badge.lossless-badge {
  border-color: var(--magenta-dim) !important;
  color: var(--magenta-bright) !important;
  box-shadow: 0 0 6px rgba(255, 45, 123, 0.15);
}

/* VIZ SCENE NAME — magenta text shadow */
.viz-scene-name {
  text-shadow:
    0 0 8px rgba(0, 220, 245, 0.4),
    0 0 16px rgba(255, 45, 123, 0.2) !important;
}

/* CONTEXT MENU HOVER — magenta tint */
.context-menu-item:hover {
  background: linear-gradient(90deg, rgba(255, 45, 123, 0.06), rgba(123, 47, 190, 0.1)) !important;
}

/* APP SHELL WINDOW — soft outer aura that breathes */
.app-shell {
  box-shadow:
    inset 0 0 calc(30px + var(--energy, 0) * 40px) rgba(157, 78, 221, calc(0.01 + var(--energy, 0) * 0.03)),
    inset 0 0 calc(20px + var(--bass, 0) * 30px) rgba(255, 45, 123, calc(0.005 + var(--bass, 0) * 0.015));
  transition: box-shadow 0.12s;
}
/* ============================================
   SPLASH SCREEN — UFO CONTROL CONSOLE
   ============================================ */
#splashScreen {
  position: fixed;
  inset: 0;
  z-index: 99999;
  background: var(--bg-void);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  transition: opacity 0.8s ease, transform 0.8s ease;
}

#splashScreen.fade-out {
  opacity: 0;
  transform: scale(1.05);
  pointer-events: none;
}

#splashCanvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
}

.splash-content {
  position: relative;
  z-index: 2;
  text-align: center;
}

.splash-logo {
  font-family: var(--font-display);
  font-size: 8rem;
  font-weight: 900;
  color: var(--purple-vivid);
  line-height: 1;
  text-shadow: var(--glow-neon);
  animation: splashLogoPulse 2s ease-in-out infinite, splashGlitch 4s linear infinite;
  position: relative;
}

@keyframes splashLogoPulse {
  0%, 100% {
    text-shadow: 0 0 4px #B76EFF, 0 0 12px rgba(183,110,255,0.5), 0 0 30px rgba(157,78,221,0.3), 0 0 60px rgba(123,47,190,0.15);
    transform: scale(1);
  }
  50% {
    text-shadow: 0 0 8px #D4A0FF, 0 0 25px rgba(183,110,255,0.8), 0 0 50px rgba(157,78,221,0.5), 0 0 100px rgba(123,47,190,0.3);
    transform: scale(1.03);
  }
}

@keyframes splashGlitch {
  0%, 93%, 95%, 97%, 100% { transform: translate(0); filter: none; }
  93.5% { transform: translate(-3px, 1px); filter: hue-rotate(30deg); }
  94% { transform: translate(2px, -1px); filter: hue-rotate(-30deg) brightness(1.3); }
  95.5% { transform: translate(-1px, 2px); filter: hue-rotate(15deg); }
  96% { transform: translate(3px, 0px); filter: saturate(2) brightness(1.5); }
  97.5% { transform: translate(0, -2px); filter: hue-rotate(-15deg); }
}

.splash-logo::before,
.splash-logo::after {
  content: 'A';
  position: absolute;
  inset: 0;
  z-index: -1;
}

.splash-logo::before {
  color: rgba(0,180,216,0.4);
  animation: glitchShift1 4s linear infinite;
  clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
}

.splash-logo::after {
  color: rgba(255,45,123,0.4);
  animation: glitchShift2 4s linear infinite;
  clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
}

@keyframes glitchShift1 {
  0%, 92%, 96%, 100% { transform: translate(0); }
  93% { transform: translate(5px, -2px); }
  94% { transform: translate(-3px, 1px); }
  95% { transform: translate(2px, 2px); }
}

@keyframes glitchShift2 {
  0%, 93%, 97%, 100% { transform: translate(0); }
  94% { transform: translate(-4px, 2px); }
  95% { transform: translate(3px, -1px); }
  96% { transform: translate(-2px, -2px); }
}

.splash-title {
  font-family: var(--font-display);
  font-size: 1.2rem;
  font-weight: 700;
  letter-spacing: 0.5em;
  color: var(--purple-white);
  margin-top: 1rem;
  opacity: 0;
  animation: splashFadeIn 0.8s 0.5s forwards;
}

.splash-tagline {
  font-family: var(--font-body);
  font-size: 0.85rem;
  font-weight: 400;
  color: var(--purple-muted);
  letter-spacing: 0.1em;
  margin-top: 0.5rem;
  opacity: 0;
  animation: splashFadeIn 0.8s 0.8s forwards;
}

@keyframes splashFadeIn {
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
}

.splash-loader {
  margin-top: 3rem;
  width: 200px;
  opacity: 0;
  animation: splashFadeIn 0.6s 1s forwards;
}

.splash-bar-track {
  width: 100%;
  height: 2px;
  background: var(--purple-dim);
  border-radius: 1px;
  overflow: hidden;
}

.splash-bar-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, var(--purple-core), var(--purple-vivid));
  border-radius: 1px;
  box-shadow: 0 0 10px rgba(183,110,255,0.5), 0 0 4px rgba(183,110,255,0.8);
  transition: width 0.4s var(--ease-smooth);
}

.splash-status {
  font-family: var(--font-mono);
  font-size: 0.6rem;
  letter-spacing: 0.15em;
  color: var(--purple-muted);
  margin-top: 0.75rem;
  text-transform: uppercase;
  min-height: 1.2em;
}

.splash-scanlines {
  position: absolute;
  inset: 0;
  z-index: 1;
  pointer-events: none;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0,0,0,0.08) 2px,
    rgba(0,0,0,0.08) 4px
  );
  animation: scanlineScroll 8s linear infinite;
}

@keyframes scanlineScroll {
  from { transform: translateY(0); }
  to { transform: translateY(4px); }
}

.splash-vignette {
  position: absolute;
  inset: 0;
  z-index: 1;
  pointer-events: none;
  background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.7) 100%);
}

/* ============ BINAURAL BEATS VIEW ============ */
.binaural-view { padding: 24px; max-width: 720px; margin: 0 auto; }
.binaural-header { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
.binaural-header h2 { font-family: var(--font-display); font-size: 1.3rem; color: var(--purple-vivid); letter-spacing: 2px; }
.binaural-headphone-note { font-family: var(--font-mono); font-size: 0.7rem; color: var(--cyan-bright); margin-bottom: 24px; opacity: 0.8; }

.binaural-presets { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 28px; }
.binaural-preset-btn {
  background: var(--bg-raised);
  border: 1px solid var(--purple-dim);
  border-radius: 8px;
  padding: 12px 18px;
  cursor: pointer;
  transition: all 0.2s var(--ease-smooth);
  text-align: center;
  min-width: 110px;
}
.binaural-preset-btn:hover { border-color: var(--purple-bright); box-shadow: var(--glow-subtle); }
.binaural-preset-btn.active { border-color: var(--purple-vivid); background: rgba(123,47,190,0.15); box-shadow: var(--glow-medium); }
.binaural-preset-name { font-family: var(--font-display); font-size: 0.85rem; color: var(--purple-white); letter-spacing: 1px; margin-bottom: 4px; }
.binaural-preset-info { font-family: var(--font-mono); font-size: 0.6rem; color: var(--purple-muted); }

.binaural-controls { display: flex; flex-direction: column; gap: 18px; margin-bottom: 28px; }
.binaural-slider-group { display: flex; flex-direction: column; gap: 6px; }
.binaural-slider-label {
  display: flex; justify-content: space-between; align-items: center;
  font-family: var(--font-mono); font-size: 0.75rem; color: var(--purple-hot);
}
.binaural-slider-value { color: var(--cyan-bright); font-weight: 500; }
.binaural-slider {
  -webkit-appearance: none; appearance: none; width: 100%; height: 4px;
  background: var(--bg-input); border-radius: 2px; outline: none;
}
.binaural-slider::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
  background: var(--purple-vivid); border-radius: 50%; cursor: pointer;
  box-shadow: 0 0 8px rgba(183,110,255,0.5);
  transition: box-shadow 0.2s;
}
.binaural-slider::-webkit-slider-thumb:hover { box-shadow: 0 0 14px rgba(183,110,255,0.8); }

.binaural-freq-display {
  display: flex; justify-content: space-around; align-items: center;
  background: var(--bg-raised); border: 1px solid var(--purple-dim); border-radius: 8px;
  padding: 16px; margin-bottom: 20px; text-align: center;
}
.binaural-freq-item { display: flex; flex-direction: column; gap: 4px; }
.binaural-freq-label { font-family: var(--font-mono); font-size: 0.6rem; color: var(--purple-muted); text-transform: uppercase; letter-spacing: 1px; }
.binaural-freq-val { font-family: var(--font-display); font-size: 1.1rem; color: var(--cyan-bright); text-shadow: 0 0 8px rgba(0,220,245,0.4); }

.binaural-actions { display: flex; align-items: center; gap: 16px; margin-bottom: 20px; }
.binaural-play-btn {
  display: flex; align-items: center; gap: 8px;
  background: linear-gradient(135deg, var(--purple-core), var(--purple-bright));
  border: none; border-radius: 8px; padding: 12px 28px;
  font-family: var(--font-display); font-size: 0.85rem; color: #fff;
  cursor: pointer; letter-spacing: 2px; transition: all 0.25s var(--ease-smooth);
  box-shadow: var(--glow-medium);
}
.binaural-play-btn:hover { transform: scale(1.03); box-shadow: var(--glow-intense); }
.binaural-play-btn.active { background: linear-gradient(135deg, var(--magenta-core), var(--magenta-bright)); }
.binaural-play-btn svg { width: 18px; height: 18px; fill: currentColor; stroke: currentColor; }

.binaural-mix-toggle {
  display: flex; align-items: center; gap: 8px;
  font-family: var(--font-mono); font-size: 0.75rem; color: var(--purple-hot); cursor: pointer;
}
.binaural-mix-toggle input[type="checkbox"] { accent-color: var(--purple-vivid); width: 16px; height: 16px; cursor: pointer; }

.binaural-status {
  font-family: var(--font-mono); font-size: 0.7rem; color: var(--purple-muted);
  padding: 10px 0; border-top: 1px solid var(--purple-dim); margin-top: 8px;
}
.binaural-status.active { color: var(--cyan-bright); }

/* ============ RHYTHM LAYERS ============ */
.rhythm-section { margin-top: 32px; border-top: 1px solid var(--purple-dim); padding-top: 24px; }
.rhythm-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; }
.rhythm-header h3 { font-family: var(--font-display); font-size: 1rem; color: var(--magenta-bright); letter-spacing: 2px; }
.rhythm-subtitle { font-family: var(--font-mono); font-size: 0.65rem; color: var(--purple-muted); margin-bottom: 20px; }

.rhythm-presets { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 20px; }
.rhythm-preset-btn {
  background: var(--bg-raised); border: 1px solid var(--magenta-dim); border-radius: 6px;
  padding: 8px 14px; cursor: pointer; transition: all 0.2s var(--ease-smooth);
}
.rhythm-preset-btn:hover { border-color: var(--magenta-bright); box-shadow: var(--magenta-glow); }
.rhythm-preset-btn.active { border-color: var(--magenta-vivid); background: rgba(212,20,122,0.1); box-shadow: var(--magenta-glow); }
.rhythm-preset-name { font-family: var(--font-display); font-size: 0.75rem; color: var(--magenta-vivid); letter-spacing: 1px; }
.rhythm-preset-desc { font-family: var(--font-mono); font-size: 0.55rem; color: var(--purple-muted); margin-top: 2px; }

.rhythm-bpm-row { display: flex; align-items: center; gap: 14px; margin-bottom: 18px; }
.rhythm-bpm-label { font-family: var(--font-display); font-size: 0.8rem; color: var(--magenta-bright); letter-spacing: 1px; min-width: 40px; }
.rhythm-bpm-val { font-family: var(--font-display); font-size: 1.1rem; color: var(--cyan-bright); text-shadow: 0 0 8px rgba(0,220,245,0.4); min-width: 60px; text-align: right; }
.rhythm-bpm-slider { flex: 1; }

.rhythm-layers-container { display: flex; flex-direction: column; gap: 10px; margin-bottom: 16px; }
.rhythm-layer-card {
  background: var(--bg-raised); border: 1px solid var(--purple-dim); border-radius: 8px;
  padding: 12px 14px; display: flex; align-items: center; gap: 12px;
  transition: all 0.2s var(--ease-smooth); position: relative;
}
.rhythm-layer-card.pulsing { border-color: var(--cyan-bright); box-shadow: 0 0 12px rgba(0,220,245,0.2); }
.rhythm-layer-num {
  font-family: var(--font-display); font-size: 0.7rem; color: var(--purple-muted);
  width: 20px; text-align: center; flex-shrink: 0;
}
.rhythm-layer-select {
  background: var(--bg-input); border: 1px solid var(--purple-dim); border-radius: 4px;
  color: var(--purple-white); font-family: var(--font-mono); font-size: 0.75rem;
  padding: 5px 8px; cursor: pointer; outline: none;
}
.rhythm-layer-select:focus { border-color: var(--purple-bright); }
.rhythm-layer-vol { width: 70px; }
.rhythm-layer-vol-label { font-family: var(--font-mono); font-size: 0.6rem; color: var(--purple-muted); min-width: 30px; text-align: right; }
.rhythm-layer-remove {
  background: none; border: 1px solid var(--magenta-dim); border-radius: 4px;
  color: var(--magenta-muted); cursor: pointer; padding: 3px 6px; font-size: 0.7rem;
  font-family: var(--font-mono); transition: all 0.2s; flex-shrink: 0;
}
.rhythm-layer-remove:hover { border-color: var(--magenta-bright); color: var(--magenta-bright); }
.rhythm-layer-badge {
  font-family: var(--font-display); font-size: 0.55rem; letter-spacing: 1px;
  padding: 2px 6px; border-radius: 3px; flex-shrink: 0;
}

.rhythm-add-btn {
  background: none; border: 1px dashed var(--purple-dim); border-radius: 8px;
  color: var(--purple-muted); font-family: var(--font-mono); font-size: 0.75rem;
  padding: 10px; cursor: pointer; transition: all 0.2s; width: 100%; text-align: center;
}
.rhythm-add-btn:hover { border-color: var(--purple-bright); color: var(--purple-bright); }

.rhythm-actions { display: flex; align-items: center; gap: 14px; margin-top: 16px; }
.rhythm-play-btn {
  display: flex; align-items: center; gap: 8px;
  background: linear-gradient(135deg, var(--magenta-core), var(--magenta-bright));
  border: none; border-radius: 8px; padding: 10px 24px;
  font-family: var(--font-display); font-size: 0.8rem; color: #fff;
  cursor: pointer; letter-spacing: 2px; transition: all 0.25s var(--ease-smooth);
  box-shadow: var(--magenta-glow);
}
.rhythm-play-btn:hover { transform: scale(1.03); box-shadow: 0 0 16px rgba(255,45,123,0.4); }
.rhythm-play-btn.active { background: linear-gradient(135deg, var(--cyan-muted), var(--cyan-core)); box-shadow: var(--cyan-glow); }
.rhythm-play-btn svg { width: 16px; height: 16px; fill: currentColor; stroke: currentColor; }

.rhythm-beat-viz {
  display: flex; align-items: center; gap: 6px; padding: 8px 0;
}
.rhythm-beat-dot {
  width: 10px; height: 10px; border-radius: 50%;
  background: var(--purple-dim); transition: all 0.08s;
}
.rhythm-beat-dot.on { background: var(--magenta-bright); box-shadow: 0 0 10px rgba(255,45,123,0.6); transform: scale(1.3); }
.rhythm-beat-dot.accent { background: var(--cyan-bright); box-shadow: 0 0 10px rgba(0,220,245,0.6); transform: scale(1.5); }

.rhythm-layer-indicator {
  width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0;
  background: var(--purple-dim); transition: all 0.1s;
}
.rhythm-layer-indicator.on { background: var(--cyan-bright); box-shadow: 0 0 8px rgba(0,220,245,0.5); }

/* ============ EQUALIZER PANEL ============ */
.eq-toggle-btn {
  background: none; border: 1px solid var(--purple-dim); border-radius: 4px;
  padding: 3px 8px; cursor: pointer; transition: all 0.2s var(--ease-smooth);
  display: flex; align-items: center; gap: 4px;
}
.eq-toggle-btn:hover { border-color: var(--purple-bright); box-shadow: var(--glow-subtle); }
.eq-toggle-btn.active { border-color: var(--cyan-bright); box-shadow: var(--cyan-glow); }
.eq-toggle-btn svg { width: 14px; height: 14px; stroke: var(--purple-muted); fill: none; stroke-width: 1.5; transition: stroke 0.2s; }
.eq-toggle-btn:hover svg { stroke: var(--purple-bright); }
.eq-toggle-btn.active svg { stroke: var(--cyan-bright); }
.eq-toggle-btn span { font-family: var(--font-mono); font-size: 0.55rem; color: var(--purple-muted); letter-spacing: 0.05em; transition: color 0.2s; }
.eq-toggle-btn:hover span { color: var(--purple-bright); }
.eq-toggle-btn.active span { color: var(--cyan-bright); }

.eq-panel {
  position: fixed; bottom: var(--nowplaying-h); right: 12px;
  width: 500px; max-width: calc(100vw - 24px);
  background: rgba(9,9,15,0.95); border: 1px solid var(--purple-dim);
  border-radius: 16px 16px 0 0; border-bottom: none;
  box-shadow: 0 -4px 40px rgba(0,0,0,0.7), var(--glow-subtle);
  backdrop-filter: blur(20px) saturate(1.2);
  z-index: 500;
  transform: translateY(calc(100% + 12px));
  opacity: 0; pointer-events: none;
  transition: transform 0.35s var(--ease-smooth), opacity 0.3s var(--ease-smooth);
}
.eq-panel.open { transform: translateY(0); opacity: 1; pointer-events: auto; }

.eq-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 14px 20px 10px; border-bottom: 1px solid var(--purple-dim);
}
.eq-title { font-family: var(--font-display); font-weight: 700; font-size: 0.75rem; color: var(--purple-white); letter-spacing: 0.12em; }
.eq-close { background: none; border: none; cursor: pointer; padding: 4px; }
.eq-close svg { width: 14px; height: 14px; stroke: var(--purple-muted); fill: none; stroke-width: 1.5; transition: stroke 0.2s; }
.eq-close:hover svg { stroke: var(--purple-white); }

.eq-presets {
  display: flex; gap: 6px; padding: 10px 20px; overflow-x: auto;
  border-bottom: 1px solid rgba(54,32,80,0.3);
}
.eq-presets::-webkit-scrollbar { height: 2px; }
.eq-preset-btn {
  background: var(--bg-raised); border: 1px solid var(--purple-dim); border-radius: 6px;
  padding: 4px 10px; cursor: pointer; font-family: var(--font-mono); font-size: 0.55rem;
  color: var(--purple-hot); white-space: nowrap; transition: all 0.2s var(--ease-smooth); letter-spacing: 0.03em;
}
.eq-preset-btn:hover { border-color: var(--purple-bright); box-shadow: var(--glow-subtle); color: var(--purple-white); }
.eq-preset-btn.active { border-color: var(--cyan-bright); box-shadow: var(--cyan-glow); color: var(--cyan-bright); background: rgba(0,220,245,0.05); }

.eq-bands {
  display: flex; align-items: stretch; justify-content: space-around;
  padding: 14px 16px 6px; position: relative;
}
.eq-bands::before {
  content: ''; position: absolute; left: 16px; right: 16px; top: 50%;
  height: 1px; background: var(--purple-dim); pointer-events: none; opacity: 0.5;
}
.eq-band {
  display: flex; flex-direction: column; align-items: center; gap: 4px; flex: 1;
  position: relative; z-index: 1;
}
.eq-band-db {
  font-family: var(--font-mono); font-size: 0.5rem; color: var(--cyan-bright);
  text-shadow: 0 0 6px rgba(0,220,245,0.3); min-width: 28px; text-align: center;
  height: 14px; line-height: 14px; transition: color 0.15s;
}
.eq-band-db.positive { color: var(--cyan-bright); }
.eq-band-db.negative { color: var(--magenta-bright); }
.eq-band-db.zero { color: var(--purple-muted); }

.eq-slider-wrap {
  width: 28px; height: 130px; position: relative;
  display: flex; align-items: center; justify-content: center;
}
.eq-slider-wrap input[type="range"] {
  -webkit-appearance: none; appearance: none;
  width: 130px; height: 4px;
  background: linear-gradient(90deg, var(--purple-dim) 0%, var(--bg-input) 50%, var(--purple-dim) 100%);
  border-radius: 2px; outline: none; margin: 0;
  transform: rotate(-90deg);
  transform-origin: center center;
}
.eq-slider-wrap input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; width: 14px; height: 14px;
  background: var(--purple-vivid); border-radius: 50%; cursor: pointer;
  box-shadow: 0 0 8px rgba(183,110,255,0.5);
  transition: box-shadow 0.15s, transform 0.15s, background 0.15s;
}
.eq-slider-wrap input[type="range"]::-webkit-slider-thumb:hover {
  box-shadow: 0 0 16px rgba(183,110,255,0.8); transform: scale(1.25);
}
.eq-slider-wrap input[type="range"]:active::-webkit-slider-thumb {
  background: var(--cyan-bright); box-shadow: 0 0 20px rgba(0,220,245,0.7);
}

.eq-band-freq {
  font-family: var(--font-mono); font-size: 0.45rem; color: var(--purple-muted);
  letter-spacing: 0.02em; text-align: center; white-space: nowrap;
}
.eq-band-line {
  position: absolute; width: 2px; border-radius: 1px;
  left: 50%; transform: translateX(-50%);
  transition: height 0.15s var(--ease-smooth), background 0.15s;
  pointer-events: none; opacity: 0.4;
}

.eq-footer {
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 20px 12px; border-top: 1px solid rgba(54,32,80,0.3);
}
.eq-reset-btn {
  background: none; border: 1px solid var(--purple-dim); border-radius: 4px;
  padding: 4px 12px; cursor: pointer; font-family: var(--font-mono); font-size: 0.55rem;
  color: var(--purple-muted); transition: all 0.2s; letter-spacing: 0.05em;
}
.eq-reset-btn:hover { border-color: var(--magenta-bright); color: var(--magenta-bright); box-shadow: var(--magenta-glow); }
.eq-status { font-family: var(--font-mono); font-size: 0.5rem; color: var(--purple-muted); letter-spacing: 0.05em; }

@media (max-width:600px) {
  .eq-panel { width: 100%; right: 0; max-width: 100vw; border-radius: 12px 12px 0 0; }
  .eq-slider-wrap { height: 100px; }
  .eq-slider-wrap input[type="range"] { width: 100px; }
  .eq-bands { padding: 10px 8px 4px; }
  .eq-band-freq { font-size: 0.4rem; }
}
</style>
</head>
<body>

<!-- ============ SPLASH SCREEN ============ -->
<div id="splashScreen">
  <canvas id="splashCanvas"></canvas>
  <div class="splash-scanlines"></div>
  <div class="splash-vignette"></div>
  <div class="splash-content">
    <div class="splash-logo">P</div>
    <div class="splash-title">AETHER</div>
    <div class="splash-tagline">Not a music player — an experience.</div>
    <div class="splash-loader">
      <div class="splash-bar-track">
        <div class="splash-bar-fill" id="splashBarFill"></div>
      </div>
      <div class="splash-status" id="splashStatus">INITIALIZING</div>
    </div>
  </div>
</div>

<!-- AMBIENT FLOATING PARTICLES -->
<canvas id="ambientParticles"></canvas>

<!-- DRAG HANDLE (bottom-right corner) -->
<div id="dragHandle" style="position:fixed;bottom:0;right:0;width:48px;height:48px;-webkit-app-region:drag;z-index:9998;cursor:grab;display:flex;align-items:flex-end;justify-content:flex-end;padding:6px;">
  <svg width="14" height="14" viewBox="0 0 14 14" style="opacity:0.25;pointer-events:none;">
    <line x1="12" y1="2" x2="2" y2="12" stroke="#9d4edd" stroke-width="1"/>
    <line x1="12" y1="6" x2="6" y2="12" stroke="#9d4edd" stroke-width="1"/>
    <line x1="12" y1="10" x2="10" y2="12" stroke="#9d4edd" stroke-width="1"/>
  </svg>
</div>

<!-- TITLEBAR -->
<div class="titlebar" id="titlebar">
  <div class="titlebar-left">
    <span class="titlebar-logo"><span class="logo-p">A</span>ETHER</span>
    <span class="beat-dot" id="beatDot"></span>
  </div>
  <div class="titlebar-controls">
    <button class="tb-btn" id="tbMin" title="Minimize"><svg viewBox="0 0 10 10"><line x1="0" y1="5" x2="10" y2="5"/></svg></button>
    <button class="tb-btn" id="tbMax" title="Maximize"><svg viewBox="0 0 10 10" id="tbMaxIcon"><rect x="0.5" y="0.5" width="9" height="9" rx="1" fill="none"/></svg></button>
    <button class="tb-btn close" id="tbClose" title="Close"><svg viewBox="0 0 10 10"><line x1="0" y1="0" x2="10" y2="10"/><line x1="10" y1="0" x2="0" y2="10"/></svg></button>
  </div>
</div>

<!-- APP SHELL -->
<div class="app-shell" id="appShell">
  <!-- SIDEBAR -->
  <div class="sidebar" id="sidebar">
    <button class="sidebar-toggle" id="sidebarToggle" title="Expand sidebar">
      <svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"/></svg>
    </button>
    <div class="sidebar-nav">
      <div class="nav-item active" data-view="library">
        <svg viewBox="0 0 24 24"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg>
        <span class="nav-item-label">Library</span>
      </div>
      <div class="nav-item" data-view="albums">
        <svg viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/></svg>
        <span class="nav-item-label">Albums</span>
      </div>
      <div class="nav-item" data-view="artists">
        <svg viewBox="0 0 24 24"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
        <span class="nav-item-label">Artists</span>
      </div>
      <div class="nav-item" data-view="genres">
        <svg viewBox="0 0 24 24"><path d="M4 7h16M4 12h10M4 17h6" stroke-linecap="round"/></svg>
        <span class="nav-item-label">Genres</span>
      </div>
      <div class="nav-item" data-view="binaural">
        <svg viewBox="0 0 24 24"><path d="M2 12c0-3 2-7 5-7s3 4 5 4 2-4 5-4 5 4 5 7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M2 16c0-2 1.5-5 3.5-5s2 3 3.5 3 1.5-3 3.5-3 2 3 3.5 3 1.5-3 3.5-3 3.5 3 3.5 5" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" opacity="0.6"/></svg>
        <span class="nav-item-label">Binaural</span>
      </div>
      <div class="nav-item" data-action="search">
        <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
        <span class="nav-item-label">Search</span>
      </div>
      <div class="nav-item" data-action="queue">
        <svg viewBox="0 0 24 24"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
        <span class="nav-item-label">Queue</span>
      </div>
      <div class="sidebar-divider"></div>
      <div class="sidebar-section-label">PLAYLISTS</div>
      <div id="sidebarPlaylists"></div>
      <button class="create-playlist-btn" id="createPlaylistBtn">
        <svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
        <span class="create-playlist-label">Create Playlist</span>
      </button>
      <div class="sidebar-divider"></div>
      <div class="nav-item" data-action="settings" style="margin-top:auto;">
        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
        <span class="nav-item-label">Settings</span>
      </div>
    </div>
  </div>

  <!-- MAIN CONTENT -->
  <div class="main-content" id="mainContent">
    <div class="content-header">
      <button id="btnBack" onclick="navigateBack()" style="display:none;position:absolute;left:28px;top:50%;transform:translateY(-50%);background:none;border:1px solid var(--purple-dim);border-radius:6px;padding:6px 8px;cursor:pointer;transition:all 0.2s;z-index:2;" title="Back">
        <svg width="16" height="16" viewBox="0 0 24 24" stroke="var(--purple-muted)" fill="none" stroke-width="1.5"><polyline points="15 18 9 12 15 6"/></svg>
      </button>
      <h1 class="content-title" id="contentTitle">Library</h1>
      <div class="content-header-right">
        <div class="view-toggles" id="viewToggles">
          <button class="view-btn active" data-mode="list" title="List view">
            <svg viewBox="0 0 24 24"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
          </button>
          <button class="view-btn" data-mode="grid" title="Grid view">
            <svg viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/></svg>
          </button>
        </div>
        <div class="search-bar">
          <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
          <input type="text" placeholder="Filter tracks..." id="filterInput">
        </div>
      </div>
    </div>

    <!-- VISUALIZER -->
    <div class="visualizer-panel" id="vizPanel">
      <video id="sheepVideo" style="position:absolute;inset:0;width:100%;height:100%;object-fit:cover;display:none;z-index:0;" muted loop playsinline></video>
      <canvas id="vizCanvas" style="position:relative;z-index:1;"></canvas>
      <div class="viz-label">VISUALIZER</div>
      <div class="viz-scene-name" id="vizSceneName">FRACTAL FLAME</div>
      <button class="viz-expand" title="Fullscreen"><svg viewBox="0 0 24 24"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></svg></button>
    </div>

    <!-- DYNAMIC CONTENT AREA -->
    <div id="dynamicContent"></div>
  </div>

  <!-- NOW PLAYING -->
  <div class="now-playing">
    <div class="np-left">
      <div class="np-art" id="npArt"></div>
      <div class="np-info">
        <div class="np-title" id="npTitle">No track selected</div>
        <div class="np-artist" id="npArtist">--</div>
        <div class="np-album" id="npAlbum">--</div>
      </div>
    </div>
    <div class="np-center">
      <div class="transport">
        <button class="transport-btn shuffle" id="btnShuffle" title="Shuffle"><svg viewBox="0 0 24 24"><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="9" y2="9"/></svg></button>
        <button class="transport-btn" id="btnPrev" title="Previous"><svg viewBox="0 0 24 24"><polygon points="19 20 9 12 19 4 19 20"/><line x1="5" y1="19" x2="5" y2="5"/></svg></button>
        <button class="play-btn" id="btnPlay" title="Play">
          <svg class="play-icon" viewBox="0 0 24 24"><polygon points="6 3 20 12 6 21 6 3"/></svg>
          <svg class="pause-icon" viewBox="0 0 24 24"><rect x="5" y="3" width="5" height="18" rx="1" fill="var(--purple-white)"/><rect x="14" y="3" width="5" height="18" rx="1" fill="var(--purple-white)"/></svg>
        </button>
        <button class="transport-btn" id="btnNext" title="Next"><svg viewBox="0 0 24 24"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" y1="5" x2="19" y2="19"/></svg></button>
        <button class="transport-btn repeat" id="btnRepeat" title="Repeat"><svg viewBox="0 0 24 24"><polyline points="17 1 21 5 17 9"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><polyline points="7 23 3 19 7 15"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg></button>
      </div>
      <div class="seek-container">
        <span class="seek-time" id="seekCurrent">0:00</span>
        <div class="waveform-container" id="waveform"></div>
        <span class="seek-time" id="seekTotal">0:00</span>
      </div>
    </div>
    <div class="np-right">
      <div class="volume-group">
        <button class="volume-btn" id="btnMute"><svg viewBox="0 0 24 24"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg></button>
        <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="75">
      </div>
      <button class="eq-toggle-btn" id="eqToggleBtn" title="Equalizer">
        <svg viewBox="0 0 24 24"><line x1="4" y1="21" x2="4" y2="14"/><line x1="4" y1="10" x2="4" y2="3"/><line x1="12" y1="21" x2="12" y2="12"/><line x1="12" y1="8" x2="12" y2="3"/><line x1="20" y1="21" x2="20" y2="16"/><line x1="20" y1="12" x2="20" y2="3"/><line x1="1" y1="14" x2="7" y2="14"/><line x1="9" y1="8" x2="15" y2="8"/><line x1="17" y1="16" x2="23" y2="16"/></svg>
        <span>EQ</span>
      </button>
      <div class="quality-badge" id="qualityBadge">--</div>
    </div>
  </div>
</div>

<!-- EQUALIZER PANEL -->
<div class="eq-panel" id="eqPanel">
  <div class="eq-header">
    <div class="eq-title">EQUALIZER</div>
    <button class="eq-close" id="eqClose"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
  </div>
  <div class="eq-presets" id="eqPresets"></div>
  <div class="eq-bands" id="eqBands"></div>
  <div class="eq-footer">
    <button class="eq-reset-btn" onclick="resetEq()">RESET</button>
    <span class="eq-status" id="eqStatus">10-BAND PARAMETRIC</span>
  </div>
</div>

<!-- SEARCH OVERLAY -->
<div class="search-overlay" id="searchOverlay">
  <div class="search-modal">
    <input type="text" class="search-modal-input" id="searchInput" placeholder="Search your library...">
    <div class="search-results" id="searchResults"></div>
    <div class="search-hint">ESC to close &bull; CTRL+K to toggle</div>
  </div>
</div>

<!-- QUEUE PANEL -->
<div class="queue-panel" id="queuePanel">
  <div class="queue-header">
    <div class="queue-title">QUEUE</div>
    <button class="queue-close" id="queueClose"><svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
  </div>
  <div class="queue-now">
    <div class="queue-now-label">NOW PLAYING</div>
    <div class="queue-now-track">
      <div class="queue-now-art" id="queueNowArt"></div>
      <div class="queue-now-info">
        <div class="queue-track-title" id="queueNowTitle">--</div>
        <div class="queue-track-artist" id="queueNowArtist">--</div>
      </div>
    </div>
  </div>
  <div class="queue-list">
    <div class="queue-list-label">UP NEXT</div>
    <div id="queueItems"></div>
  </div>
</div>

<!-- SETTINGS OVERLAY -->
<div class="search-overlay" id="settingsOverlay">
  <div class="search-modal" style="max-width:500px;background:var(--bg-surface);border:1px solid var(--purple-dim);border-radius:16px;padding:0;overflow:hidden;max-height:80vh;overflow-y:auto;">
    <div style="padding:20px 24px;border-bottom:1px solid var(--purple-dim);display:flex;align-items:center;justify-content:space-between;">
      <span style="font-family:var(--font-display);font-weight:700;font-size:0.9rem;color:var(--purple-white);letter-spacing:0.08em;">SETTINGS</span>
      <button onclick="document.getElementById('settingsOverlay').classList.remove('open')" style="background:none;border:none;cursor:pointer;padding:4px;"><svg width="16" height="16" viewBox="0 0 24 24" stroke="var(--purple-muted)" fill="none" stroke-width="1.5"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
    </div>
    <div style="padding:20px 24px;">
      <div style="font-family:var(--font-display);font-size:0.7rem;color:var(--cyan-bright);letter-spacing:0.12em;margin-bottom:12px;">VISUALIZER</div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:16px;" id="sceneButtons"></div>
      <label style="display:flex;align-items:center;gap:10px;margin-bottom:10px;cursor:pointer;">
        <input type="checkbox" id="settAutoRotate" style="accent-color:var(--purple-bright);">
        <span style="font-family:var(--font-body);font-size:0.9rem;color:var(--purple-hot);">Auto-rotate scenes</span>
      </label>
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:16px;">
        <span style="font-family:var(--font-mono);font-size:0.7rem;color:var(--purple-muted);">Interval:</span>
        <select id="settRotateInterval" style="background:var(--bg-input);border:1px solid var(--purple-dim);border-radius:6px;color:var(--purple-hot);font-family:var(--font-mono);font-size:0.75rem;padding:4px 8px;outline:none;">
          <option value="30000">30s</option>
          <option value="60000" selected>60s</option>
          <option value="120000">120s</option>
          <option value="300000">5m</option>
        </select>
      </div>

      <div style="font-family:var(--font-display);font-size:0.7rem;color:var(--cyan-bright);letter-spacing:0.12em;margin:20px 0 12px;">ELECTRIC SHEEP</div>
      <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:16px;">
        <div style="display:flex;gap:8px;align-items:center;">
          <input type="text" id="settSheepFolder" placeholder="Video folder path (e.g. C:\Sheep)" style="flex:1;background:var(--bg-input);border:1px solid var(--purple-dim);border-radius:6px;color:var(--purple-white);font-family:var(--font-mono);font-size:0.75rem;padding:8px 12px;outline:none;transition:border-color 0.2s;">
          <button id="settSheepBrowse" style="background:var(--bg-raised);border:1px solid var(--purple-dim);border-radius:6px;color:var(--purple-hot);font-family:var(--font-display);font-size:0.6rem;letter-spacing:0.08em;padding:8px 12px;cursor:pointer;transition:all 0.2s;white-space:nowrap;">BROWSE</button>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <button id="settSheepScan" style="background:var(--bg-raised);border:1px solid var(--purple-dim);border-radius:6px;color:var(--purple-hot);font-family:var(--font-display);font-size:0.6rem;letter-spacing:0.08em;padding:8px 14px;cursor:pointer;transition:all 0.2s;">SCAN FOLDER</button>
          <button id="settSheepAddFiles" style="background:var(--bg-raised);border:1px solid var(--purple-dim);border-radius:6px;color:var(--purple-hot);font-family:var(--font-display);font-size:0.6rem;letter-spacing:0.08em;padding:8px 14px;cursor:pointer;transition:all 0.2s;">ADD FILES</button>
          <button id="settSheepClear" style="background:var(--bg-raised);border:1px solid var(--purple-dim);border-radius:6px;color:var(--purple-muted);font-family:var(--font-display);font-size:0.6rem;letter-spacing:0.08em;padding:8px 14px;cursor:pointer;transition:all 0.2s;">CLEAR</button>
        </div>
        <div id="settSheepStatus" style="font-family:var(--font-mono);font-size:0.7rem;color:var(--purple-muted);padding:4px 0;">No videos loaded</div>
      </div>

      <div style="font-family:var(--font-display);font-size:0.7rem;color:var(--cyan-bright);letter-spacing:0.12em;margin:20px 0 12px;">LAYOUT</div>
      <div style="display:flex;gap:8px;margin-bottom:16px;">
        <button id="settLayoutH" onclick="setOrientation('horizontal')" style="flex:1;background:var(--bg-raised);border:1px solid var(--cyan-bright);border-radius:6px;color:var(--purple-hot);font-family:var(--font-mono);font-size:0.7rem;padding:8px 12px;cursor:pointer;transition:all 0.2s;">HORIZONTAL</button>
        <button id="settLayoutV" onclick="setOrientation('vertical')" style="flex:1;background:var(--bg-raised);border:1px solid var(--purple-dim);border-radius:6px;color:var(--purple-hot);font-family:var(--font-mono);font-size:0.7rem;padding:8px 12px;cursor:pointer;transition:all 0.2s;">VERTICAL</button>
      </div>

      <div style="font-family:var(--font-display);font-size:0.7rem;color:var(--cyan-bright);letter-spacing:0.12em;margin:20px 0 12px;">CONNECTION</div>
      <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:12px;">
        <input type="text" id="settUrl" value="http://localhost:4533" placeholder="Navidrome URL" style="background:var(--bg-input);border:1px solid var(--purple-dim);border-radius:6px;color:var(--purple-white);font-family:var(--font-mono);font-size:0.8rem;padding:8px 12px;outline:none;">
        <div style="display:flex;gap:8px;">
          <input type="text" id="settUser" value="phantom" placeholder="Username" style="flex:1;background:var(--bg-input);border:1px solid var(--purple-dim);border-radius:6px;color:var(--purple-white);font-family:var(--font-mono);font-size:0.8rem;padding:8px 12px;outline:none;">
          <input type="password" id="settPass" value="phantom" placeholder="Password" style="flex:1;background:var(--bg-input);border:1px solid var(--purple-dim);border-radius:6px;color:var(--purple-white);font-family:var(--font-mono);font-size:0.8rem;padding:8px 12px;outline:none;">
        </div>
        <button id="settTestConn" style="align-self:flex-start;background:var(--bg-raised);border:1px solid var(--purple-dim);border-radius:6px;color:var(--purple-hot);font-family:var(--font-display);font-size:0.65rem;letter-spacing:0.1em;padding:8px 16px;cursor:pointer;transition:all 0.2s;">TEST CONNECTION</button>
      </div>

      <div style="font-family:var(--font-display);font-size:0.7rem;color:var(--cyan-bright);letter-spacing:0.12em;margin:20px 0 12px;">ABOUT</div>
      <div style="font-family:var(--font-mono);font-size:0.7rem;color:var(--purple-muted);line-height:1.8;" id="settAbout">
        AETHER v1.0.0<br>
        Navidrome: checking...<br>
      </div>
    </div>
  </div>
</div>

<!-- CREATE PLAYLIST MODAL -->
<div class="search-overlay" id="createPlaylistModal">
  <div class="search-modal" style="max-width:380px;background:var(--bg-surface);border:1px solid var(--purple-dim);border-radius:16px;padding:24px;">
    <div style="font-family:var(--font-display);font-weight:600;font-size:0.85rem;color:var(--purple-white);letter-spacing:0.06em;margin-bottom:16px;">CREATE PLAYLIST</div>
    <input type="text" id="newPlaylistName" placeholder="Playlist name..." style="width:100%;background:var(--bg-input);border:1px solid var(--purple-dim);border-radius:8px;color:var(--purple-white);font-family:var(--font-body);font-size:1rem;padding:12px 16px;outline:none;margin-bottom:16px;transition:border-color 0.2s;">
    <div style="display:flex;gap:10px;justify-content:flex-end;">
      <button onclick="document.getElementById('createPlaylistModal').classList.remove('open')" style="background:none;border:1px solid var(--purple-dim);border-radius:6px;color:var(--purple-muted);font-family:var(--font-display);font-size:0.7rem;letter-spacing:0.08em;padding:8px 16px;cursor:pointer;">CANCEL</button>
      <button id="confirmCreatePlaylist" style="background:var(--purple-core);border:none;border-radius:6px;color:var(--purple-white);font-family:var(--font-display);font-size:0.7rem;letter-spacing:0.08em;padding:8px 20px;cursor:pointer;transition:all 0.2s;">CREATE</button>
    </div>
  </div>
</div>

<!-- CONTEXT MENU -->
<div class="context-menu" id="contextMenu"></div>

<!-- TOAST CONTAINER -->
<div class="toast-container" id="toastContainer"></div>

<script>
// ============ SAFETY NET — dismiss splash on uncaught errors ============
window.addEventListener('error', (e) => {
  console.error('AETHER ERROR:', e.message, e.filename, e.lineno);
  const s = document.getElementById('splashScreen');
  if (s) { s.classList.add('fade-out'); setTimeout(() => s.remove(), 900); }
});
window.addEventListener('unhandledrejection', (e) => {
  console.error('AETHER PROMISE ERROR:', e.reason);
});

// ============ SPLASH — UFO CONTROL CONSOLE CANVAS ============
(function() {
  const sc = document.getElementById('splashCanvas');
  if (!sc) return;
  const ctx = sc.getContext('2d');
  let W, H;

  function resize() { W = sc.width = sc.offsetWidth; H = sc.height = sc.offsetHeight; }
  resize();
  window.addEventListener('resize', resize);

  const radarDots = [];
  for (let i = 0; i < 60; i++) {
    radarDots.push({ angle: Math.random() * Math.PI * 2, r: 30 + Math.random() * 250, speed: 0.0003 + Math.random() * 0.001 });
  }

  let splashFrame = 0;

  function draw(t) {
    if (!document.getElementById('splashScreen')) return;
    splashFrame++;
    ctx.clearRect(0, 0, W, H);
    const cx = W / 2, cy = H / 2;

    // Concentric HUD rings with tick marks
    for (let i = 1; i <= 6; i++) {
      const r = i * 55;
      const breathe = Math.sin(t * 0.001 + i * 0.5) * 3;
      ctx.beginPath();
      ctx.arc(cx, cy, r + breathe, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(157,78,221,${0.04 + (1 - i/6) * 0.08})`;
      ctx.lineWidth = 0.8;
      ctx.stroke();

      const ticks = 12 + i * 4;
      for (let j = 0; j < ticks; j++) {
        const a = (j / ticks) * Math.PI * 2 + t * 0.0002 * (i % 2 === 0 ? 1 : -1);
        const innerR = r + breathe - 4;
        const outerR = r + breathe + (j % 4 === 0 ? 8 : 3);
        ctx.beginPath();
        ctx.moveTo(cx + Math.cos(a) * innerR, cy + Math.sin(a) * innerR);
        ctx.lineTo(cx + Math.cos(a) * outerR, cy + Math.sin(a) * outerR);
        ctx.strokeStyle = `rgba(123,47,190,${j % 4 === 0 ? 0.15 : 0.06})`;
        ctx.lineWidth = j % 4 === 0 ? 1 : 0.5;
        ctx.stroke();
      }
    }

    // Radar sweep
    const sweepAngle = t * 0.0015;
    const sweepGrad = ctx.createConicGradient(sweepAngle, cx, cy);
    sweepGrad.addColorStop(0, 'rgba(183,110,255,0.12)');
    sweepGrad.addColorStop(0.08, 'rgba(183,110,255,0.02)');
    sweepGrad.addColorStop(0.1, 'transparent');
    sweepGrad.addColorStop(1, 'transparent');
    ctx.beginPath();
    ctx.arc(cx, cy, 330, 0, Math.PI * 2);
    ctx.fillStyle = sweepGrad;
    ctx.fill();

    // Sweep line
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(sweepAngle) * 330, cy + Math.sin(sweepAngle) * 330);
    ctx.strokeStyle = 'rgba(183,110,255,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Radar blips that light up as sweep passes
    radarDots.forEach(d => {
      d.angle += d.speed;
      const x = cx + Math.cos(d.angle) * d.r;
      const y = cy + Math.sin(d.angle) * d.r;
      const angleDiff = ((d.angle - sweepAngle) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
      const brightness = angleDiff < 0.5 ? (1 - angleDiff / 0.5) : 0;
      if (brightness > 0) {
        ctx.beginPath();
        ctx.arc(x, y, 1.5, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(183,110,255,${brightness * 0.7})`;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(183,110,255,${brightness * 0.15})`;
        ctx.fill();
      }
    });

    // Crosshair dashed lines
    ctx.setLineDash([4, 8]);
    ctx.strokeStyle = 'rgba(74,45,107,0.15)';
    ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.moveTo(cx - 350, cy); ctx.lineTo(cx + 350, cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, cy - 350); ctx.lineTo(cx, cy + 350); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx - 250, cy - 250); ctx.lineTo(cx + 250, cy + 250); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx + 250, cy - 250); ctx.lineTo(cx - 250, cy + 250); ctx.stroke();
    ctx.setLineDash([]);

    // Corner HUD readouts
    const pad = 40;
    ctx.font = '10px "JetBrains Mono"';
    ctx.fillStyle = `rgba(157,78,221,${0.3 + Math.sin(t * 0.003) * 0.1})`;
    ctx.textAlign = 'left';
    ctx.fillText('SYS://AETHER.AUDIO.' + splashFrame.toString(16).toUpperCase().padStart(4, '0'), pad, pad);
    ctx.fillText('NODE: 127.0.0.1:4533', pad, pad + 16);

    ctx.textAlign = 'right';
    ctx.fillStyle = 'rgba(123,47,190,0.25)';
    ctx.fillText('FFT: 2048 | SR: 48000', W - pad, pad);
    ctx.fillText('BANDS: 10 | SMOOTH: 0.82', W - pad, pad + 16);

    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(74,45,107,0.3)';
    ctx.fillText('OLED_PROTOCOL: ACTIVE', pad, H - pad - 16);
    ctx.fillText('TRON_MATRIX: ENGAGED', pad, H - pad);

    ctx.textAlign = 'right';
    ctx.fillStyle = 'rgba(74,45,107,0.25)';
    ctx.fillText('BUILD: 2077.1.0', W - pad, H - pad - 16);
    ctx.fillText('ENGINE: WEB_AUDIO_V2', W - pad, H - pad);
    ctx.textAlign = 'left';

    // Orbiting arc segments with glowing endpoints
    for (let i = 0; i < 4; i++) {
      const r = 100 + i * 70;
      const startA = t * (0.0005 + i * 0.0002) * (i % 2 === 0 ? 1 : -1) + i * 1.5;
      const len = 0.3 + Math.sin(t * 0.001 + i) * 0.15;
      ctx.beginPath();
      ctx.arc(cx, cy, r, startA, startA + len);
      ctx.strokeStyle = `rgba(183,110,255,${0.2 + i * 0.05})`;
      ctx.lineWidth = 2;
      ctx.stroke();
      const ex = cx + Math.cos(startA + len) * r;
      const ey = cy + Math.sin(startA + len) * r;
      ctx.beginPath();
      ctx.arc(ex, ey, 3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(183,110,255,${0.3 + i * 0.1})`;
      ctx.fill();
    }

    // Central pulsing core
    const coreR = 8 + Math.sin(t * 0.004) * 2;
    const coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR * 4);
    coreGrad.addColorStop(0, 'rgba(212,160,255,0.4)');
    coreGrad.addColorStop(0.3, 'rgba(183,110,255,0.15)');
    coreGrad.addColorStop(1, 'transparent');
    ctx.beginPath();
    ctx.arc(cx, cy, coreR * 4, 0, Math.PI * 2);
    ctx.fillStyle = coreGrad;
    ctx.fill();

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();

// Splash helpers
function splashProgress(pct, status) {
  const bar = document.getElementById('splashBarFill');
  const txt = document.getElementById('splashStatus');
  if (bar) bar.style.width = pct + '%';
  if (txt) txt.textContent = status;
}
function dismissSplash() {
  const s = document.getElementById('splashScreen');
  if (!s) return;
  s.classList.add('fade-out');
  setTimeout(() => s.remove(), 900);
}

// ============ MINIMAL MD5 (Joseph Myers) ============
function md5(str) {
  function cmn(q, a, b, x, s, t) { a = (a + q + (x >>> 0) + t) | 0; return (((a << s) | (a >>> (32 - s))) + b) | 0; }
  function ff(a,b,c,d,x,s,t) { return cmn((b & c) | (~b & d), a, b, x, s, t); }
  function gg(a,b,c,d,x,s,t) { return cmn((b & d) | (c & ~d), a, b, x, s, t); }
  function hh(a,b,c,d,x,s,t) { return cmn(b ^ c ^ d, a, b, x, s, t); }
  function ii(a,b,c,d,x,s,t) { return cmn(c ^ (b | ~d), a, b, x, s, t); }
  function cycle(x, k) {
    var a = x[0], b = x[1], c = x[2], d = x[3];
    a = ff(a,b,c,d,k[0],7,-680876936); d = ff(d,a,b,c,k[1],12,-389564586); c = ff(c,d,a,b,k[2],17,606105819); b = ff(b,c,d,a,k[3],22,-1044525330);
    a = ff(a,b,c,d,k[4],7,-176418897); d = ff(d,a,b,c,k[5],12,1200080426); c = ff(c,d,a,b,k[6],17,-1473231341); b = ff(b,c,d,a,k[7],22,-45705983);
    a = ff(a,b,c,d,k[8],7,1770035416); d = ff(d,a,b,c,k[9],12,-1958414417); c = ff(c,d,a,b,k[10],17,-42063); b = ff(b,c,d,a,k[11],22,-1990404162);
    a = ff(a,b,c,d,k[12],7,1804603682); d = ff(d,a,b,c,k[13],12,-40341101); c = ff(c,d,a,b,k[14],17,-1502002290); b = ff(b,c,d,a,k[15],22,1236535329);
    a = gg(a,b,c,d,k[1],5,-165796510); d = gg(d,a,b,c,k[6],9,-1069501632); c = gg(c,d,a,b,k[11],14,643717713); b = gg(b,c,d,a,k[0],20,-373897302);
    a = gg(a,b,c,d,k[5],5,-701558691); d = gg(d,a,b,c,k[10],9,38016083); c = gg(c,d,a,b,k[15],14,-660478335); b = gg(b,c,d,a,k[4],20,-405537848);
    a = gg(a,b,c,d,k[9],5,568446438); d = gg(d,a,b,c,k[14],9,-1019803690); c = gg(c,d,a,b,k[3],14,-187363961); b = gg(b,c,d,a,k[8],20,1163531501);
    a = gg(a,b,c,d,k[13],5,-1444681467); d = gg(d,a,b,c,k[2],9,-51403784); c = gg(c,d,a,b,k[7],14,1735328473); b = gg(b,c,d,a,k[12],20,-1926607734);
    a = hh(a,b,c,d,k[5],4,-378558); d = hh(d,a,b,c,k[8],11,-2022574463); c = hh(c,d,a,b,k[11],16,1839030562); b = hh(b,c,d,a,k[14],23,-35309556);
    a = hh(a,b,c,d,k[1],4,-1530992060); d = hh(d,a,b,c,k[4],11,1272893353); c = hh(c,d,a,b,k[7],16,-155497632); b = hh(b,c,d,a,k[10],23,-1094730640);
    a = hh(a,b,c,d,k[13],4,681279174); d = hh(d,a,b,c,k[0],11,-358537222); c = hh(c,d,a,b,k[3],16,-722521979); b = hh(b,c,d,a,k[6],23,76029189);
    a = hh(a,b,c,d,k[9],4,-640364487); d = hh(d,a,b,c,k[12],11,-421815835); c = hh(c,d,a,b,k[15],16,530742520); b = hh(b,c,d,a,k[2],23,-995338651);
    a = ii(a,b,c,d,k[0],6,-198630844); d = ii(d,a,b,c,k[7],10,1126891415); c = ii(c,d,a,b,k[14],15,-1416354905); b = ii(b,c,d,a,k[5],21,-57434055);
    a = ii(a,b,c,d,k[12],6,1700485571); d = ii(d,a,b,c,k[3],10,-1894986606); c = ii(c,d,a,b,k[10],15,-1051523); b = ii(b,c,d,a,k[1],21,-2054922799);
    a = ii(a,b,c,d,k[8],6,1873313359); d = ii(d,a,b,c,k[15],10,-30611744); c = ii(c,d,a,b,k[6],15,-1560198380); b = ii(b,c,d,a,k[13],21,1309151649);
    a = ii(a,b,c,d,k[4],6,-145523070); d = ii(d,a,b,c,k[11],10,-1120210379); c = ii(c,d,a,b,k[2],15,718787259); b = ii(b,c,d,a,k[9],21,-343485551);
    x[0] = (x[0] + a) | 0; x[1] = (x[1] + b) | 0; x[2] = (x[2] + c) | 0; x[3] = (x[3] + d) | 0;
  }
  var n = str.length, state = [1732584193, -271733879, -1732584194, 271733878];
  var i, tail = [], lo = n * 8;
  for (i = 0; i + 64 <= n; i += 64) {
    var w = [];
    for (var j = 0; j < 64; j += 4) w.push(str.charCodeAt(i+j) | (str.charCodeAt(i+j+1) << 8) | (str.charCodeAt(i+j+2) << 16) | (str.charCodeAt(i+j+3) << 24));
    cycle(state, w);
  }
  for (var j = i; j < n; j++) tail.push(str.charCodeAt(j));
  tail.push(0x80);
  while (tail.length % 64 !== 56) tail.push(0);
  var words = [];
  for (var j = 0; j < tail.length; j += 4) words.push(tail[j] | (tail[j+1] << 8) | (tail[j+2] << 16) | (tail[j+3] << 24));
  words.push(lo); words.push(0);
  for (i = 0; i < words.length; i += 16) cycle(state, words.slice(i, i + 16));
  var hex = '';
  for (i = 0; i < 4; i++) for (var j = 0; j < 4; j++) { var b = (state[i] >> (j * 8)) & 0xff; hex += (b < 16 ? '0' : '') + b.toString(16); }
  return hex;
}

// ============ SUBSONIC API CLIENT ============
// DEVNOTE: Default credentials below are local-only placeholders.
// Users configure their own server URL + credentials via Settings panel.
// Saved settings are loaded from localStorage on startup (see loadSavedSettings).
const SUBSONIC = {
  baseUrl: 'http://localhost:4533',
  user: 'phantom',
  password: 'phantom',
  auth() {
    const salt = Math.random().toString(36).slice(2, 10);
    const token = md5(this.password + salt);
    return `u=${this.user}&t=${token}&s=${salt}&v=1.16.1&c=Aether&f=json`;
  },
  async get(endpoint, params = {}) {
    const query = new URLSearchParams(params).toString();
    const url = `${this.baseUrl}/rest/${endpoint}?${this.auth()}${query ? '&' + query : ''}`;
    const res = await fetch(url);
    const data = await res.json();
    return data['subsonic-response'];
  },
  streamUrl(id) {
    return `${this.baseUrl}/rest/stream?id=${id}&${this.auth()}`;
  },
  coverUrl(id, size = 300) {
    // Stable auth for cover art so browser can cache images
    const salt = 'aether_cover';
    const token = md5(this.password + salt);
    return `${this.baseUrl}/rest/getCoverArt?id=${id}&size=${size}&u=${this.user}&t=${token}&s=${salt}&v=1.16.1&c=Aether&f=json`;
  }
};

// ============ UTILS ============
function escHtml(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

// ============ NAVIGATION HISTORY ============
let navHistory = [];
function pushNavState(viewFn, label) {
  navHistory.push({ fn: viewFn, label });
  const backBtn = document.getElementById('btnBack');
  if (backBtn) backBtn.style.display = navHistory.length > 1 ? 'flex' : 'none';
}
function navigateBack() {
  if (navHistory.length > 1) {
    navHistory.pop(); // Remove current
    const prev = navHistory[navHistory.length - 1];
    prev.fn();
  }
  const backBtn = document.getElementById('btnBack');
  if (backBtn) backBtn.style.display = navHistory.length > 1 ? 'flex' : 'none';
}

// ============ ORIENTATION ============
let currentOrientation = localStorage.getItem('aether_orientation') || 'horizontal';
function setOrientation(mode) {
  currentOrientation = mode;
  localStorage.setItem('aether_orientation', mode);
  if (mode === 'vertical') {
    document.body.classList.add('vertical-mode');
  } else {
    document.body.classList.remove('vertical-mode');
  }
  // Update settings buttons
  const hBtn = document.getElementById('settLayoutH');
  const vBtn = document.getElementById('settLayoutV');
  if (hBtn) hBtn.style.borderColor = mode === 'horizontal' ? 'var(--cyan-bright)' : 'var(--purple-dim)';
  if (vBtn) vBtn.style.borderColor = mode === 'vertical' ? 'var(--cyan-bright)' : 'var(--purple-dim)';
  showToast(`Layout: ${mode}`);
}
// Apply saved orientation on load
if (currentOrientation === 'vertical') document.body.classList.add('vertical-mode');

// ============ STATE ============
let currentQueue = [];
let currentQueueIndex = -1;
let isPlaying = false;
let isShuffle = false;
let repeatMode = 0; // 0=off, 1=all, 2=one
let allPlaylists = [];
let currentView = 'library';
let vizGlowIntensity = 0;
let currentScene = 0;
const SCENES = ['FRACTAL FLAME', 'VOID PULSE', 'TRON GRID', 'PARTICLE FIELD', 'WAVEFORM BARS', 'PLASMA WARP', 'NEURAL WEB', 'AURORA BOREALIS', 'DNA HELIX', 'COSMIC MANDALA', 'ELECTRIC SHEEP', 'BIO-GENESIS', 'COMMAND DECK', 'VOID PULSE II', 'NEURAL WEB II', 'DNA HELIX II', 'LYRIC RAIN'];
let vizAutoRotate = false;
let vizAutoRotateInterval = 60000;
let vizAutoRotateTimer = null;
let vizFullscreen = false;

// ============ AUDIO ELEMENT ============
const audio = new Audio();
audio.volume = 0.75;

// ============ WEB AUDIO API + BEAT DETECTION ============
let audioCtx = null;
let analyser = null;
let audioSource = null;
let freqData = null;
let beatIntensity = 0;
let lastBeatTime = 0;
let energyHistory = [];
const ENERGY_HISTORY_SIZE = 30;

const bands = { sub: 0, bass: 0, mid: 0, high: 0, energy: 0 };

// 10-Band Parametric EQ
const EQ_FREQUENCIES = [31, 62, 125, 250, 500, 1000, 2000, 4000, 8000, 16000];
let eqFilters = [];
let eqGains = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // dB, range -12 to +12

function setEqBand(bandIndex, gainDb) {
  eqGains[bandIndex] = Math.max(-12, Math.min(12, gainDb));
  if (eqFilters[bandIndex]) eqFilters[bandIndex].gain.value = eqGains[bandIndex];
  saveEqState();
  updateEqSliderVisuals(bandIndex);
}

// ============ EQ PRESETS & UI ============
const EQ_PRESETS = {
  'Flat':       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  'Bass Boost': [6, 5, 3, 1, 0, 0, 0, 0, 0, 0],
  'Treble':     [0, 0, 0, 0, 0, 1, 3, 4, 5, 6],
  'V-Shape':    [5, 4, 1, -1, -3, -3, -1, 1, 4, 5],
  'Vocal':      [-2, -1, 0, 2, 4, 4, 2, 0, -1, -2],
  'Loudness':   [4, 3, 0, 0, -2, 0, -1, 0, 3, 4],
  'Rock':       [4, 3, 1, 0, -1, 0, 2, 3, 4, 3],
  'Electronic': [5, 4, 2, 0, -2, 0, 1, 3, 4, 5],
  'Acoustic':   [3, 2, 1, 1, 0, 1, 1, 2, 3, 2],
  'Night':      [-3, -2, 0, 2, 3, 3, 2, 0, -2, -4],
};

let currentEqPreset = 'Flat';

const EQ_FREQ_LABELS = ['31', '62', '125', '250', '500', '1K', '2K', '4K', '8K', '16K'];

function saveEqState() {
  localStorage.setItem('aether_eq', JSON.stringify({ gains: eqGains, preset: currentEqPreset }));
}

function loadEqState() {
  try {
    const saved = JSON.parse(localStorage.getItem('aether_eq'));
    if (saved && saved.gains && saved.gains.length === 10) {
      eqGains = saved.gains.map(g => Math.max(-12, Math.min(12, g)));
      currentEqPreset = saved.preset || 'Flat';
    }
  } catch(e) { /* use defaults */ }
}

function applyEqPreset(name) {
  const preset = EQ_PRESETS[name];
  if (!preset) return;
  currentEqPreset = name;
  for (let i = 0; i < 10; i++) {
    eqGains[i] = preset[i];
    if (eqFilters[i]) eqFilters[i].gain.value = preset[i];
  }
  saveEqState();
  renderEqBands();
  renderEqPresets();
}

function resetEq() {
  applyEqPreset('Flat');
}

function updateEqSliderVisuals(bandIndex) {
  const db = eqGains[bandIndex];
  const dbEl = document.getElementById(`eqDb${bandIndex}`);
  if (dbEl) {
    const sign = db > 0 ? '+' : '';
    dbEl.textContent = `${sign}${db.toFixed(1)}`;
    dbEl.className = 'eq-band-db ' + (db > 0.1 ? 'positive' : db < -0.1 ? 'negative' : 'zero');
  }
  const slider = document.getElementById(`eqSlider${bandIndex}`);
  if (slider) slider.value = db;
  // Check if gains still match any preset
  let matchedPreset = null;
  for (const [name, vals] of Object.entries(EQ_PRESETS)) {
    if (vals.every((v, i) => Math.abs(v - eqGains[i]) < 0.1)) { matchedPreset = name; break; }
  }
  if (matchedPreset !== currentEqPreset) {
    currentEqPreset = matchedPreset || 'Custom';
    renderEqPresets();
  }
}

function renderEqPresets() {
  const container = document.getElementById('eqPresets');
  if (!container) return;
  container.innerHTML = Object.keys(EQ_PRESETS).map(name =>
    `<button class="eq-preset-btn${name === currentEqPreset ? ' active' : ''}" onclick="applyEqPreset('${name}')">${name}</button>`
  ).join('');
}

function renderEqBands() {
  const container = document.getElementById('eqBands');
  if (!container) return;
  container.innerHTML = EQ_FREQUENCIES.map((freq, i) => {
    const db = eqGains[i];
    const sign = db > 0 ? '+' : '';
    const dbClass = db > 0.1 ? 'positive' : db < -0.1 ? 'negative' : 'zero';
    return `<div class="eq-band">
      <div class="eq-band-db ${dbClass}" id="eqDb${i}">${sign}${db.toFixed(1)}</div>
      <div class="eq-slider-wrap">
        <input type="range" id="eqSlider${i}" min="-12" max="12" step="0.1" value="${db}"
          oninput="setEqBand(${i}, parseFloat(this.value))">
      </div>
      <div class="eq-band-freq">${EQ_FREQ_LABELS[i]}</div>
    </div>`;
  }).join('');
}

function toggleEqPanel() {
  const panel = document.getElementById('eqPanel');
  const btn = document.getElementById('eqToggleBtn');
  const isOpen = panel.classList.toggle('open');
  btn.classList.toggle('active', isOpen);
  if (isOpen) {
    renderEqPresets();
    renderEqBands();
  }
}

// Load saved EQ state before audio init
loadEqState();

function initAudioContext() {
  if (audioCtx) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    return;
  }
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.82;
    if (!audioSource) audioSource = audioCtx.createMediaElementSource(audio);
    // Build 10-band EQ chain: source → eq[0-9] → analyser → destination
    eqFilters = EQ_FREQUENCIES.map((freq, i) => {
      const f = audioCtx.createBiquadFilter();
      f.type = 'peaking';
      f.frequency.value = freq;
      f.Q.value = 1.4;
      f.gain.value = eqGains[i];
      return f;
    });
    audioSource.connect(eqFilters[0]);
    for (let i = 0; i < eqFilters.length - 1; i++) eqFilters[i].connect(eqFilters[i + 1]);
    eqFilters[eqFilters.length - 1].connect(analyser);
    analyser.connect(audioCtx.destination);
    freqData = new Uint8Array(analyser.frequencyBinCount);
    audioCtx.resume();
    console.log('Web Audio API initialized with 10-band EQ, state:', audioCtx.state);
  } catch(e) {
    console.error('Web Audio init failed:', e);
    audioCtx = null;
    analyser = null;
  }
}

// ============ BINAURAL BEATS GENERATOR ============
let binauralOscL = null, binauralOscR = null;
let binauralGain = null;
let binauralPanL = null, binauralPanR = null;
let binauralActive = false;
let binauralBaseFreq = 200;
let binauralBeatFreq = 10;
let binauralVolume = 0.3;
let binauralMixWithMusic = false;

const BINAURAL_PRESETS = [
  { name: 'Delta',  beat: 2,  base: 150, purpose: 'Deep Sleep' },
  { name: 'Theta',  beat: 6,  base: 200, purpose: 'Meditation' },
  { name: 'Alpha',  beat: 10, base: 200, purpose: 'Relaxation / Focus' },
  { name: 'Beta',   beat: 20, base: 250, purpose: 'Alertness' },
  { name: 'Gamma',  beat: 40, base: 300, purpose: 'Peak Cognition' },
];

function startBinaural(baseFreq, beatFreq) {
  initAudioContext();
  if (!audioCtx) return;
  stopBinaural();
  binauralBaseFreq = baseFreq;
  binauralBeatFreq = beatFreq;

  binauralGain = audioCtx.createGain();
  binauralGain.gain.value = binauralVolume;

  binauralPanL = audioCtx.createStereoPanner();
  binauralPanL.pan.value = -1;
  binauralPanR = audioCtx.createStereoPanner();
  binauralPanR.pan.value = 1;

  binauralOscL = audioCtx.createOscillator();
  binauralOscL.type = 'sine';
  binauralOscL.frequency.value = baseFreq;

  binauralOscR = audioCtx.createOscillator();
  binauralOscR.type = 'sine';
  binauralOscR.frequency.value = baseFreq + beatFreq;

  binauralOscL.connect(binauralPanL);
  binauralPanL.connect(binauralGain);
  binauralOscR.connect(binauralPanR);
  binauralPanR.connect(binauralGain);

  // Connect to analyser so visualizers react
  binauralGain.connect(analyser);
  if (!binauralMixWithMusic) {
    // Disconnect music from analyser, keep binaural only
    try { eqFilters[eqFilters.length - 1].disconnect(analyser); } catch(e) {}
  }

  binauralOscL.start();
  binauralOscR.start();
  binauralActive = true;
  updateBinauralUI();
}

function stopBinaural() {
  if (binauralOscL) { try { binauralOscL.stop(); } catch(e) {} binauralOscL = null; }
  if (binauralOscR) { try { binauralOscR.stop(); } catch(e) {} binauralOscR = null; }
  if (binauralGain) { try { binauralGain.disconnect(); } catch(e) {} binauralGain = null; }
  if (binauralPanL) { try { binauralPanL.disconnect(); } catch(e) {} binauralPanL = null; }
  if (binauralPanR) { try { binauralPanR.disconnect(); } catch(e) {} binauralPanR = null; }
  // Reconnect music to analyser
  if (eqFilters.length > 0 && analyser) {
    try { eqFilters[eqFilters.length - 1].connect(analyser); } catch(e) {}
  }
  binauralActive = false;
  updateBinauralUI();
}

function updateBinauralFreqs(baseFreq, beatFreq) {
  binauralBaseFreq = baseFreq;
  binauralBeatFreq = beatFreq;
  if (binauralOscL) binauralOscL.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);
  if (binauralOscR) binauralOscR.frequency.setValueAtTime(baseFreq + beatFreq, audioCtx.currentTime);
  updateBinauralUI();
}

function updateBinauralVolume(vol) {
  binauralVolume = vol;
  if (binauralGain) binauralGain.gain.setValueAtTime(vol, audioCtx.currentTime);
}

function toggleBinauralMix(mix) {
  binauralMixWithMusic = mix;
  if (!binauralActive || !analyser) return;
  if (mix) {
    try { eqFilters[eqFilters.length - 1].connect(analyser); } catch(e) {}
  } else {
    try { eqFilters[eqFilters.length - 1].disconnect(analyser); } catch(e) {}
  }
}

function updateBinauralUI() {
  const freqL = document.getElementById('binauralFreqL');
  const freqR = document.getElementById('binauralFreqR');
  const freqBeat = document.getElementById('binauralFreqBeat');
  const playBtn = document.getElementById('binauralPlayBtn');
  const status = document.getElementById('binauralStatus');
  if (freqL) freqL.textContent = binauralBaseFreq.toFixed(1) + ' Hz';
  if (freqR) freqR.textContent = (binauralBaseFreq + binauralBeatFreq).toFixed(1) + ' Hz';
  if (freqBeat) freqBeat.textContent = binauralBeatFreq.toFixed(1) + ' Hz';
  if (playBtn) {
    playBtn.classList.toggle('active', binauralActive);
    playBtn.innerHTML = binauralActive
      ? '<svg viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>STOP'
      : '<svg viewBox="0 0 24 24"><polygon points="5,3 19,12 5,21"/></svg>PLAY';
  }
  if (status) {
    status.className = 'binaural-status' + (binauralActive ? ' active' : '');
    status.textContent = binauralActive
      ? `Active — L: ${binauralBaseFreq.toFixed(1)} Hz  R: ${(binauralBaseFreq + binauralBeatFreq).toFixed(1)} Hz  Beat: ${binauralBeatFreq.toFixed(1)} Hz`
      : 'Inactive — Select a preset or adjust sliders and press Play';
  }
  // Update slider values if they exist
  const baseVal = document.getElementById('binauralBaseVal');
  const beatVal = document.getElementById('binauralBeatVal');
  const volVal = document.getElementById('binauralVolVal');
  if (baseVal) baseVal.textContent = binauralBaseFreq.toFixed(0) + ' Hz';
  if (beatVal) beatVal.textContent = binauralBeatFreq.toFixed(1) + ' Hz';
  if (volVal) volVal.textContent = Math.round(binauralVolume * 100) + '%';
}

// ============ RHYTHMIC BRAINWAVE LAYER ENGINE ============
const RHYTHM_DIVISIONS = [
  { id: 'whole',    label: '1 bar',    beatsPerMeasure: 1,  desc: 'Once per measure' },
  { id: 'half',     label: '1/2',      beatsPerMeasure: 2,  desc: 'Half notes' },
  { id: 'quarter',  label: '1/4',      beatsPerMeasure: 4,  desc: 'Quarter notes' },
  { id: 'eighth',   label: '1/8',      beatsPerMeasure: 8,  desc: 'Eighth notes' },
  { id: 'triplet',  label: 'triplet',  beatsPerMeasure: 3,  desc: 'Triplets per measure' },
  { id: 'sixtuplet',label: '6-tuplet', beatsPerMeasure: 6,  desc: '6 per measure' },
  { id: 'sixteenth',label: '1/16',     beatsPerMeasure: 16, desc: 'Sixteenth notes' },
];

const RHYTHM_PRESETS = [
  {
    name: 'Deep Meditation',
    desc: 'Delta whole + Theta halves',
    bpm: 60,
    layers: [
      { preset: 0, division: 'whole', volume: 0.3 },
      { preset: 1, division: 'half', volume: 0.25 },
    ]
  },
  {
    name: 'Focus Flow',
    desc: 'Alpha quarters + Beta eighths',
    bpm: 80,
    layers: [
      { preset: 2, division: 'quarter', volume: 0.3 },
      { preset: 3, division: 'eighth', volume: 0.15 },
    ]
  },
  {
    name: 'Lucid Dream',
    desc: 'Delta whole + Theta quarter + Alpha triplet',
    bpm: 50,
    layers: [
      { preset: 0, division: 'whole', volume: 0.35 },
      { preset: 1, division: 'quarter', volume: 0.2 },
      { preset: 2, division: 'triplet', volume: 0.15 },
    ]
  },
  {
    name: 'Peak Performance',
    desc: 'Alpha half + Beta quarter + Gamma eighth',
    bpm: 100,
    layers: [
      { preset: 2, division: 'half', volume: 0.2 },
      { preset: 3, division: 'quarter', volume: 0.25 },
      { preset: 4, division: 'eighth', volume: 0.15 },
    ]
  },
  {
    name: 'Shamanic Journey',
    desc: 'Theta whole + Delta triplet + Gamma sixteenths',
    bpm: 55,
    layers: [
      { preset: 1, division: 'whole', volume: 0.35 },
      { preset: 0, division: 'triplet', volume: 0.2 },
      { preset: 4, division: 'sixteenth', volume: 0.1 },
    ]
  },
];

let rhythmLayers = [];
let rhythmBPM = 72;
let rhythmActive = false;
let rhythmSchedulerTimer = null;
let rhythmMasterGain = null;
let rhythmLayerIdCounter = 0;
let rhythmBeatVizTimer = null;
let rhythmMeasureStartTime = 0;
const RHYTHM_LOOKAHEAD = 0.15;
const RHYTHM_INTERVAL = 25;

// Color per brainwave for layer badges
const BRAINWAVE_COLORS = ['#6366f1','#8b5cf6','#a78bfa','#f59e0b','#ef4444'];

function addRhythmLayer(presetIdx = 2, divisionId = 'quarter') {
  const id = ++rhythmLayerIdCounter;
  const div = RHYTHM_DIVISIONS.find(d => d.id === divisionId) || RHYTHM_DIVISIONS[2];
  rhythmLayers.push({
    id,
    preset: presetIdx,
    divisionId: div.id,
    beatsPerMeasure: div.beatsPerMeasure,
    volume: 0.25,
    oscL: null, oscR: null, panL: null, panR: null, gain: null,
    nextPulseTime: 0,
  });
  renderRhythmLayers();
  return id;
}

function removeRhythmLayer(layerId) {
  const idx = rhythmLayers.findIndex(l => l.id === layerId);
  if (idx === -1) return;
  destroyLayerNodes(rhythmLayers[idx]);
  rhythmLayers.splice(idx, 1);
  renderRhythmLayers();
}

function updateRhythmLayerPreset(layerId, presetIdx) {
  const layer = rhythmLayers.find(l => l.id === layerId);
  if (!layer) return;
  layer.preset = presetIdx;
  if (rhythmActive && layer.oscL) {
    const p = BINAURAL_PRESETS[presetIdx];
    layer.oscL.frequency.setValueAtTime(p.base, audioCtx.currentTime);
    layer.oscR.frequency.setValueAtTime(p.base + p.beat, audioCtx.currentTime);
  }
}

function updateRhythmLayerDivision(layerId, divisionId) {
  const layer = rhythmLayers.find(l => l.id === layerId);
  if (!layer) return;
  const div = RHYTHM_DIVISIONS.find(d => d.id === divisionId);
  if (!div) return;
  layer.divisionId = div.id;
  layer.beatsPerMeasure = div.beatsPerMeasure;
  // Recalculate next pulse time from measure start
  if (rhythmActive && audioCtx) {
    const measureDur = (60 / rhythmBPM) * 4;
    const pulseDur = measureDur / layer.beatsPerMeasure;
    const elapsed = audioCtx.currentTime - rhythmMeasureStartTime;
    const nextPulseInMeasure = Math.ceil(elapsed / pulseDur) * pulseDur;
    layer.nextPulseTime = rhythmMeasureStartTime + nextPulseInMeasure;
  }
}

function updateRhythmLayerVolume(layerId, vol) {
  const layer = rhythmLayers.find(l => l.id === layerId);
  if (layer) layer.volume = vol;
}

function createLayerNodes(layer) {
  const p = BINAURAL_PRESETS[layer.preset];
  layer.gain = audioCtx.createGain();
  layer.gain.gain.value = 0;
  layer.panL = audioCtx.createStereoPanner();
  layer.panL.pan.value = -1;
  layer.panR = audioCtx.createStereoPanner();
  layer.panR.pan.value = 1;
  layer.oscL = audioCtx.createOscillator();
  layer.oscL.type = 'sine';
  layer.oscL.frequency.value = p.base;
  layer.oscR = audioCtx.createOscillator();
  layer.oscR.type = 'sine';
  layer.oscR.frequency.value = p.base + p.beat;
  layer.oscL.connect(layer.panL);
  layer.panL.connect(layer.gain);
  layer.oscR.connect(layer.panR);
  layer.panR.connect(layer.gain);
  layer.gain.connect(rhythmMasterGain);
  layer.oscL.start();
  layer.oscR.start();
}

function destroyLayerNodes(layer) {
  if (layer.oscL) { try { layer.oscL.stop(); } catch(e) {} layer.oscL = null; }
  if (layer.oscR) { try { layer.oscR.stop(); } catch(e) {} layer.oscR = null; }
  if (layer.gain) { try { layer.gain.disconnect(); } catch(e) {} layer.gain = null; }
  if (layer.panL) { try { layer.panL.disconnect(); } catch(e) {} layer.panL = null; }
  if (layer.panR) { try { layer.panR.disconnect(); } catch(e) {} layer.panR = null; }
}

function startRhythm() {
  initAudioContext();
  if (!audioCtx) return;
  if (rhythmLayers.length === 0) {
    showToast('Add at least one brainwave layer first');
    return;
  }
  stopRhythm();

  rhythmMasterGain = audioCtx.createGain();
  rhythmMasterGain.gain.value = 0.5;
  rhythmMasterGain.connect(analyser);
  if (!binauralMixWithMusic) {
    try { eqFilters[eqFilters.length - 1].disconnect(analyser); } catch(e) {}
  }

  const now = audioCtx.currentTime + 0.05;
  rhythmMeasureStartTime = now;
  rhythmLayers.forEach(layer => {
    createLayerNodes(layer);
    layer.nextPulseTime = now;
  });

  rhythmActive = true;
  rhythmSchedulerTimer = setInterval(rhythmScheduler, RHYTHM_INTERVAL);
  startRhythmBeatViz();
  updateRhythmUI();
  showToast('Rhythmic brainwave engine started');
}

function stopRhythm() {
  if (rhythmSchedulerTimer) { clearInterval(rhythmSchedulerTimer); rhythmSchedulerTimer = null; }
  if (rhythmBeatVizTimer) { clearInterval(rhythmBeatVizTimer); rhythmBeatVizTimer = null; }
  rhythmLayers.forEach(layer => destroyLayerNodes(layer));
  if (rhythmMasterGain) { try { rhythmMasterGain.disconnect(); } catch(e) {} rhythmMasterGain = null; }
  if (eqFilters.length > 0 && analyser) {
    try { eqFilters[eqFilters.length - 1].connect(analyser); } catch(e) {}
  }
  rhythmActive = false;
  updateRhythmUI();
}

function rhythmScheduler() {
  if (!audioCtx || !rhythmActive) return;
  const deadline = audioCtx.currentTime + RHYTHM_LOOKAHEAD;
  const measureDuration = (60 / rhythmBPM) * 4;

  rhythmLayers.forEach(layer => {
    if (!layer.gain) return;
    const pulseDuration = measureDuration / layer.beatsPerMeasure;

    while (layer.nextPulseTime < deadline) {
      schedulePulse(layer, layer.nextPulseTime, pulseDuration);
      layer.nextPulseTime += pulseDuration;
    }
  });
}

function schedulePulse(layer, time, duration) {
  if (!layer.gain) return;
  const attack = Math.min(0.04, duration * 0.08);
  const sustain = duration * 0.55;
  const release = Math.min(duration * 0.35, 0.5);
  const g = layer.gain.gain;
  // Cancel any previous scheduled values for clean transitions
  g.cancelScheduledValues(time);
  g.setValueAtTime(0, time);
  g.linearRampToValueAtTime(layer.volume, time + attack);
  g.setValueAtTime(layer.volume, time + attack + sustain);
  g.linearRampToValueAtTime(0, time + attack + sustain + release);
}

function startRhythmBeatViz() {
  if (rhythmBeatVizTimer) clearInterval(rhythmBeatVizTimer);
  rhythmBeatVizTimer = setInterval(() => {
    if (!rhythmActive || !audioCtx) return;
    const now = audioCtx.currentTime;
    const measureDur = (60 / rhythmBPM) * 4;
    const beatDur = measureDur / 4;
    const elapsed = now - rhythmMeasureStartTime;
    const measurePos = ((elapsed % measureDur) + measureDur) % measureDur;
    const currentBeat = Math.floor(measurePos / beatDur);

    // Update beat dots
    document.querySelectorAll('.rhythm-beat-dot').forEach((dot, i) => {
      dot.classList.toggle('on', i === currentBeat);
      dot.classList.toggle('accent', i === currentBeat && i === 0);
    });

    // Update layer pulse indicators
    rhythmLayers.forEach(layer => {
      const indicator = document.getElementById('rhythmLayerInd_' + layer.id);
      if (!indicator) return;
      const pulseDur = measureDur / layer.beatsPerMeasure;
      const pulsePos = measurePos % pulseDur;
      const isOn = pulsePos < pulseDur * 0.4;
      indicator.classList.toggle('on', isOn);
    });
  }, 50);
}

function applyRhythmPreset(index) {
  const rp = RHYTHM_PRESETS[index];
  // Stop if running
  if (rhythmActive) stopRhythm();
  // Clear existing layers
  rhythmLayers = [];
  rhythmLayerIdCounter = 0;
  rhythmBPM = rp.bpm;
  // Add layers from preset
  rp.layers.forEach(l => {
    const id = ++rhythmLayerIdCounter;
    const div = RHYTHM_DIVISIONS.find(d => d.id === l.division) || RHYTHM_DIVISIONS[2];
    rhythmLayers.push({
      id, preset: l.preset, divisionId: div.id,
      beatsPerMeasure: div.beatsPerMeasure, volume: l.volume,
      oscL: null, oscR: null, panL: null, panR: null, gain: null, nextPulseTime: 0,
    });
  });
  // Update UI
  const bpmSlider = document.getElementById('rhythmBpmSlider');
  const bpmVal = document.getElementById('rhythmBpmVal');
  if (bpmSlider) bpmSlider.value = rhythmBPM;
  if (bpmVal) bpmVal.textContent = rhythmBPM + ' BPM';
  document.querySelectorAll('.rhythm-preset-btn').forEach((btn, i) => {
    btn.classList.toggle('active', i === index);
  });
  renderRhythmLayers();
  // Auto-start
  startRhythm();
}

function renderRhythmLayers() {
  const container = document.getElementById('rhythmLayersContainer');
  if (!container) return;

  const presetOptions = BINAURAL_PRESETS.map((p, i) =>
    `<option value="${i}">${p.name} (${p.beat}Hz)</option>`
  ).join('');
  const divOptions = RHYTHM_DIVISIONS.map(d =>
    `<option value="${d.id}">${d.label}</option>`
  ).join('');

  container.innerHTML = rhythmLayers.map((layer, idx) => {
    const p = BINAURAL_PRESETS[layer.preset];
    const bgColor = BRAINWAVE_COLORS[layer.preset] || '#7B2FBE';
    return `<div class="rhythm-layer-card" id="rhythmLayerCard_${layer.id}">
      <div class="rhythm-layer-indicator" id="rhythmLayerInd_${layer.id}"></div>
      <div class="rhythm-layer-num">${idx + 1}</div>
      <div class="rhythm-layer-badge" style="background:${bgColor}22;color:${bgColor};border:1px solid ${bgColor}44;">${escHtml(p.name)}</div>
      <select class="rhythm-layer-select" onchange="updateRhythmLayerPreset(${layer.id},+this.value)" title="Brainwave">
        ${BINAURAL_PRESETS.map((p2,i) => `<option value="${i}" ${i===layer.preset?'selected':''}>${p2.name} (${p2.beat}Hz)</option>`).join('')}
      </select>
      <select class="rhythm-layer-select" onchange="updateRhythmLayerDivision(${layer.id},this.value)" title="Rhythm">
        ${RHYTHM_DIVISIONS.map(d => `<option value="${d.id}" ${d.id===layer.divisionId?'selected':''}>${d.label}</option>`).join('')}
      </select>
      <input type="range" class="binaural-slider rhythm-layer-vol" min="0" max="0.5" step="0.01" value="${layer.volume}"
        oninput="updateRhythmLayerVolume(${layer.id},+this.value);this.nextElementSibling.textContent=Math.round(this.value*200)+'%'" title="Layer volume">
      <div class="rhythm-layer-vol-label">${Math.round(layer.volume * 200)}%</div>
      <button class="rhythm-layer-remove" onclick="removeRhythmLayer(${layer.id})" title="Remove layer">&times;</button>
    </div>`;
  }).join('');
}

function updateRhythmUI() {
  const playBtn = document.getElementById('rhythmPlayBtn');
  if (playBtn) {
    playBtn.classList.toggle('active', rhythmActive);
    playBtn.innerHTML = rhythmActive
      ? '<svg viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>STOP'
      : '<svg viewBox="0 0 24 24"><polygon points="5,3 19,12 5,21"/></svg>START';
  }
}

function updateAudioAnalysis() {
  if (!analyser || !freqData) {
    requestAnimationFrame(updateAudioAnalysis);
    return;
  }

  analyser.getByteFrequencyData(freqData);

  // Extract frequency bands
  let subSum = 0, bassSum = 0, midSum = 0, highSum = 0, totalSum = 0;
  for (let i = 1; i < 4; i++) subSum += freqData[i];
  for (let i = 4; i < 12; i++) bassSum += freqData[i];
  for (let i = 12; i < 40; i++) midSum += freqData[i];
  for (let i = 40; i < 120; i++) highSum += freqData[i];
  for (let i = 0; i < 256; i++) totalSum += freqData[i];

  bands.sub = subSum / (3 * 255);
  bands.bass = bassSum / (8 * 255);
  bands.mid = midSum / (28 * 255);
  bands.high = highSum / (80 * 255);
  bands.energy = totalSum / (256 * 255);

  // Beat detection via energy threshold
  const currentEnergy = bands.bass * 0.7 + bands.sub * 0.3;
  energyHistory.push(currentEnergy);
  if (energyHistory.length > ENERGY_HISTORY_SIZE) energyHistory.shift();

  const avgEnergy = energyHistory.reduce((a, b) => a + b, 0) / energyHistory.length;
  const now = performance.now();

  if (currentEnergy > avgEnergy * 1.4 && now - lastBeatTime > 250) {
    beatIntensity = Math.min(1, currentEnergy / Math.max(avgEnergy, 0.01) - 1);
    lastBeatTime = now;
  }

  // Decay beat intensity
  beatIntensity *= 0.85;

  // Update CSS custom properties for beat-reactive UI
  const root = document.documentElement.style;
  root.setProperty('--beat', beatIntensity.toFixed(3));
  root.setProperty('--bass', bands.bass.toFixed(3));
  root.setProperty('--energy', bands.energy.toFixed(3));
  root.setProperty('--mid', bands.mid.toFixed(3));
  root.setProperty('--high', bands.high.toFixed(3));

  requestAnimationFrame(updateAudioAnalysis);
}

// Start the analysis loop
requestAnimationFrame(updateAudioAnalysis);

// ============ TOAST SYSTEM ============
function showToast(text) {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.innerHTML = `<div class="toast-text">${text}</div><div class="toast-progress"></div>`;
  container.appendChild(toast);
  setTimeout(() => {
    toast.classList.add('removing');
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}

// ============ FORMAT DURATION ============
function fmtDur(sec) {
  if (!sec || isNaN(sec)) return '0:00';
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${String(s).padStart(2, '0')}`;
}

// ============ RENDER TRACK LIST ============
function renderTrackList(tracks, containerId, filter = '') {
  const container = document.getElementById(containerId);
  if (!container) return;
  let filtered = tracks;
  if (filter) {
    const f = filter.toLowerCase();
    filtered = tracks.filter(t => ((t.title||'')+(t.artist||'')+(t.album||'')).toLowerCase().includes(f));
  }
  // Cap rendered rows for performance; full list still available for playback
  const MAX_RENDER = 300;
  const allFiltered = filtered;
  if (filtered.length > MAX_RENDER) filtered = filtered.slice(0, MAX_RENDER);
  container.innerHTML = filtered.map((t, i) => {
    const isCurrentPlaying = currentQueue[currentQueueIndex] && currentQueue[currentQueueIndex].id === t.id;
    const coverSrc = t.coverArt ? SUBSONIC.coverUrl(t.coverArt, 80) : '';
    const suffix = (t.suffix || '').toUpperCase();
    const isLossless = ['FLAC','ALAC','WAV','AIFF','APE','WV'].includes(suffix);
    return `<div class="track-row track-enter ${isCurrentPlaying ? 'playing' : ''}" data-track-id="${t.id}" style="animation-delay:${i * 30}ms" oncontextmenu="showTrackContext(event,'${t.id}','${escHtml((t.title||'').replace(/'/g,"\\'"))}')">
      <div class="track-num">${i + 1}</div>
      <div class="eq-bars"><div class="eq-bar"></div><div class="eq-bar"></div><div class="eq-bar"></div><div class="eq-bar"></div></div>
      <div class="track-title-cell">
        <div class="track-art-small">${coverSrc ? `<img src="${coverSrc}" alt="" loading="lazy" onerror="this.style.display='none'">` : ''}</div>
        <div class="track-title-text">
          <div class="track-title">${escHtml(t.title) || 'Unknown'}</div>
          <div class="track-artist-sub">${escHtml(t.artist) || 'Unknown'}</div>
        </div>
      </div>
      <div class="track-album">${escHtml(t.album) || ''}</div>
      <div class="track-format ${isLossless ? 'lossless' : ''}">${suffix || '--'}</div>
      <div class="track-duration">${fmtDur(t.duration)}</div>
    </div>`;
  }).join('');

  container.querySelectorAll('.track-row').forEach((row, i) => {
    row.addEventListener('dblclick', () => {
      currentQueue = [...allFiltered];
      currentQueueIndex = i;
      playCurrentTrack();
    });
  });

  // Show count if truncated
  if (allFiltered.length > MAX_RENDER) {
    const note = document.createElement('div');
    note.style.cssText = 'text-align:center;padding:12px;font-family:var(--font-mono);font-size:0.65rem;color:var(--purple-muted);';
    note.textContent = `Showing ${MAX_RENDER} of ${allFiltered.length} tracks`;
    container.appendChild(note);
  }
}

// ============ PLAY CURRENT TRACK ============
function playCurrentTrack() {
  initAudioContext();
  if (currentQueueIndex < 0 || currentQueueIndex >= currentQueue.length) return;
  const t = currentQueue[currentQueueIndex];
  audio.src = SUBSONIC.streamUrl(t.id);
  audio.play().then(() => {
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    console.log('Playing:', t.title, '| AudioCtx:', audioCtx?.state);
  }).catch(e => {
    console.error('Play failed:', e);
    // Retry once after resuming context
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => audio.play().catch(() => {}));
    }
  });
  isPlaying = true;
  document.getElementById('btnPlay').classList.add('playing');

  // Update now playing info
  document.getElementById('npTitle').textContent = t.title || 'Unknown';
  document.getElementById('npArtist').textContent = t.artist || 'Unknown';
  document.getElementById('npAlbum').textContent = t.album || '';

  // Cover art
  const npArt = document.getElementById('npArt');
  if (t.coverArt) {
    npArt.innerHTML = `<img src="${SUBSONIC.coverUrl(t.coverArt, 300)}" alt="">`;
    npArt.classList.add('rotating');
    npArt.classList.remove('rotating-paused');
  } else {
    npArt.innerHTML = '';
    npArt.classList.remove('rotating', 'rotating-paused');
  }

  // Quality badge
  const suffix = (t.suffix || '').toUpperCase();
  const isLossless = ['FLAC','ALAC','WAV','AIFF'].includes(suffix);
  if (isLossless) {
    document.getElementById('qualityBadge').textContent = `${suffix} ${t.bitRate ? t.bitRate + 'k' : ''}`;
  } else {
    document.getElementById('qualityBadge').textContent = suffix + (t.bitRate ? ' ' + t.bitRate + 'k' : '');
  }
  document.getElementById('qualityBadge').classList.toggle('lossless-badge', t.suffix === 'flac' || t.suffix === 'alac' || t.suffix === 'wav' || (t.bitRate && t.bitRate > 1000));

  document.getElementById('seekTotal').textContent = fmtDur(t.duration);

  // Queue now playing
  const qArt = document.getElementById('queueNowArt');
  qArt.innerHTML = t.coverArt ? `<img src="${SUBSONIC.coverUrl(t.coverArt, 80)}" alt="">` : '';
  document.getElementById('queueNowTitle').textContent = t.title || 'Unknown';
  document.getElementById('queueNowArtist').textContent = t.artist || 'Unknown';

  renderQueueItems();
  generateWaveform();
  showToast(`Now playing: ${t.title}`);

  // Re-render active track list to highlight
  const trackList = document.getElementById('trackList');
  if (trackList) {
    trackList.querySelectorAll('.track-row').forEach(row => {
      row.classList.toggle('playing', row.dataset.trackId === t.id);
    });
  }
}

// ============ RENDER QUEUE ITEMS ============
function renderQueueItems() {
  const container = document.getElementById('queueItems');
  const upcoming = currentQueue.slice(currentQueueIndex + 1, currentQueueIndex + 15);
  container.innerHTML = upcoming.map((t, i) => `
    <div class="queue-item" data-track-id="${t.id}" data-queue-offset="${i + 1}" style="cursor:pointer">
      <div class="queue-item-art">${t.coverArt ? `<img src="${SUBSONIC.coverUrl(t.coverArt, 80)}" alt="" loading="lazy">` : ''}</div>
      <div class="queue-item-info">
        <div class="queue-item-title">${escHtml(t.title) || 'Unknown'}</div>
        <div class="queue-item-artist">${escHtml(t.artist) || 'Unknown'}</div>
      </div>
      <div class="queue-item-dur">${fmtDur(t.duration)}</div>
    </div>
  `).join('');
  // Make queue items clickable
  container.querySelectorAll('.queue-item').forEach(item => {
    item.addEventListener('click', () => {
      const offset = parseInt(item.dataset.queueOffset);
      currentQueueIndex += offset;
      playCurrentTrack();
    });
  });
}

// ============ WAVEFORM ============
function generateWaveform() {
  const container = document.getElementById('waveform');
  const bars = 80;
  let html = '';
  for (let i = 0; i < bars; i++) {
    const h = 8 + Math.random() * 20;
    html += `<div class="waveform-bar" style="height:${h}px"></div>`;
  }
  container.innerHTML = html;
}

function updateWaveformProgress(pct) {
  const bars = document.querySelectorAll('#waveform .waveform-bar');
  bars.forEach((b, i) => {
    b.classList.toggle('played', (i / bars.length) * 100 < pct);
  });
}

// ============ AUDIO EVENTS ============
audio.addEventListener('timeupdate', () => {
  if (!audio.duration) return;
  const pct = (audio.currentTime / audio.duration) * 100;
  document.getElementById('seekCurrent').textContent = fmtDur(audio.currentTime);
  updateWaveformProgress(pct);
});

audio.addEventListener('loadedmetadata', () => {
  document.getElementById('seekTotal').textContent = fmtDur(audio.duration);
});

audio.addEventListener('ended', () => {
  // Scrobble
  const t = currentQueue[currentQueueIndex];
  if (t) {
    SUBSONIC.get('scrobble', { id: t.id, submission: true }).catch(() => {});
  }
  // Next track logic
  if (repeatMode === 2) {
    audio.currentTime = 0;
    audio.play().catch(() => {});
  } else if (currentQueueIndex < currentQueue.length - 1) {
    currentQueueIndex++;
    playCurrentTrack();
  } else if (repeatMode === 1) {
    currentQueueIndex = 0;
    playCurrentTrack();
  } else {
    isPlaying = false;
    document.getElementById('btnPlay').classList.remove('playing');
    const npArt = document.getElementById('npArt');
    npArt.classList.remove('rotating');
    npArt.classList.add('rotating-paused');
  }
});

audio.addEventListener('play', () => {
  const npArt = document.getElementById('npArt');
  npArt.classList.add('rotating');
  npArt.classList.remove('rotating-paused');
});

audio.addEventListener('pause', () => {
  const npArt = document.getElementById('npArt');
  npArt.classList.remove('rotating');
  npArt.classList.add('rotating-paused');
});

// Waveform click to seek
document.getElementById('waveform').addEventListener('click', (e) => {
  if (!audio.duration) return;
  const rect = e.currentTarget.getBoundingClientRect();
  const pct = (e.clientX - rect.left) / rect.width;
  audio.currentTime = pct * audio.duration;
});

// ============ TRANSPORT CONTROLS ============
document.getElementById('btnPlay').addEventListener('click', function() {
  initAudioContext();
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  if (currentQueue.length === 0) return;
  if (isPlaying) {
    audio.pause();
    isPlaying = false;
    this.classList.remove('playing');
  } else {
    audio.play().catch(() => {});
    isPlaying = true;
    this.classList.add('playing');
  }
});

document.getElementById('btnNext').addEventListener('click', () => {
  if (currentQueue.length === 0) return;
  if (isShuffle) {
    if (currentQueue.length > 1) {
      let newIdx;
      do { newIdx = Math.floor(Math.random() * currentQueue.length); } while (newIdx === currentQueueIndex);
      currentQueueIndex = newIdx;
    }
  } else {
    currentQueueIndex = (currentQueueIndex + 1) % currentQueue.length;
  }
  playCurrentTrack();
});

document.getElementById('btnPrev').addEventListener('click', () => {
  if (currentQueue.length === 0) return;
  if (audio.currentTime > 3) {
    audio.currentTime = 0;
  } else {
    currentQueueIndex = (currentQueueIndex - 1 + currentQueue.length) % currentQueue.length;
    playCurrentTrack();
  }
});

document.getElementById('btnShuffle').addEventListener('click', function() {
  isShuffle = !isShuffle;
  this.classList.toggle('active', isShuffle);
});

document.getElementById('btnRepeat').addEventListener('click', function() {
  repeatMode = (repeatMode + 1) % 3;
  this.classList.toggle('active', repeatMode > 0);
  if (repeatMode === 2) this.title = 'Repeat One';
  else if (repeatMode === 1) this.title = 'Repeat All';
  else this.title = 'Repeat';
});

// Volume
document.getElementById('volumeSlider').addEventListener('input', (e) => {
  audio.volume = e.target.value / 100;
});

document.getElementById('btnMute').addEventListener('click', () => {
  audio.muted = !audio.muted;
});

// ============ ALBUM CARD RENDERER ============
function renderAlbumCards(albums, container, addBottomPad = false) {
  container.innerHTML = '';
  container.className = 'album-grid' + (addBottomPad ? ' bottom-pad' : '');
  albums.forEach(a => {
    const card = document.createElement('div');
    card.className = 'album-card';
    const coverSrc = a.coverArt ? SUBSONIC.coverUrl(a.coverArt, 300) : '';
    card.innerHTML = `
      <div class="album-art">
        ${coverSrc ? `<img src="${coverSrc}" alt="" loading="lazy" onerror="this.style.display='none';this.parentElement.innerHTML='<div class=\\'album-art-bg\\'><div class=\\'album-art-icon\\'><svg viewBox=\\'0 0 24 24\\'><path d=\\'M9 18V5l12-2v13\\' stroke=\\'var(--purple-muted)\\' fill=\\'none\\' stroke-width=\\'1\\'/></svg></div></div>'">` : `<div class="album-art-bg"><div class="album-art-icon"><svg viewBox="0 0 24 24"><path d="M9 18V5l12-2v13" stroke="var(--purple-muted)" fill="none" stroke-width="1"/><circle cx="6" cy="18" r="3" stroke="var(--purple-muted)" fill="none"/><circle cx="18" cy="16" r="3" stroke="var(--purple-muted)" fill="none"/></svg></div></div>`}
        <div class="album-play-overlay">
          <div class="album-play-btn"><svg viewBox="0 0 24 24"><polygon points="8 5 19 12 8 19 8 5"/></svg></div>
        </div>
      </div>
      <div class="album-info">
        <div class="album-name">${a.name || a.title || 'Unknown'}</div>
        <div class="album-artist">${a.artist || ''} ${a.songCount ? '&bull; ' + a.songCount + ' tracks' : ''}</div>
      </div>
    `;
    card.addEventListener('click', () => openAlbumDetail(a.id));
    container.appendChild(card);
  });
}

// ============ OPEN ALBUM DETAIL ============
async function openAlbumDetail(albumId) {
  pushNavState(() => openAlbumDetail(albumId), 'Album');
  const dc = document.getElementById('dynamicContent');
  dc.classList.add('content-fade-out');
  await new Promise(r => setTimeout(r, 150));

  try {
    const resp = await SUBSONIC.get('getAlbum', { id: albumId });
    const album = resp.album;
    const songs = (album.song || []).map(s => ({
      ...s,
      coverArt: s.coverArt || album.coverArt || albumId
    }));

    document.getElementById('contentTitle').textContent = album.name || 'Album';

    let html = `<div class="section-header"><div class="section-title">${album.artist || ''} &mdash; ${songs.length} tracks</div></div>`;
    html += `<div class="track-list-container"><div class="track-list-header">
      <span>#</span><span>TITLE</span><span>ALBUM</span><span>FORMAT</span><span>BITRATE</span><span style="text-align:right">TIME</span>
    </div><div id="trackList"></div></div>`;

    dc.innerHTML = html;
    dc.classList.remove('content-fade-out');
    dc.classList.add('content-fade-in');
    setTimeout(() => dc.classList.remove('content-fade-in'), 300);

    renderTrackList(songs, 'trackList');

    // Only set queue if nothing is currently playing
    if (!isPlaying) currentQueue = [...songs];
  } catch(e) {
    dc.innerHTML = '<div style="padding:28px;color:var(--purple-muted);">Failed to load album.</div>';
    dc.classList.remove('content-fade-out');
  }
}

// ============ LOAD PLAYLISTS INTO SIDEBAR ============
async function loadPlaylists() {
  try {
    const resp = await SUBSONIC.get('getPlaylists');
    allPlaylists = resp.playlists?.playlist || [];
    const container = document.getElementById('sidebarPlaylists');
    const colors = ['var(--purple-bright)','var(--purple-vivid)','var(--purple-core)','var(--purple-hot)','var(--purple-muted)'];
    container.innerHTML = allPlaylists.map((p, i) => `
      <div class="playlist-item" data-playlist-id="${p.id}">
        <div class="playlist-dot" style="background:${colors[i % colors.length]}"></div>
        <span class="playlist-name">${p.name}</span>
        <span class="playlist-count">${p.songCount || 0}</span>
      </div>
    `).join('');

    container.querySelectorAll('.playlist-item').forEach(item => {
      item.addEventListener('click', () => openPlaylist(item.dataset.playlistId));
    });
  } catch(e) {
    console.error('Failed to load playlists', e);
  }
}

// ============ OPEN PLAYLIST ============
async function openPlaylist(playlistId) {
  const dc = document.getElementById('dynamicContent');
  dc.classList.add('content-fade-out');
  await new Promise(r => setTimeout(r, 150));

  try {
    const resp = await SUBSONIC.get('getPlaylist', { id: playlistId });
    const pl = resp.playlist;
    const songs = pl.entry || [];

    document.getElementById('contentTitle').textContent = pl.name || 'Playlist';

    let html = `<div class="section-header"><div class="section-title">${songs.length} tracks &bull; ${fmtDur(pl.duration)}</div></div>`;
    html += `<div class="track-list-container"><div class="track-list-header">
      <span>#</span><span>TITLE</span><span>ALBUM</span><span>FORMAT</span><span>BITRATE</span><span style="text-align:right">TIME</span>
    </div><div id="trackList"></div></div>`;

    dc.innerHTML = html;
    dc.classList.remove('content-fade-out');
    dc.classList.add('content-fade-in');
    setTimeout(() => dc.classList.remove('content-fade-in'), 300);

    renderTrackList(songs, 'trackList');
  } catch(e) {
    dc.innerHTML = '<div style="padding:28px;color:var(--purple-muted);">Failed to load playlist.</div>';
    dc.classList.remove('content-fade-out');
  }
}

// ============ CONTEXT MENU ============
function showTrackContext(event, trackId, trackTitle) {
  event.preventDefault();
  const menu = document.getElementById('contextMenu');
  const playlistSubItems = allPlaylists.map(p =>
    `<div class="context-submenu-item" onclick="addToPlaylist('${p.id}','${trackId}','${trackTitle.replace(/'/g,"\\'")}');hideContextMenu()">${p.name}</div>`
  ).join('');

  menu.innerHTML = `
    <div class="context-menu-item" onclick="playTrackById('${trackId}');hideContextMenu()">
      <svg viewBox="0 0 24 24"><polygon points="6 3 20 12 6 21 6 3"/></svg> Play
    </div>
    <div class="context-menu-item" onclick="addToQueueById('${trackId}');hideContextMenu()">
      <svg viewBox="0 0 24 24"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/></svg> Add to Queue
    </div>
    <div class="context-menu-item">
      <svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg> Add to Playlist
      <div class="context-submenu">${playlistSubItems || '<div class="context-submenu-item" style="color:var(--purple-muted)">No playlists</div>'}</div>
    </div>
  `;

  menu.classList.add('visible');
  // Position with overflow prevention
  const menuRect = menu.getBoundingClientRect();
  let left = event.clientX;
  let top = event.clientY;
  if (left + menuRect.width > window.innerWidth) left = window.innerWidth - menuRect.width - 8;
  if (top + menuRect.height > window.innerHeight) top = window.innerHeight - menuRect.height - 8;
  if (left < 0) left = 8;
  if (top < 0) top = 8;
  menu.style.left = left + 'px';
  menu.style.top = top + 'px';
}

function hideContextMenu() {
  document.getElementById('contextMenu').classList.remove('visible');
}

document.addEventListener('click', hideContextMenu);

async function addToPlaylist(playlistId, trackId, trackTitle) {
  try {
    await SUBSONIC.get('updatePlaylist', { playlistId, songIdToAdd: trackId });
    showToast(`Added "${trackTitle}" to playlist`);
    loadPlaylists();
  } catch(e) { showToast('Failed to add to playlist'); }
}

function playTrackById(trackId) {
  // First check current queue
  const queueIdx = currentQueue.findIndex(t => t.id === trackId);
  if (queueIdx >= 0) {
    currentQueueIndex = queueIdx;
    playCurrentTrack();
    return;
  }
  // If not in queue, fetch the song and create a single-track queue
  SUBSONIC.get('getSong', { id: trackId }).then(resp => {
    const s = resp.song;
    if (s) {
      currentQueue.push(s);
      currentQueueIndex = currentQueue.length - 1;
      playCurrentTrack();
    }
  }).catch(() => showToast('Failed to play track'));
}

function addToQueueById(trackId) {
  const rows = document.querySelectorAll('#trackList .track-row');
  // Find track from current rendered list
  for (const t of currentQueue) {
    if (t.id === trackId) {
      currentQueue.push(t);
      renderQueueItems();
      showToast(`Added to queue`);
      return;
    }
  }
}

// ============ CREATE PLAYLIST ============
document.getElementById('createPlaylistBtn').addEventListener('click', () => {
  document.getElementById('createPlaylistModal').classList.add('open');
  document.getElementById('newPlaylistName').value = '';
  document.getElementById('newPlaylistName').focus();
});

document.getElementById('confirmCreatePlaylist').addEventListener('click', async () => {
  const name = document.getElementById('newPlaylistName').value.trim();
  if (!name) return;
  try {
    await SUBSONIC.get('createPlaylist', { name });
    showToast(`Created playlist "${name}"`);
    document.getElementById('createPlaylistModal').classList.remove('open');
    loadPlaylists();
  } catch(e) { showToast('Failed to create playlist'); }
});

document.getElementById('newPlaylistName').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') document.getElementById('confirmCreatePlaylist').click();
  if (e.key === 'Escape') document.getElementById('createPlaylistModal').classList.remove('open');
});

// ============ SEARCH ============
let searchTimeout = null;
document.getElementById('searchInput').addEventListener('input', (e) => {
  clearTimeout(searchTimeout);
  const q = e.target.value.trim();
  if (!q) { document.getElementById('searchResults').classList.remove('has-results'); return; }
  searchTimeout = setTimeout(async () => {
    try {
      const resp = await SUBSONIC.get('search3', { query: q, songCount: 10, albumCount: 6, artistCount: 4 });
      const r = resp.searchResult3 || {};
      const songs = r.song || [];
      const albums = r.album || [];
      const artists = r.artist || [];
      let html = '';
      if (artists.length) {
        html += `<div class="search-result-section"><div class="search-result-section-title">ARTISTS</div>`;
        artists.forEach(a => {
          html += `<div class="search-result-item" onclick="loadArtistAlbums('${a.id}','${(a.name||'').replace(/'/g,"\\'")}');document.getElementById('searchOverlay').classList.remove('open')">
            <div class="search-result-art">${a.coverArt ? `<img src="${SUBSONIC.coverUrl(a.coverArt, 80)}">` : ''}</div>
            <div class="search-result-info"><div class="search-result-title">${escHtml(a.name)}</div><div class="search-result-sub">${a.albumCount || 0} albums</div></div>
          </div>`;
        });
        html += '</div>';
      }
      if (albums.length) {
        html += `<div class="search-result-section"><div class="search-result-section-title">ALBUMS</div>`;
        albums.forEach(a => {
          html += `<div class="search-result-item" onclick="openAlbumDetail('${a.id}');document.getElementById('searchOverlay').classList.remove('open')">
            <div class="search-result-art">${a.coverArt ? `<img src="${SUBSONIC.coverUrl(a.coverArt, 80)}">` : ''}</div>
            <div class="search-result-info"><div class="search-result-title">${escHtml(a.name || a.title)}</div><div class="search-result-sub">${escHtml(a.artist) || ''}</div></div>
          </div>`;
        });
        html += '</div>';
      }
      if (songs.length) {
        html += `<div class="search-result-section"><div class="search-result-section-title">TRACKS</div>`;
        songs.forEach(s => {
          html += `<div class="search-result-item" onclick="searchPlaySong('${s.id}');document.getElementById('searchOverlay').classList.remove('open')">
            <div class="search-result-art">${s.coverArt ? `<img src="${SUBSONIC.coverUrl(s.coverArt, 80)}">` : ''}</div>
            <div class="search-result-info"><div class="search-result-title">${escHtml(s.title)}</div><div class="search-result-sub">${escHtml(s.artist) || ''} &mdash; ${escHtml(s.album) || ''}</div></div>
          </div>`;
        });
        html += '</div>';
      }
      const sr = document.getElementById('searchResults');
      sr.innerHTML = html || '<div style="padding:16px;text-align:center;color:var(--purple-muted);">No results</div>';
      sr.classList.add('has-results');
    } catch(e) { console.error('Search error', e); }
  }, 300);
});

function searchPlaySong(songId) {
  // Fetch song info and play it
  SUBSONIC.get('getSong', { id: songId }).then(resp => {
    const s = resp.song;
    if (s) {
      currentQueue = [s];
      currentQueueIndex = 0;
      playCurrentTrack();
    }
  }).catch(() => {});
}

// ============ VIEWS ============
async function loadLibraryView() {
  pushNavState(() => loadLibraryView(), 'Library');
  const dc = document.getElementById('dynamicContent');
  dc.classList.add('content-fade-out');
  await new Promise(r => setTimeout(r, 150));

  document.getElementById('contentTitle').textContent = 'Library';

  let html = '';

  // Recently Added section
  html += `<div class="section-header"><div class="section-title">Recently Added</div><div class="section-see-all" onclick="loadAlbumsView()">SEE ALL</div></div>`;
  html += `<div class="album-grid" id="recentAlbums" style="padding-bottom:10px;"></div>`;

  // Most Played section
  html += `<div class="section-header"><div class="section-title">Most Played</div></div>`;
  html += `<div class="album-grid" id="frequentAlbums" style="padding-bottom:10px;"></div>`;

  // Random picks
  html += `<div class="section-header"><div class="section-title">Discover</div></div>`;
  html += `<div class="album-grid" id="randomAlbums" style="padding-bottom:10px;"></div>`;

  // Track list
  html += `<div class="section-header"><div class="section-title">Random Tracks</div></div>`;
  html += `<div class="track-list-container"><div class="track-list-header">
    <span>#</span><span>TITLE</span><span>ALBUM</span><span>FORMAT</span><span>BITRATE</span><span style="text-align:right">TIME</span>
  </div><div id="trackList"></div></div>`;

  dc.innerHTML = html;
  dc.classList.remove('content-fade-out');
  dc.classList.add('content-fade-in');
  setTimeout(() => dc.classList.remove('content-fade-in'), 300);

  // Load data in parallel
  const [recentResp, frequentResp, randomResp, randomSongsResp] = await Promise.all([
    SUBSONIC.get('getAlbumList2', { type: 'newest', size: 30 }).catch(() => null),
    SUBSONIC.get('getAlbumList2', { type: 'frequent', size: 20 }).catch(() => null),
    SUBSONIC.get('getAlbumList2', { type: 'random', size: 50 }).catch(() => null),
    SUBSONIC.get('getRandomSongs', { size: 40 }).catch(() => null)
  ]);

  if (recentResp?.albumList2?.album) {
    renderAlbumCards(recentResp.albumList2.album, document.getElementById('recentAlbums'));
  }
  if (frequentResp?.albumList2?.album) {
    renderAlbumCards(frequentResp.albumList2.album, document.getElementById('frequentAlbums'));
  }
  if (randomResp?.albumList2?.album) {
    renderAlbumCards(randomResp.albumList2.album, document.getElementById('randomAlbums'));
  }
  if (randomSongsResp?.randomSongs?.song) {
    const songs = randomSongsResp.randomSongs.song;
    renderTrackList(songs, 'trackList');
    if (!isPlaying) currentQueue = [...songs];
  }
}

async function loadAlbumsView() {
  pushNavState(() => loadAlbumsView(), 'Albums');
  const dc = document.getElementById('dynamicContent');
  dc.classList.add('content-fade-out');
  await new Promise(r => setTimeout(r, 150));

  document.getElementById('contentTitle').textContent = 'Albums';
  dc.innerHTML = `<div class="album-grid bottom-pad" id="allAlbumsGrid"></div>`;
  dc.classList.remove('content-fade-out');
  dc.classList.add('content-fade-in');
  setTimeout(() => dc.classList.remove('content-fade-in'), 300);

  try {
    // Load all albums with pagination
    let allAlbums = [];
    let offset = 0;
    const pageSize = 500;
    while (true) {
      const resp = await SUBSONIC.get('getAlbumList2', { type: 'alphabeticalByName', size: pageSize, offset });
      const batch = resp?.albumList2?.album || [];
      allAlbums = allAlbums.concat(batch);
      if (batch.length < pageSize) break;
      offset += pageSize;
    }
    if (allAlbums.length) {
      renderAlbumCards(allAlbums, document.getElementById('allAlbumsGrid'), true);
    }
  } catch(e) { console.error('Albums load error', e); }
}

async function loadArtistsView() {
  pushNavState(() => loadArtistsView(), 'Artists');
  const dc = document.getElementById('dynamicContent');
  dc.classList.add('content-fade-out');
  await new Promise(r => setTimeout(r, 150));

  document.getElementById('contentTitle').textContent = 'Artists';
  dc.innerHTML = '<div id="artistsList" style="padding:10px 28px 120px;"></div>';
  dc.classList.remove('content-fade-out');
  dc.classList.add('content-fade-in');
  setTimeout(() => dc.classList.remove('content-fade-in'), 300);

  try {
    const resp = await SUBSONIC.get('getArtists');
    const indexes = resp?.artists?.index || [];
    const container = document.getElementById('artistsList');
    let html = '';
    indexes.forEach(idx => {
      (idx.artist || []).forEach((a, i) => {
        html += `<div class="track-row track-enter" style="animation-delay:${i*30}ms;grid-template-columns:40px 2fr 1fr 80px;" onclick="loadArtistAlbums('${a.id}','${(a.name||'').replace(/'/g,"\\'")}')">
          <div class="track-num">${a.name ? a.name[0] : '#'}</div>
          <div class="track-title-cell">
            <div class="track-art-small">${a.coverArt ? `<img src="${SUBSONIC.coverUrl(a.coverArt, 80)}" loading="lazy">` : ''}</div>
            <div class="track-title-text"><div class="track-title">${a.name}</div></div>
          </div>
          <div class="track-album">${a.albumCount || 0} albums</div>
          <div class="track-duration"></div>
        </div>`;
      });
    });
    container.innerHTML = html;
  } catch(e) { console.error('Artists load error', e); }
}

async function loadArtistAlbums(artistId, artistName) {
  const dc = document.getElementById('dynamicContent');
  dc.classList.add('content-fade-out');
  await new Promise(r => setTimeout(r, 150));

  document.getElementById('contentTitle').textContent = artistName;

  try {
    const resp = await SUBSONIC.get('getArtist', { id: artistId });
    const albums = resp?.artist?.album || [];
    dc.innerHTML = `<div class="album-grid bottom-pad" id="artistAlbumsGrid"></div>`;
    dc.classList.remove('content-fade-out');
    dc.classList.add('content-fade-in');
    setTimeout(() => dc.classList.remove('content-fade-in'), 300);
    renderAlbumCards(albums, document.getElementById('artistAlbumsGrid'), true);
  } catch(e) {
    dc.innerHTML = '<div style="padding:28px;color:var(--purple-muted);">Failed to load artist.</div>';
    dc.classList.remove('content-fade-out');
  }
}

// ============ SIDEBAR NAV ============
// ============ GENRES VIEW ============
async function loadGenresView() {
  pushNavState(() => loadGenresView(), 'Genres');
  const dc = document.getElementById('dynamicContent');
  dc.classList.add('content-fade-out');
  await new Promise(r => setTimeout(r, 150));

  document.getElementById('contentTitle').textContent = 'Genres';

  try {
    const resp = await SUBSONIC.get('getGenres');
    // Consolidate similar genres (e.g. "Hip-Hop" + "Hip" → "Hip-Hop")
    const GENRE_ALIASES = { 'hip': 'Hip-Hop', 'hiphop': 'Hip-Hop', 'hip hop': 'Hip-Hop', 'rap': 'Hip-Hop', 'rnb': 'R&B', 'r&b': 'R&B', 'rhythm and blues': 'R&B', 'electronica': 'Electronic', 'edm': 'Electronic', 'alt-rock': 'Alternative Rock', 'alt rock': 'Alternative Rock' };
    const rawGenres = (resp.genres?.genre || []).filter(g => g.songCount > 0);
    const merged = {};
    rawGenres.forEach(g => {
      const key = GENRE_ALIASES[(g.value || '').toLowerCase()] || g.value;
      if (!merged[key]) merged[key] = { value: key, songCount: 0, albumCount: 0, originals: [] };
      merged[key].songCount += g.songCount || 0;
      merged[key].albumCount += g.albumCount || 0;
      merged[key].originals.push(g.value);
    });
    const genres = Object.values(merged).sort((a, b) => b.songCount - a.songCount);

    let html = '<div style="display:flex;flex-wrap:wrap;gap:10px;padding:20px 0;">';
    genres.forEach((g, i) => {
      const hue = 260 + (i * 17) % 60;
      const sat = 50 + (i * 7) % 30;
      html += `<div class="genre-card" onclick="loadGenreDetail('${(g.value || '').replace(/'/g, "\\'")}')" style="
        background: linear-gradient(135deg, hsla(${hue},${sat}%,15%,0.6), hsla(${hue},${sat}%,8%,0.8));
        border: 1px solid hsla(${hue},${sat}%,40%,0.25);
        border-radius: 12px; padding: 20px 24px; cursor: pointer;
        transition: all 0.25s; position: relative; overflow: hidden;
        min-width: 140px; flex: 1 1 160px; max-width: 240px;
      ">
        <div style="font-family:var(--font-display);font-size:0.9rem;letter-spacing:0.06em;color:var(--purple-white);margin-bottom:6px;">${escHtml(g.value)}</div>
        <div style="font-family:var(--font-mono);font-size:0.65rem;color:var(--purple-bright);opacity:0.7;">${g.albumCount || 0} albums &middot; ${g.songCount || 0} tracks</div>
        <div style="position:absolute;top:-20px;right:-20px;width:80px;height:80px;border-radius:50%;background:hsla(${hue},${sat}%,50%,0.04);"></div>
      </div>`;
    });
    html += '</div>';

    if (genres.length === 0) {
      html = '<div style="text-align:center;padding:60px 20px;color:var(--purple-muted);font-family:var(--font-body);">No genres found in your library</div>';
    }

    dc.innerHTML = html;
  } catch(e) {
    console.error('Genres load error', e);
    dc.innerHTML = '<div style="text-align:center;padding:60px;color:var(--purple-bright);">Failed to load genres</div>';
  }

  dc.classList.remove('content-fade-out');
  dc.classList.add('content-fade-in');
  setTimeout(() => dc.classList.remove('content-fade-in'), 300);
}

async function loadGenreDetail(genreName) {
  pushNavState(() => loadGenreDetail(genreName), genreName);
  const dc = document.getElementById('dynamicContent');
  dc.classList.add('content-fade-out');
  await new Promise(r => setTimeout(r, 150));

  document.getElementById('contentTitle').textContent = genreName;

  // For merged genres, query each original genre name
  const GENRE_ALIASES = { 'hip': 'Hip-Hop', 'hiphop': 'Hip-Hop', 'hip hop': 'Hip-Hop', 'rap': 'Hip-Hop', 'rnb': 'R&B', 'r&b': 'R&B', 'rhythm and blues': 'R&B', 'electronica': 'Electronic', 'edm': 'Electronic', 'alt-rock': 'Alternative Rock', 'alt rock': 'Alternative Rock' };
  // Find all original genre names that map to this merged name
  const genreNames = [genreName];
  Object.entries(GENRE_ALIASES).forEach(([k, v]) => { if (v === genreName && !genreNames.includes(k)) genreNames.push(k); });

  try {
    // Load albums and songs for all genre variants
    const albumPromises = genreNames.map(g => SUBSONIC.get('getAlbumList2', { type: 'byGenre', genre: g, size: 500 }).catch(() => null));
    const songPromises = genreNames.map(g => SUBSONIC.get('getSongsByGenre', { genre: g, count: 500 }).catch(() => null));
    const albumResults = await Promise.all(albumPromises);
    const songResults = await Promise.all(songPromises);

    // Dedupe by ID
    const albumMap = {};
    albumResults.forEach(r => (r?.albumList2?.album || []).forEach(a => { albumMap[a.id] = a; }));
    const albums = Object.values(albumMap);

    const songMap = {};
    songResults.forEach(r => (r?.songsByGenre?.song || []).forEach(s => { songMap[s.id] = s; }));
    const songs = Object.values(songMap);

    let html = '';

    // Album cards section
    if (albums.length > 0) {
      html += '<div class="section-header"><div class="section-title">Albums</div><div style="font-family:var(--font-mono);font-size:0.65rem;color:var(--purple-muted);">' + albums.length + ' albums</div></div>';
      html += '<div class="album-grid" id="genreAlbumsGrid"></div>';
    }

    // Songs section
    if (songs.length > 0) {
      html += '<div class="section-header" style="margin-top:30px;"><div class="section-title">All Tracks</div><div style="font-family:var(--font-mono);font-size:0.65rem;color:var(--purple-muted);">' + songs.length + ' tracks</div></div>';
      html += '<div class="track-list-header"><span>#</span><span>TITLE</span><span>ALBUM</span><span>FORMAT</span><span style="text-align:right">TIME</span></div>';
      html += '<div id="genreTrackList" class="bottom-pad"></div>';
    }

    if (albums.length === 0 && songs.length === 0) {
      html = '<div style="text-align:center;padding:60px;color:var(--purple-muted);font-family:var(--font-body);">No music found for this genre</div>';
    }

    dc.innerHTML = html;

    // Render album cards
    if (albums.length > 0) {
      renderAlbumCards(albums, document.getElementById('genreAlbumsGrid'), true);
    }

    // Render track list
    if (songs.length > 0) {
      renderTrackList(songs, 'genreTrackList');
    }
  } catch(e) {
    console.error('Genre detail error', e);
    dc.innerHTML = '<div style="text-align:center;padding:60px;color:var(--purple-bright);">Failed to load genre</div>';
  }

  dc.classList.remove('content-fade-out');
  dc.classList.add('content-fade-in');
  setTimeout(() => dc.classList.remove('content-fade-in'), 300);
}

// ============ BINAURAL BEATS VIEW ============
async function loadBinauralView() {
  const dc = document.getElementById('dynamicContent');
  dc.classList.add('content-fade-out');
  await new Promise(r => setTimeout(r, 150));

  const presetsHTML = BINAURAL_PRESETS.map((p, i) =>
    `<div class="binaural-preset-btn" data-preset="${i}" onclick="applyBinauralPreset(${i})">
      <div class="binaural-preset-name">${escHtml(p.name)}</div>
      <div class="binaural-preset-info">${p.beat} Hz beat · ${p.base} Hz base</div>
      <div class="binaural-preset-info">${escHtml(p.purpose)}</div>
    </div>`
  ).join('');

  const rhythmPresetsHTML = RHYTHM_PRESETS.map((rp, i) =>
    `<div class="rhythm-preset-btn" onclick="applyRhythmPreset(${i})">
      <div class="rhythm-preset-name">${escHtml(rp.name)}</div>
      <div class="rhythm-preset-desc">${escHtml(rp.desc)} · ${rp.bpm} BPM</div>
    </div>`
  ).join('');

  dc.innerHTML = `
    <div class="binaural-view">
      <div style="text-align:center;margin-bottom:8px;">
        <div style="font-family:var(--font-display);font-size:1.8rem;font-weight:800;letter-spacing:4px;background:linear-gradient(135deg,var(--purple-vivid),var(--magenta-bright),var(--cyan-bright));-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-shadow:none;line-height:1.2;">RHYTHMIC BINAURAL</div>
        <div style="font-family:var(--font-display);font-size:1.1rem;font-weight:600;letter-spacing:6px;color:var(--cyan-bright);text-shadow:0 0 20px rgba(0,220,245,0.4);margin-top:2px;">BRAINWAVE LAYERING ENGINE</div>
        <div style="font-family:var(--font-mono);font-size:0.6rem;color:var(--purple-muted);letter-spacing:2px;margin-top:6px;">MULTI-LAYER NEURAL ENTRAINMENT SYSTEM</div>
      </div>
      <div class="binaural-headphone-note" style="text-align:center;">&#x1F3A7; Use headphones — each ear receives a different frequency to produce the binaural effect</div>

      <!-- ═══ SINGLE TONE MODE ═══ -->
      <div style="font-family:var(--font-display);font-size:0.8rem;color:var(--purple-hot);letter-spacing:2px;margin:20px 0 12px;border-bottom:1px solid var(--purple-dim);padding-bottom:6px;">SINGLE TONE</div>

      <div class="binaural-presets">${presetsHTML}</div>

      <div class="binaural-freq-display">
        <div class="binaural-freq-item">
          <div class="binaural-freq-label">Left Ear</div>
          <div class="binaural-freq-val" id="binauralFreqL">${binauralBaseFreq.toFixed(1)} Hz</div>
        </div>
        <div class="binaural-freq-item">
          <div class="binaural-freq-label">Beat Freq</div>
          <div class="binaural-freq-val" id="binauralFreqBeat">${binauralBeatFreq.toFixed(1)} Hz</div>
        </div>
        <div class="binaural-freq-item">
          <div class="binaural-freq-label">Right Ear</div>
          <div class="binaural-freq-val" id="binauralFreqR">${(binauralBaseFreq + binauralBeatFreq).toFixed(1)} Hz</div>
        </div>
      </div>

      <div class="binaural-controls">
        <div class="binaural-slider-group">
          <div class="binaural-slider-label">
            <span>Base Frequency</span>
            <span class="binaural-slider-value" id="binauralBaseVal">${binauralBaseFreq.toFixed(0)} Hz</span>
          </div>
          <input type="range" class="binaural-slider" id="binauralBaseSlider" min="100" max="500" step="1" value="${binauralBaseFreq}"
            oninput="binauralBaseFreq=+this.value; updateBinauralFreqs(binauralBaseFreq, binauralBeatFreq); clearActivePreset();">
        </div>
        <div class="binaural-slider-group">
          <div class="binaural-slider-label">
            <span>Beat Frequency</span>
            <span class="binaural-slider-value" id="binauralBeatVal">${binauralBeatFreq.toFixed(1)} Hz</span>
          </div>
          <input type="range" class="binaural-slider" id="binauralBeatSlider" min="1" max="50" step="0.5" value="${binauralBeatFreq}"
            oninput="binauralBeatFreq=+this.value; updateBinauralFreqs(binauralBaseFreq, binauralBeatFreq); clearActivePreset();">
        </div>
        <div class="binaural-slider-group">
          <div class="binaural-slider-label">
            <span>Volume</span>
            <span class="binaural-slider-value" id="binauralVolVal">${Math.round(binauralVolume * 100)}%</span>
          </div>
          <input type="range" class="binaural-slider" id="binauralVolSlider" min="0" max="1" step="0.01" value="${binauralVolume}"
            oninput="updateBinauralVolume(+this.value); document.getElementById('binauralVolVal').textContent=Math.round(this.value*100)+'%';">
        </div>
      </div>

      <div class="binaural-actions">
        <button class="binaural-play-btn ${binauralActive ? 'active' : ''}" id="binauralPlayBtn" onclick="if(binauralActive){stopBinaural();}else{startBinaural(binauralBaseFreq,binauralBeatFreq);}">
          ${binauralActive
            ? '<svg viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>STOP'
            : '<svg viewBox="0 0 24 24"><polygon points="5,3 19,12 5,21"/></svg>PLAY'}
        </button>
        <label class="binaural-mix-toggle">
          <input type="checkbox" id="binauralMixCheck" ${binauralMixWithMusic ? 'checked' : ''} onchange="toggleBinauralMix(this.checked);">
          Mix with music
        </label>
      </div>

      <div class="binaural-status ${binauralActive ? 'active' : ''}" id="binauralStatus">
        ${binauralActive
          ? 'Active — L: ' + binauralBaseFreq.toFixed(1) + ' Hz  R: ' + (binauralBaseFreq + binauralBeatFreq).toFixed(1) + ' Hz  Beat: ' + binauralBeatFreq.toFixed(1) + ' Hz'
          : 'Inactive — Select a preset or adjust sliders and press Play'}
      </div>

      <!-- ═══ RHYTHM LAYER ENGINE ═══ -->
      <div class="rhythm-section">
        <div class="rhythm-header">
          <h3>RHYTHM LAYERS</h3>
          <div style="font-family:var(--font-mono);font-size:0.6rem;color:var(--magenta-muted);">Stack brainwaves at different rhythmic divisions</div>
        </div>
        <div class="rhythm-subtitle">Layer multiple binaural frequencies pulsing at different rhythmic intervals — Delta on whole notes, Theta on quarters, Gamma on eighths — your brain, your patterns</div>

        <div class="rhythm-presets">${rhythmPresetsHTML}</div>

        <div class="rhythm-bpm-row">
          <div class="rhythm-bpm-label">BPM</div>
          <input type="range" class="binaural-slider rhythm-bpm-slider" id="rhythmBpmSlider" min="30" max="180" step="1" value="${rhythmBPM}"
            oninput="rhythmBPM=+this.value; document.getElementById('rhythmBpmVal').textContent=this.value+' BPM';">
          <div class="rhythm-bpm-val" id="rhythmBpmVal">${rhythmBPM} BPM</div>
        </div>

        <div class="rhythm-beat-viz">
          <div class="rhythm-beat-dot"></div>
          <div class="rhythm-beat-dot"></div>
          <div class="rhythm-beat-dot"></div>
          <div class="rhythm-beat-dot"></div>
        </div>

        <div class="rhythm-layers-container" id="rhythmLayersContainer"></div>

        <button class="rhythm-add-btn" onclick="addRhythmLayer()">+ Add Brainwave Layer</button>

        <div class="rhythm-actions">
          <button class="rhythm-play-btn ${rhythmActive ? 'active' : ''}" id="rhythmPlayBtn" onclick="if(rhythmActive){stopRhythm();}else{startRhythm();}">
            ${rhythmActive
              ? '<svg viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>STOP'
              : '<svg viewBox="0 0 24 24"><polygon points="5,3 19,12 5,21"/></svg>START'}
          </button>
          <label class="binaural-mix-toggle">
            <input type="checkbox" ${binauralMixWithMusic ? 'checked' : ''} onchange="toggleBinauralMix(this.checked);">
            Mix with music
          </label>
        </div>
      </div>
    </div>`;

  renderRhythmLayers();
  if (rhythmActive) startRhythmBeatViz();

  dc.classList.remove('content-fade-out');
  dc.classList.add('content-fade-in');
  setTimeout(() => dc.classList.remove('content-fade-in'), 300);
}

function applyBinauralPreset(index) {
  const p = BINAURAL_PRESETS[index];
  binauralBaseFreq = p.base;
  binauralBeatFreq = p.beat;
  // Update sliders
  const baseSlider = document.getElementById('binauralBaseSlider');
  const beatSlider = document.getElementById('binauralBeatSlider');
  if (baseSlider) baseSlider.value = p.base;
  if (beatSlider) beatSlider.value = p.beat;
  // Highlight active preset
  document.querySelectorAll('.binaural-preset-btn').forEach((btn, i) => {
    btn.classList.toggle('active', i === index);
  });
  // If already playing, update live
  if (binauralActive) {
    updateBinauralFreqs(p.base, p.beat);
  } else {
    startBinaural(p.base, p.beat);
  }
  updateBinauralUI();
}

function clearActivePreset() {
  document.querySelectorAll('.binaural-preset-btn').forEach(btn => btn.classList.remove('active'));
}

document.querySelectorAll('.nav-item[data-view]').forEach(item => {
  item.addEventListener('click', () => {
    document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
    item.classList.add('active');
    const view = item.dataset.view;
    currentView = view;
    // Show/hide view toggles and filter based on view
    if (view === 'library') loadLibraryView();
    else if (view === 'albums') loadAlbumsView();
    else if (view === 'artists') loadArtistsView();
    else if (view === 'genres') loadGenresView();
    else if (view === 'binaural') loadBinauralView();
  });
});

// ============ VIEW TOGGLES ============
document.querySelectorAll('.view-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const mode = btn.dataset.mode;
    if (mode === 'grid' && currentView === 'library') {
      loadAlbumsView();
    } else if (mode === 'list' && currentView === 'library') {
      loadLibraryView();
    }
  });
});

// ============ SIDEBAR TOGGLE ============
document.getElementById('sidebarToggle').addEventListener('click', () => {
  document.getElementById('appShell').classList.toggle('sidebar-expanded');
});

// ============ SEARCH OVERLAY ============
const searchOverlay = document.getElementById('searchOverlay');
document.querySelector('[data-action="search"]').addEventListener('click', () => {
  searchOverlay.classList.add('open');
  document.getElementById('searchInput').focus();
});
searchOverlay.addEventListener('click', (e) => {
  if (e.target === searchOverlay) searchOverlay.classList.remove('open');
});
// Keyboard shortcuts are registered in the unified handler below

// ============ QUEUE PANEL ============
document.querySelector('[data-action="queue"]').addEventListener('click', () => {
  document.getElementById('queuePanel').classList.toggle('open');
});
document.getElementById('queueClose').addEventListener('click', () => {
  document.getElementById('queuePanel').classList.remove('open');
});

// ============ EQUALIZER PANEL ============
document.getElementById('eqToggleBtn').addEventListener('click', toggleEqPanel);
document.getElementById('eqClose').addEventListener('click', () => {
  document.getElementById('eqPanel').classList.remove('open');
  document.getElementById('eqToggleBtn').classList.remove('active');
});

// ============ SETTINGS PANEL ============
document.querySelector('[data-action="settings"]').addEventListener('click', () => {
  const overlay = document.getElementById('settingsOverlay');
  overlay.classList.add('open');
  // Populate scene buttons
  const container = document.getElementById('sceneButtons');
  container.innerHTML = SCENES.map((s, i) =>
    `<button onclick="switchScene(${i});this.parentElement.querySelectorAll('button').forEach(b=>b.style.borderColor='var(--purple-dim)');this.style.borderColor='var(--cyan-bright)'" style="background:var(--bg-raised);border:1px solid ${i === currentScene ? 'var(--cyan-bright)' : 'var(--purple-dim)'};border-radius:6px;color:var(--purple-hot);font-family:var(--font-mono);font-size:0.7rem;padding:6px 12px;cursor:pointer;transition:all 0.2s;">${s}</button>`
  ).join('');
  // Update about
  SUBSONIC.get('ping').then(r => {
    document.getElementById('settAbout').innerHTML = `AETHER v1.0.0<br>Navidrome: ${r.status === 'ok' ? 'connected' : 'failed'} — ${r.serverVersion || 'unknown'}<br>`;
  });
});

document.getElementById('settingsOverlay').addEventListener('click', (e) => {
  if (e.target === document.getElementById('settingsOverlay')) {
    document.getElementById('settingsOverlay').classList.remove('open');
  }
});

// Auto-rotate
document.getElementById('settAutoRotate').addEventListener('change', (e) => {
  vizAutoRotate = e.target.checked;
  clearInterval(vizAutoRotateTimer);
  if (vizAutoRotate) {
    vizAutoRotateTimer = setInterval(() => switchScene(), vizAutoRotateInterval);
  }
});
document.getElementById('settRotateInterval').addEventListener('change', (e) => {
  vizAutoRotateInterval = parseInt(e.target.value);
  if (vizAutoRotate) {
    clearInterval(vizAutoRotateTimer);
    vizAutoRotateTimer = setInterval(() => switchScene(), vizAutoRotateInterval);
  }
});

// Apply settings from inputs to SUBSONIC object + save to localStorage
function applySettings() {
  const url = document.getElementById('settUrl').value.trim();
  const user = document.getElementById('settUser').value.trim();
  const pass = document.getElementById('settPass').value;
  if (url) SUBSONIC.baseUrl = url.replace(/\/+$/, '');
  if (user) SUBSONIC.user = user;
  if (pass) SUBSONIC.password = pass;
  // Persist
  localStorage.setItem('aether_settings', JSON.stringify({
    baseUrl: SUBSONIC.baseUrl,
    user: SUBSONIC.user,
    password: SUBSONIC.password,
    vizAutoRotate,
    vizAutoRotateInterval,
    volume: audio.volume
  }));
}

// Load settings from localStorage on startup
(function loadSavedSettings() {
  try {
    const saved = JSON.parse(localStorage.getItem('aether_settings'));
    if (saved) {
      if (saved.baseUrl) SUBSONIC.baseUrl = saved.baseUrl;
      if (saved.user) SUBSONIC.user = saved.user;
      if (saved.password) SUBSONIC.password = saved.password;
      if (saved.volume !== undefined) audio.volume = saved.volume;
      if (saved.vizAutoRotate) {
        vizAutoRotate = saved.vizAutoRotate;
        const chk = document.getElementById('settAutoRotate');
        if (chk) chk.checked = vizAutoRotate;
      }
      if (saved.vizAutoRotateInterval) vizAutoRotateInterval = saved.vizAutoRotateInterval;
      // Populate inputs
      const urlEl = document.getElementById('settUrl');
      const userEl = document.getElementById('settUser');
      const passEl = document.getElementById('settPass');
      if (urlEl) urlEl.value = SUBSONIC.baseUrl;
      if (userEl) userEl.value = SUBSONIC.user;
      if (passEl) passEl.value = SUBSONIC.password;
    }
  } catch(e) { console.warn('Settings load failed:', e); }
})();

// Test connection — also applies settings first
document.getElementById('settTestConn').addEventListener('click', async () => {
  const btn = document.getElementById('settTestConn');
  btn.textContent = 'TESTING...';
  applySettings();
  try {
    const resp = await SUBSONIC.get('ping');
    btn.textContent = resp.status === 'ok' ? 'CONNECTED & SAVED' : 'FAILED';
    btn.style.borderColor = resp.status === 'ok' ? 'var(--cyan-bright)' : '#ff4466';
    if (resp.status === 'ok') showToast('Settings saved & connected!');
  } catch(e) {
    btn.textContent = 'FAILED';
    btn.style.borderColor = '#ff4466';
  }
  setTimeout(() => { btn.textContent = 'TEST CONNECTION'; btn.style.borderColor = ''; }, 3000);
});

// ============ ELECTRIC SHEEP STATE & SETTINGS ============
let sheepVideos = [];
let sheepVideoIdx = 0;
let sheepFolder = '';

function updateSheepStatus() {
  const el = document.getElementById('settSheepStatus');
  if (!el) return;
  if (sheepVideos.length === 0) {
    el.textContent = 'No videos loaded';
    el.style.color = 'var(--purple-muted)';
  } else {
    el.textContent = `${sheepVideos.length} video${sheepVideos.length === 1 ? '' : 's'} loaded` + (sheepFolder ? ` from ${sheepFolder}` : '');
    el.style.color = 'var(--purple-bright)';
  }
}

async function scanSheepFolder(folderPath) {
  if (!folderPath) return;
  sheepFolder = folderPath;
  if (window.electronAPI && window.electronAPI.scanSheepFolder) {
    const files = await window.electronAPI.scanSheepFolder(folderPath);
    sheepVideos = (files || []).map(f => 'file:///' + encodeURI(f).replace(/#/g, '%23'));
    showToast(`Electric Sheep: ${sheepVideos.length} video${sheepVideos.length === 1 ? '' : 's'} loaded`);
  } else {
    showToast('Electric Sheep: folder scan not available');
  }
  // Persist
  localStorage.setItem('aether_sheep_folder', folderPath);
  updateSheepStatus();
}

document.getElementById('settSheepBrowse').addEventListener('click', async () => {
  if (window.electronAPI && window.electronAPI.openFolderDialog) {
    const folder = await window.electronAPI.openFolderDialog('Select Electric Sheep Video Folder');
    if (folder) {
      document.getElementById('settSheepFolder').value = folder;
      scanSheepFolder(folder);
    }
  } else {
    showToast('Folder picker requires Electron');
  }
});

document.getElementById('settSheepScan').addEventListener('click', () => {
  const folder = document.getElementById('settSheepFolder').value.trim();
  if (!folder) { showToast('Enter a folder path first'); return; }
  scanSheepFolder(folder);
});

document.getElementById('settSheepAddFiles').addEventListener('click', async () => {
  if (window.electronAPI && window.electronAPI.openFilesDialog) {
    const files = await window.electronAPI.openFilesDialog('Select Video Files', ['mp4', 'webm', 'mkv', 'avi', 'mov', 'm4v']);
    if (files && files.length > 0) {
      files.forEach(f => {
        sheepVideos.push('file:///' + encodeURI(f.replace(/\\/g, '/')).replace(/#/g, '%23'));
      });
      showToast(`Electric Sheep: added ${files.length} video${files.length === 1 ? '' : 's'}`);
      updateSheepStatus();
    }
  } else {
    showToast('File picker requires Electron');
  }
});

document.getElementById('settSheepClear').addEventListener('click', () => {
  sheepVideos = [];
  sheepVideoIdx = 0;
  sheepFolder = '';
  document.getElementById('settSheepFolder').value = '';
  localStorage.removeItem('aether_sheep_folder');
  const sv = document.getElementById('sheepVideo');
  sv.pause();
  sv.removeAttribute('src');
  showToast('Electric Sheep: videos cleared');
  updateSheepStatus();
});

// Load saved sheep folder on startup
(function loadSheepSettings() {
  const saved = localStorage.getItem('aether_sheep_folder');
  if (saved) {
    document.getElementById('settSheepFolder').value = saved;
    sheepFolder = saved;
  }
})();

// ============ FILTER ============
document.getElementById('filterInput').addEventListener('input', (e) => {
  const q = e.target.value.toLowerCase().trim();

  // Filter track list
  const trackList = document.getElementById('trackList');
  if (trackList && currentQueue.length) {
    renderTrackList(currentQueue, 'trackList', e.target.value);
    return;
  }

  // Filter artist list
  const artistsList = document.getElementById('artistsList');
  if (artistsList) {
    const rows = artistsList.querySelectorAll('.track-row');
    rows.forEach(row => {
      const name = (row.querySelector('.track-title')?.textContent || '').toLowerCase();
      row.style.display = !q || name.includes(q) ? '' : 'none';
    });
    return;
  }

  // Filter album grid
  const albumGrid = document.querySelector('.album-grid');
  if (albumGrid) {
    const cards = albumGrid.querySelectorAll('.album-card');
    cards.forEach(card => {
      const title = (card.querySelector('.album-title')?.textContent || '').toLowerCase();
      const artist = (card.querySelector('.album-artist')?.textContent || '').toLowerCase();
      card.style.display = !q || title.includes(q) || artist.includes(q) ? '' : 'none';
    });
    return;
  }

  // Filter genre cards
  const genreGrid = document.getElementById('genreGrid');
  if (genreGrid) {
    const cards = genreGrid.querySelectorAll('.genre-card');
    cards.forEach(card => {
      const name = (card.textContent || '').toLowerCase();
      card.style.display = !q || name.includes(q) ? '' : 'none';
    });
  }
});

// ============ KEYBOARD SHORTCUTS ============
document.addEventListener('keydown', (e) => {
  // Don't trigger shortcuts when typing in inputs
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
    if (e.key === 'Escape') {
      e.target.blur();
      document.getElementById('searchOverlay').classList.remove('open');
      document.getElementById('settingsOverlay').classList.remove('open');
      document.getElementById('createPlaylistModal').classList.remove('open');
    }
    return;
  }

  // Ctrl combos
  if (e.ctrlKey || e.metaKey) {
    if (e.key === 'k') { e.preventDefault(); document.getElementById('searchOverlay').classList.toggle('open'); if (document.getElementById('searchOverlay').classList.contains('open')) document.getElementById('searchInput').focus(); }
    if (e.key === ',') { e.preventDefault(); document.getElementById('settingsOverlay').classList.add('open'); }
    if (e.key === 'ArrowRight') { e.preventDefault(); document.getElementById('btnNext').click(); }
    if (e.key === 'ArrowLeft') { e.preventDefault(); document.getElementById('btnPrev').click(); }
    return;
  }

  switch(e.code) {
    case 'Space': e.preventDefault(); document.getElementById('btnPlay').click(); break;
    case 'KeyV': switchScene(); break;
    case 'KeyF': document.querySelector('.viz-expand').click(); break;
    case 'KeyM': document.getElementById('btnMute').click(); break;
    case 'KeyS': document.getElementById('btnShuffle').click(); break;
    case 'KeyR': document.getElementById('btnRepeat').click(); break;
    case 'KeyQ': document.getElementById('queuePanel').classList.toggle('open'); break;
    case 'ArrowLeft': if (audio.duration) { audio.currentTime = Math.max(0, audio.currentTime - 5); } break;
    case 'ArrowRight': if (audio.duration) { audio.currentTime = Math.min(audio.duration, audio.currentTime + 5); } break;
    case 'ArrowUp': e.preventDefault(); audio.volume = Math.min(1, audio.volume + 0.05); document.getElementById('volumeSlider').value = audio.volume * 100; break;
    case 'ArrowDown': e.preventDefault(); audio.volume = Math.max(0, audio.volume - 0.05); document.getElementById('volumeSlider').value = audio.volume * 100; break;
    case 'KeyN':
      // Cycle to next sheep video when on Electric Sheep scene
      if (currentScene === 10 && sheepVideos.length > 0) {
        const sv = document.getElementById('sheepVideo');
        sheepVideoIdx = (sheepVideoIdx + 1) % sheepVideos.length;
        sv.src = sheepVideos[sheepVideoIdx];
        sv.play().catch(() => {});
        showToast(`Sheep: ${sheepVideoIdx + 1} / ${sheepVideos.length}`);
      }
      break;
    case 'KeyP':
      // Cycle to previous sheep video when on Electric Sheep scene
      if (currentScene === 10 && sheepVideos.length > 0) {
        const sv = document.getElementById('sheepVideo');
        sheepVideoIdx = (sheepVideoIdx - 1 + sheepVideos.length) % sheepVideos.length;
        sv.src = sheepVideos[sheepVideoIdx];
        sv.play().catch(() => {});
        showToast(`Sheep: ${sheepVideoIdx + 1} / ${sheepVideos.length}`);
      }
      break;
    case 'Digit1': switchScene(0); break;
    case 'Digit2': switchScene(1); break;
    case 'Digit3': switchScene(2); break;
    case 'Digit4': switchScene(3); break;
    case 'Escape':
      document.getElementById('searchOverlay').classList.remove('open');
      document.getElementById('settingsOverlay').classList.remove('open');
      document.getElementById('createPlaylistModal').classList.remove('open');
      if (vizFullscreen) document.querySelector('.viz-expand').click();
      hideContextMenu();
      break;
  }
});

// ============ VISUALIZER CANVAS ============
const vizCanvas = document.getElementById('vizCanvas');
const vizCtx = vizCanvas.getContext('2d');
let vizRings = [];
let vizW, vizH;

// Fractal Flame state (Electric Sheep style with density buffer)
let flameDensityBuffer = null;  // Float32Array: [r, g, b, hitCount] per pixel
let flameWidth = 0;
let flameHeight = 0;
let flameImageData = null;
let flameSystems = null;        // Multiple IFS systems running simultaneously
let flameBeatAccum = 0;
let flamePaletteOffset = 0;
let flameInitialized = false;

// Neural Web state
let neuralNodes = null;
let neuralSignals = [];
let neuralBeatCooldown = 0;

// Aurora Borealis state
let auroraStars = null;

// DNA Helix state
let dnaParticles = null;
let dnaBeatPulse = 0;
let dnaCameraAngle = 0;

// Cosmic Mandala state
let mandalaParticles = null;
let mandalaBeatPulse = 0;

// Load Electric Sheep videos from a folder
async function loadSheepVideos(folderPath) {
  sheepFolder = folderPath;
  if (window.electronAPI && window.electronAPI.scanSheepFolder) {
    try {
      const files = await window.electronAPI.scanSheepFolder(folderPath);
      sheepVideos = (files || []).map(f => 'file:///' + encodeURI(f).replace(/#/g, '%23'));
      showToast(`Electric Sheep: loaded ${sheepVideos.length} videos`);
    } catch(e) {
      console.error('Electric Sheep scan failed:', e);
      showToast('Electric Sheep: folder scan failed');
    }
  } else {
    showToast('Electric Sheep: use Settings to set video folder path');
  }
}

// Manual method: add sheep video files
function addSheepVideo(filePath) {
  sheepVideos.push('file:///' + encodeURI(filePath.replace(/\\/g, '/')).replace(/#/g, '%23'));
}

// Electric Sheep overlay — audio-reactive effects drawn on top of the video
function drawElectricSheepOverlay(ctx, w, h, time) {
  const sv = document.getElementById('sheepVideo');

  // If no videos loaded, show instructions + our own generative background
  if (sheepVideos.length === 0) {
    // Draw a mesmerizing generative background as placeholder
    ctx.fillStyle = 'rgba(0,0,0,0.03)';
    ctx.fillRect(0, 0, w, h);

    // Fractal-like noise pattern as placeholder
    const cx = w / 2, cy = h / 2;
    ctx.globalCompositeOperation = 'lighter';
    for (let i = 0; i < 200; i++) {
      const angle = (time * 0.0001 + i * 0.031415) % (Math.PI * 2);
      const r = 30 + i * 1.5 + Math.sin(time * 0.0005 + i * 0.1) * 40 + bands.bass * 60;
      const x = cx + Math.cos(angle * (1 + Math.sin(i * 0.01) * 0.5)) * r;
      const y = cy + Math.sin(angle * (1 + Math.cos(i * 0.013) * 0.5)) * r;
      const s = 1 + Math.sin(time * 0.002 + i) * 0.5 + beatIntensity * 2;
      const hueShift = (i / 200 + time * 0.00005) % 1;
      let pr, pg, pb;
      if (hueShift < 0.33) {
        pr = 157; pg = 78; pb = 221; // purple
      } else if (hueShift < 0.66) {
        pr = 255; pg = 45; pb = 123; // magenta
      } else {
        pr = 0; pg = 220; pb = 245; // cyan
      }
      const a = 0.15 + bands.energy * 0.4 + beatIntensity * 0.3;
      ctx.beginPath();
      ctx.arc(x, y, s, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${pr},${pg},${pb},${a * 0.3})`;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x, y, s * 4, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${pr},${pg},${pb},${a * 0.05})`;
      ctx.fill();
    }
    ctx.globalCompositeOperation = 'source-over';

    // Instruction text
    ctx.font = '600 0.9rem Orbitron';
    ctx.fillStyle = `rgba(238,212,255,${0.5 + Math.sin(time * 0.002) * 0.2})`;
    ctx.textAlign = 'center';
    ctx.fillText('ELECTRIC SHEEP', cx, cy - 30);
    ctx.font = '0.6rem "JetBrains Mono"';
    ctx.fillStyle = 'rgba(183,110,255,0.6)';
    ctx.fillText('No fractal videos loaded', cx, cy + 5);
    ctx.font = '0.5rem "JetBrains Mono"';
    ctx.fillStyle = 'rgba(157,78,221,0.45)';
    ctx.fillText('DRAG & DROP video files here', cx, cy + 30);
    ctx.fillText('or open Settings → Electric Sheep to browse', cx, cy + 48);
    ctx.fillText('Supports: MP4, WebM, MKV, AVI, MOV', cx, cy + 70);
    ctx.textAlign = 'start';
    return;
  }

  // Video is playing — draw audio-reactive overlay on top
  // Cycle to next video when current ends
  if (sv.ended || (sv.paused && sv.readyState < 3)) {
    sheepVideoIdx = (sheepVideoIdx + 1) % sheepVideos.length;
    sv.src = sheepVideos[sheepVideoIdx];
    sv.play().catch(e => console.warn('Sheep play error:', e.message, sv.src));
  }

  // ═══ AUDIO-REACTIVE VIDEO MANIPULATION ═══
  // Modulate playback speed with energy (0.7x → 1.6x)
  const targetSpeed = 0.7 + bands.energy * 0.6 + beatIntensity * 0.3;
  sv.playbackRate = sv.playbackRate + (targetSpeed - sv.playbackRate) * 0.1;

  // Apply CSS filters to video element for audio-reactive color/brightness
  const hueShift = Math.sin(time * 0.0003) * 30 + bands.mid * 60;
  const brightness = 0.85 + bands.energy * 0.5 + beatIntensity * 0.4;
  const contrast = 1.0 + bands.bass * 0.3 + beatIntensity * 0.2;
  const saturate = 1.0 + bands.energy * 0.8 + beatIntensity * 0.5;
  sv.style.filter = `hue-rotate(${hueShift}deg) brightness(${brightness}) contrast(${contrast}) saturate(${saturate})`;

  // Audio-reactive zoom via CSS transform (subtle pulse on beat)
  const zoom = 1.0 + beatIntensity * 0.04 + bands.bass * 0.02;
  sv.style.transform = `scale(${zoom})`;

  // ═══ CANVAS OVERLAY EFFECTS ═══
  // Draw the video frame to canvas with blend for extra reactivity
  if (sv.readyState >= 2) {
    ctx.save();
    ctx.globalAlpha = 0.08 + beatIntensity * 0.12;
    ctx.globalCompositeOperation = 'screen';
    ctx.drawImage(sv, 0, 0, w, h);
    ctx.restore();
  }

  ctx.globalCompositeOperation = 'lighter';

  // Beat flash — full screen color wash
  if (beatIntensity > 0.25) {
    const flashAlpha = beatIntensity * 0.2;
    // Alternate flash colors based on beat frequency
    const flashHue = (time * 0.001) % 3;
    if (flashHue < 1) ctx.fillStyle = `rgba(255, 45, 123, ${flashAlpha})`;
    else if (flashHue < 2) ctx.fillStyle = `rgba(0, 220, 245, ${flashAlpha * 0.7})`;
    else ctx.fillStyle = `rgba(183, 110, 255, ${flashAlpha * 0.8})`;
    ctx.fillRect(0, 0, w, h);
  }

  // Energy vignette glow — breathes with bass
  const vigR = Math.min(w, h) * (0.7 + bands.bass * 0.2);
  const vigGrad = ctx.createRadialGradient(w/2, h/2, vigR * 0.2, w/2, h/2, vigR);
  vigGrad.addColorStop(0, 'transparent');
  vigGrad.addColorStop(0.7, `rgba(123, 47, 190, ${0.03 + bands.energy * 0.1})`);
  vigGrad.addColorStop(1, `rgba(157, 78, 221, ${0.08 + bands.energy * 0.2})`);
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, w, h);

  // Pulse rings from center on beat — expanding outward
  if (beatIntensity > 0.15) {
    for (let ring = 0; ring < 3; ring++) {
      const decay = Math.max(0, beatIntensity - ring * 0.15);
      if (decay <= 0) break;
      const ringR = 20 + (1 - decay) * Math.min(w, h) * 0.5 + ring * 30;
      ctx.beginPath();
      ctx.arc(w/2, h/2, ringR, 0, Math.PI * 2);
      ctx.strokeStyle = ring === 0
        ? `rgba(0, 220, 245, ${decay * 0.4})`
        : `rgba(183, 110, 255, ${decay * 0.2})`;
      ctx.lineWidth = (3 - ring) + decay * 4;
      ctx.stroke();
    }
  }

  // Floating energy particles on high energy
  if (bands.energy > 0.3) {
    const particleCount = Math.floor(bands.energy * 20 + beatIntensity * 15);
    for (let i = 0; i < particleCount; i++) {
      const angle = (time * 0.0002 + i * 1.618) % (Math.PI * 2);
      const dist = 50 + Math.sin(time * 0.001 + i * 0.5) * Math.min(w, h) * 0.3;
      const px = w/2 + Math.cos(angle) * dist;
      const py = h/2 + Math.sin(angle) * dist * 0.6;
      const size = 1 + bands.energy * 3 + beatIntensity * 2;
      const alpha = 0.2 + beatIntensity * 0.4;
      ctx.beginPath();
      ctx.arc(px, py, size, 0, Math.PI * 2);
      ctx.fillStyle = i % 3 === 0
        ? `rgba(0, 220, 245, ${alpha})`
        : i % 3 === 1
        ? `rgba(255, 45, 123, ${alpha * 0.7})`
        : `rgba(183, 110, 255, ${alpha * 0.8})`;
      ctx.fill();
    }
  }

  // Bass waveform scanner line
  const scanY = h * 0.5 + Math.sin(time * 0.001) * h * 0.3;
  ctx.beginPath();
  ctx.moveTo(0, scanY);
  for (let x = 0; x < w; x += 4) {
    const idx = Math.floor((x / w) * (freqData?.length || 128));
    const amp = (freqData ? freqData[idx] / 255 : 0) * 30 * bands.energy;
    ctx.lineTo(x, scanY + Math.sin(x * 0.02 + time * 0.003) * amp);
  }
  ctx.strokeStyle = `rgba(0, 220, 245, ${0.1 + bands.energy * 0.15})`;
  ctx.lineWidth = 1;
  ctx.stroke();

  ctx.globalCompositeOperation = 'source-over';

  // Bottom frequency bars (subtle overlay)
  if (freqData) {
    const barCount = 64;
    const barW = w / barCount;
    for (let i = 0; i < barCount; i++) {
      const val = (freqData[Math.floor(i / barCount * 128)] || 0) / 255;
      const barH = val * h * 0.15;
      const t = i / barCount;
      const r = Math.round(157 * (1 - t) + 255 * t * 0.5);
      const g = Math.round(78 * (1 - t) + 45 * t);
      const b = Math.round(221 * (1 - t) + 245 * t);
      ctx.fillStyle = `rgba(${r},${g},${b},${val * 0.2})`;
      ctx.fillRect(i * barW, h - barH, barW - 1, barH);
    }
  }
}

function vizResize() {
  const rect = vizCanvas.parentElement.getBoundingClientRect();
  vizW = vizCanvas.width = rect.width;
  vizH = vizCanvas.height = rect.height;
}
vizResize();
window.addEventListener('resize', vizResize);

let lastRingSpawn = 0;
let lastFallbackSpawn = 0;
function trySpawnRing(now) {
  const minInterval = 120;
  const fallbackInterval = 800;
  if (now - lastRingSpawn < minInterval) return;
  const shouldSpawn = (beatIntensity > 0.15) || (bands.energy > 0.3) || (now - lastFallbackSpawn > fallbackInterval);
  if (shouldSpawn) {
    vizRings.push({ x:vizW/2, y:vizH/2, r:10 + bands.bass * 50, alpha:1, speed:1.5+Math.random()*3, width:1.5 + bands.energy * 5 });
    if (vizRings.length > 30) vizRings.shift();
    lastRingSpawn = now;
    if (now - lastFallbackSpawn > fallbackInterval) lastFallbackSpawn = now;
  }
}

// ============ FRACTAL FLAME (Electric Sheep inspired — density buffer + log mapping) ============

// Color palette: deep purple, bright purple, vivid purple, magenta, soft magenta, cyan, hot pink
const flamePalette = [
  [123, 47, 190],   // deep purple
  [157, 78, 221],   // bright purple
  [183, 110, 255],  // vivid purple
  [255, 45, 123],   // magenta
  [255, 107, 168],  // soft magenta
  [0, 220, 245],    // cyan
  [212, 20, 122],   // hot pink
  [157, 78, 221],   // bright purple (wrap back)
];

function flamePaletteColor(t) {
  // t in [0,1], interpolate through palette
  const tt = ((t % 1) + 1) % 1;
  const idx = tt * (flamePalette.length - 1);
  const i0 = Math.floor(idx);
  const i1 = Math.min(i0 + 1, flamePalette.length - 1);
  const f = idx - i0;
  return [
    flamePalette[i0][0] * (1 - f) + flamePalette[i1][0] * f,
    flamePalette[i0][1] * (1 - f) + flamePalette[i1][1] * f,
    flamePalette[i0][2] * (1 - f) + flamePalette[i1][2] * f
  ];
}

// Nonlinear variations (classic fractal flame variations)
function flameVariation(varType, x, y, swirlAmt) {
  const r2 = x * x + y * y;
  const r = Math.sqrt(r2) + 1e-10;
  const theta = Math.atan2(y, x);
  switch (varType) {
    case 0: // sinusoidal
      return [Math.sin(x), Math.sin(y)];
    case 1: { // swirl
      const sw = swirlAmt * 4 + 1.5;
      const sr = Math.sin(r2 * sw);
      const cr = Math.cos(r2 * sw);
      return [x * sr - y * cr, x * cr + y * sr];
    }
    case 2: // horseshoe
      return [(x - y) * (x + y) / r, 2 * x * y / r];
    case 3: // polar
      return [theta / Math.PI, r - 1];
    case 4: // handkerchief
      return [r * Math.sin(theta + r), r * Math.cos(theta - r)];
    case 5: // spiral
      return [(Math.cos(theta) + Math.sin(r)) / r, (Math.sin(theta) - Math.cos(r)) / r];
    case 6: // hyperbolic
      return [Math.sin(theta) / r, r * Math.cos(theta)];
    case 7: // diamond
      return [Math.sin(theta) * Math.cos(r), Math.cos(theta) * Math.sin(r)];
    case 8: { // ex
      const p0 = Math.sin(theta + r);
      const p1 = Math.cos(theta - r);
      return [r * (p0 * p0 * p0 + p1 * p1 * p1), r * (p0 * p0 * p0 - p1 * p1 * p1)];
    }
    case 9: { // julia
      const sqr = Math.sqrt(r);
      const omega = Math.random() < 0.5 ? 0 : Math.PI;
      return [sqr * Math.cos(theta / 2 + omega), sqr * Math.sin(theta / 2 + omega)];
    }
    default:
      return [x, y];
  }
}

// Generate transforms for a single IFS flame system
function createFlameSystem(seed) {
  return {
    x: (Math.random() - 0.5) * 2,
    y: (Math.random() - 0.5) * 2,
    colorIndex: Math.random(),
    seed: seed,
    transforms: generateFlameTransforms(seed, 0, 0)
  };
}

function generateFlameTransforms(seed, time, beatAccum) {
  const t = time * 0.00003 + seed * 7.77;
  const ba = beatAccum * 0.3;
  // 5 transforms with different variations and morph speeds
  return [
    {
      a: 0.6 * Math.cos(t * 0.7 + ba * 0.1), b: -0.4 * Math.sin(t * 1.1 + ba * 0.05),
      c: 0.12 * Math.sin(t * 0.5 + seed), d: 0.4 * Math.sin(t * 0.9),
      e: 0.6 * Math.cos(t * 0.8 + ba * 0.08), f: 0.1 * Math.cos(t * 0.6 + seed * 2),
      var1: 0, var2: 1, blend: 0.7, colorIndex: 0.0, weight: 1.0
    },
    {
      a: 0.5 * Math.sin(t * 0.4 + seed), b: -0.65 * Math.cos(t * 0.6),
      c: -0.15 * Math.cos(t * 0.3 + ba * 0.12), d: 0.65 * Math.cos(t * 0.5 + seed * 0.5),
      e: 0.5 * Math.sin(t * 0.7), f: 0.15 * Math.sin(t * 0.4 + seed * 3),
      var1: 1, var2: 5, blend: 0.5, colorIndex: 0.2, weight: 1.0
    },
    {
      a: 0.38 * Math.cos(t * 1.2 + seed * 1.3), b: 0.52 * Math.sin(t * 0.3 + ba * 0.07),
      c: 0.18 * Math.sin(t * 0.8), d: -0.52 * Math.sin(t * 0.5 + seed * 0.8),
      e: 0.38 * Math.cos(t * 0.9 + ba * 0.06), f: -0.12 * Math.cos(t * 0.7),
      var1: 4, var2: 9, blend: 0.6, colorIndex: 0.45, weight: 1.0
    },
    {
      a: -0.42 * Math.sin(t * 0.6 + seed * 2), b: 0.58 * Math.cos(t * 0.4),
      c: -0.1 * Math.cos(t * 1.0 + ba * 0.15), d: 0.58 * Math.sin(t * 0.3 + seed),
      e: 0.42 * Math.cos(t * 0.5), f: 0.08 * Math.sin(t * 0.9 + seed * 4),
      var1: 7, var2: 3, blend: 0.4, colorIndex: 0.7, weight: 1.0
    },
    {
      a: 0.3 * Math.cos(t * 0.55 + seed * 0.7), b: -0.5 * Math.sin(t * 0.85 + ba * 0.1),
      c: 0.05 * Math.sin(t * 1.3), d: 0.48 * Math.cos(t * 0.65 + seed * 1.5),
      e: -0.35 * Math.sin(t * 0.75 + ba * 0.05), f: -0.08 * Math.cos(t * 0.45 + seed * 2.5),
      var1: 8, var2: 6, blend: 0.55, colorIndex: 0.9, weight: 0.8
    }
  ];
}

function drawFractalFlame(ctx, w, h, time) {
  const iw = Math.floor(w);
  const ih = Math.floor(h);
  if (iw < 2 || ih < 2) return;

  // Reinitialize buffers if canvas size changed
  if (!flameInitialized || flameWidth !== iw || flameHeight !== ih) {
    flameWidth = iw;
    flameHeight = ih;
    // density buffer: 4 floats per pixel [r, g, b, hitCount]
    flameDensityBuffer = new Float32Array(iw * ih * 4);
    flameImageData = ctx.createImageData(iw, ih);
    // Create 3 independent flame systems
    flameSystems = [
      createFlameSystem(0),
      createFlameSystem(1),
      createFlameSystem(2)
    ];
    flameInitialized = true;
    flameBeatAccum = 0;
    flamePaletteOffset = 0;
  }

  // === Fade density buffer (persistence/trail) ===
  const fadeFactor = beatIntensity > 0.4 ? 0.85 : 0.93;
  const bufLen = flameDensityBuffer.length;
  for (let i = 0; i < bufLen; i++) {
    flameDensityBuffer[i] *= fadeFactor;
  }

  // === Audio reactive parameters ===
  const bassSwirl = bands.bass * bands.bass * 4;
  const energy = bands.energy;
  const mid = bands.mid;

  // Beat accumulator for transform morphing
  if (beatIntensity > 0.3) {
    flameBeatAccum += beatIntensity * 0.6;
  }
  // Palette rotation from mid
  flamePaletteOffset += mid * 0.008 + 0.001;

  // Iteration count: 15k base, up to 30k with energy
  const baseIterations = 15000;
  const iterationsPerSystem = Math.floor(baseIterations + energy * 12000 + beatIntensity * 5000);

  const cx = iw / 2;
  const cy = ih / 2;
  const scale = Math.min(iw, ih) * 0.26;
  const invScale = 1.0 / scale;

  // === Iterate each flame system ===
  for (let si = 0; si < flameSystems.length; si++) {
    const sys = flameSystems[si];

    // Regenerate transforms with current time morphing
    sys.transforms = generateFlameTransforms(sys.seed, time, flameBeatAccum);
    const transforms = sys.transforms;
    const numT = transforms.length;

    // Beat: dramatically shift a random transform
    if (beatIntensity > 0.4) {
      const bti = Math.floor(Math.random() * numT);
      const bt = transforms[bti];
      bt.c += (Math.random() - 0.5) * beatIntensity * 0.9;
      bt.f += (Math.random() - 0.5) * beatIntensity * 0.9;
      bt.a *= (1 + beatIntensity * 0.6 * (Math.random() - 0.3));
      bt.e *= (1 + beatIntensity * 0.5 * (Math.random() - 0.3));
      // Occasionally swap a variation on beat for dramatic change
      if (Math.random() < 0.3) {
        bt.var1 = Math.floor(Math.random() * 10);
      }
    }

    // Compute total weight for weighted random selection
    let totalWeight = 0;
    for (let ti = 0; ti < numT; ti++) totalWeight += transforms[ti].weight;

    let px = sys.x;
    let py = sys.y;
    let ci = sys.colorIndex;

    for (let iter = 0; iter < iterationsPerSystem; iter++) {
      // Weighted random transform selection
      let rw = Math.random() * totalWeight;
      let ti = 0;
      for (; ti < numT - 1; ti++) {
        rw -= transforms[ti].weight;
        if (rw <= 0) break;
      }
      const tr = transforms[ti];

      // Affine transform
      let ax = tr.a * px + tr.b * py + tr.c;
      let ay = tr.d * px + tr.e * py + tr.f;

      // Blend two nonlinear variations
      const v1 = flameVariation(tr.var1, ax, ay, bassSwirl);
      const v2 = flameVariation(tr.var2, ax, ay, bassSwirl);
      const bl = tr.blend;
      let nx = v1[0] * bl + v2[0] * (1 - bl);
      let ny = v1[1] * bl + v2[1] * (1 - bl);

      // Guard against NaN / Infinity
      if (!isFinite(nx) || !isFinite(ny)) {
        nx = (Math.random() - 0.5) * 2;
        ny = (Math.random() - 0.5) * 2;
      }

      // Blend color index
      ci = (ci + tr.colorIndex) * 0.5;

      px = nx;
      py = ny;

      // Skip first 20 iterations (transient removal)
      if (iter < 20) continue;

      // Map to pixel coordinates
      const sx = Math.floor(cx + nx * scale);
      const sy = Math.floor(cy + ny * scale);

      if (sx < 0 || sx >= iw || sy < 0 || sy >= ih) continue;

      // Get color from palette
      const palT = (ci + flamePaletteOffset) % 1.0;
      const col = flamePaletteColor(palT < 0 ? palT + 1 : palT);

      // Accumulate into density buffer
      const pidx = (sy * iw + sx) * 4;
      flameDensityBuffer[pidx]     += col[0];
      flameDensityBuffer[pidx + 1] += col[1];
      flameDensityBuffer[pidx + 2] += col[2];
      flameDensityBuffer[pidx + 3] += 1.0;  // hit count
    }

    // Store state back
    sys.x = px;
    sys.y = py;
    sys.colorIndex = ci;
  }

  // === Log-density mapping to ImageData ===
  const pixels = flameImageData.data;
  const density = flameDensityBuffer;
  const totalPixels = iw * ih;

  // Find max hit count for normalization
  let maxHits = 0;
  for (let i = 0; i < totalPixels; i++) {
    const hits = density[i * 4 + 3];
    if (hits > maxHits) maxHits = hits;
  }

  const logMax = Math.log(maxHits + 1);
  const gamma = 1.0 / 2.2;
  // Brightness boost from energy
  const brightBoost = 1.0 + energy * 0.8 + beatIntensity * 0.4;

  if (logMax > 0) {
    for (let i = 0; i < totalPixels; i++) {
      const di = i * 4;
      const pi = i * 4;
      const hits = density[di + 3];

      if (hits < 0.5) {
        pixels[pi]     = 0;
        pixels[pi + 1] = 0;
        pixels[pi + 2] = 0;
        pixels[pi + 3] = 255;
        continue;
      }

      // Log-density mapping
      const logVal = Math.log(hits + 1) / logMax;
      // Gamma correction
      const brightness = Math.pow(logVal, gamma) * brightBoost;
      const clampedBr = Math.min(brightness, 1.0);

      // Average color for this pixel (weighted by hits)
      const invHits = 1.0 / hits;
      const cr = density[di]     * invHits;
      const cg = density[di + 1] * invHits;
      const cb = density[di + 2] * invHits;

      pixels[pi]     = Math.min(255, Math.round(cr * clampedBr));
      pixels[pi + 1] = Math.min(255, Math.round(cg * clampedBr));
      pixels[pi + 2] = Math.min(255, Math.round(cb * clampedBr));
      pixels[pi + 3] = 255;
    }
  } else {
    // No hits yet, black frame
    for (let i = 0; i < totalPixels; i++) {
      const pi = i * 4;
      pixels[pi] = 0; pixels[pi + 1] = 0; pixels[pi + 2] = 0; pixels[pi + 3] = 255;
    }
  }

  // Put imageData to canvas
  ctx.putImageData(flameImageData, 0, 0);

  // === Beat pulse glow overlay ===
  if (beatIntensity > 0.2) {
    ctx.globalCompositeOperation = 'screen';
    const coreR = 30 + beatIntensity * 80;
    const coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR);
    coreGrad.addColorStop(0, `rgba(255, 45, 123, ${beatIntensity * 0.3})`);
    coreGrad.addColorStop(0.35, `rgba(183, 110, 255, ${beatIntensity * 0.15})`);
    coreGrad.addColorStop(0.7, `rgba(0, 220, 245, ${beatIntensity * 0.07})`);
    coreGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = coreGrad;
    ctx.beginPath();
    ctx.arc(cx, cy, coreR, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
  }

  // Outer glow sync
  vizGlowIntensity = Math.max(vizGlowIntensity, energy * 0.6 + beatIntensity * 0.4);
  const panel = document.getElementById('vizPanel');
  if (panel) {
    const glow = Math.round(vizGlowIntensity * 30);
    panel.style.boxShadow = `0 0 ${glow}px rgba(157,78,221,${vizGlowIntensity * 0.4}), 0 0 ${glow*2}px rgba(255,45,123,${vizGlowIntensity * 0.2})`;
  }
}

const voidParticles = Array.from({length:80}, () => ({
  x:Math.random()*2000, y:Math.random()*1000,
  vx:(Math.random()-0.5)*0.5, vy:(Math.random()-0.5)*0.5,
  size:Math.random()*2+0.5, alpha:Math.random()*0.4+0.1
}));

// Void Pulse side-emitter particles
let voidSideParticles = [];
function spawnVoidSideParticles(w, h, bi, side) {
  const count = Math.floor(3 + bi * 12);
  for (let i = 0; i < count; i++) {
    const baseX = side === 'left' ? 0 : w;
    const dirX = side === 'left' ? 1 : -1;
    voidSideParticles.push({
      x: baseX + (Math.random() - 0.5) * 30,
      y: h * 0.2 + Math.random() * h * 0.6,
      vx: dirX * (1.5 + Math.random() * 3 + bi * 4),
      vy: (Math.random() - 0.5) * 2,
      size: 1 + Math.random() * 3 + bi * 2,
      alpha: 0.6 + Math.random() * 0.4,
      life: 1.0,
      decay: 0.008 + Math.random() * 0.012,
      isCyan: Math.random() < 0.5,
      trail: []
    });
  }
  if (voidSideParticles.length > 200) voidSideParticles = voidSideParticles.slice(-200);
}

function drawVoidPulse(ctx, w, h, time) {
  // Longer trail for more dramatic persistence
  ctx.fillStyle = 'rgba(0, 0, 0, 0.045)';
  ctx.fillRect(0, 0, w, h);

  const cx = w / 2, cy = h / 2;
  // Slowed down: reduced energy multiplier
  const energyMult = 0.4 + bands.energy * 2.5;
  const bi = beatIntensity;

  // Ambient particles - slowed down
  voidParticles.forEach(p => {
    p.x += p.vx * energyMult * 0.5; p.y += p.vy * energyMult * 0.5;
    if(p.x < 0) p.x = w; if(p.x > w) p.x = 0; if(p.y < 0) p.y = h; if(p.y > h) p.y = 0;
    const pAlpha = p.alpha + bands.mid * 0.8 + bands.energy * 0.3;
    const isCyan = Math.sin(time * 0.0005 + p.alpha * 10) > 0.3;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * (1 + bi * 2.5), 0, Math.PI * 2);
    ctx.fillStyle = isCyan ? `rgba(0,220,245,${pAlpha})` : `rgba(157,78,221,${pAlpha})`;
    ctx.fill();
    // Extra glow for drama
    if (p.size > 1) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 5, 0, Math.PI * 2);
      ctx.fillStyle = isCyan ? `rgba(0,220,245,${pAlpha * 0.08})` : `rgba(157,78,221,${pAlpha * 0.08})`;
      ctx.fill();
    }
  });

  // Dramatic pulsing core - bigger, more layers
  const coreR = 25 + bands.bass * 60 + bi * 50;
  const coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR);
  coreGrad.addColorStop(0, `rgba(240, 220, 255, ${0.7 + bi * 0.3})`);
  coreGrad.addColorStop(0.15, `rgba(200, 150, 255, ${0.5 + bi * 0.4})`);
  coreGrad.addColorStop(0.35, `rgba(157, 78, 221, ${0.3 + bi * 0.4})`);
  coreGrad.addColorStop(0.6, `rgba(0, 220, 245, ${0.12 + bands.energy * 0.25})`);
  coreGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = coreGrad;
  ctx.beginPath();
  ctx.arc(cx, cy, coreR, 0, Math.PI * 2);
  ctx.fill();

  // Outer atmospheric halo
  const haloR = coreR * 2.5 + bands.energy * 40;
  const haloGrad = ctx.createRadialGradient(cx, cy, coreR * 0.5, cx, cy, haloR);
  haloGrad.addColorStop(0, `rgba(157, 78, 221, ${0.04 + bi * 0.08})`);
  haloGrad.addColorStop(0.5, `rgba(0, 180, 216, ${0.02 + bi * 0.04})`);
  haloGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = haloGrad;
  ctx.beginPath();
  ctx.arc(cx, cy, haloR, 0, Math.PI * 2);
  ctx.fill();

  // Spiral arms - SLOWED rotation speed by ~60%
  const spiralArms = 4;
  const spiralRotation = time * 0.0002 * (1 + bands.mid * 1.5);
  ctx.globalCompositeOperation = 'lighter';
  for (let arm = 0; arm < spiralArms; arm++) {
    const armAngle = (arm / spiralArms) * Math.PI * 2 + spiralRotation;
    ctx.beginPath();
    for (let i = 0; i < 100; i++) {
      const t = i / 100;
      const spiralR = 20 + t * Math.min(w, h) * 0.48;
      const twist = t * 3.5 + armAngle;
      const freqIdx = Math.floor(t * 128);
      const freqWobble = freqData ? (freqData[freqIdx] || 0) / 255 * 20 : 0;
      const sx = cx + Math.cos(twist) * (spiralR + freqWobble);
      const sy = cy + Math.sin(twist) * (spiralR + freqWobble);
      if (i === 0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    }
    const armAlpha = 0.12 + bands.mid * 0.35 + bi * 0.35;
    const isCyanArm = arm % 2 === 0;
    ctx.strokeStyle = isCyanArm
      ? `rgba(0, 220, 245, ${armAlpha})`
      : `rgba(183, 110, 255, ${armAlpha})`;
    ctx.lineWidth = 1.5 + bands.energy * 4;
    ctx.stroke();

    // Second thicker glow pass for drama
    ctx.strokeStyle = isCyanArm
      ? `rgba(0, 220, 245, ${armAlpha * 0.15})`
      : `rgba(183, 110, 255, ${armAlpha * 0.15})`;
    ctx.lineWidth = 6 + bands.energy * 10;
    ctx.stroke();
  }
  ctx.globalCompositeOperation = 'source-over';

  // Spawn side particles on beat from BOTH sides
  if (bi > 0.2) {
    spawnVoidSideParticles(w, h, bi, 'left');
    spawnVoidSideParticles(w, h, bi, 'right');
  }

  // Draw and update side particles with trails
  ctx.globalCompositeOperation = 'lighter';
  voidSideParticles.forEach(p => {
    // Store trail position
    p.trail.push({ x: p.x, y: p.y });
    if (p.trail.length > 8) p.trail.shift();

    p.x += p.vx;
    p.y += p.vy;
    p.vy += (Math.random() - 0.5) * 0.3;
    p.life -= p.decay;

    if (p.life <= 0) return;

    const a = p.alpha * p.life;
    const color = p.isCyan ? [0, 220, 245] : [183, 110, 255];

    // Draw trail
    for (let ti = 0; ti < p.trail.length; ti++) {
      const trailAlpha = a * (ti / p.trail.length) * 0.3;
      const trailSize = p.size * (ti / p.trail.length) * 0.6;
      ctx.beginPath();
      ctx.arc(p.trail[ti].x, p.trail[ti].y, trailSize, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${trailAlpha})`;
      ctx.fill();
    }

    // Main particle
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${a})`;
    ctx.fill();

    // Glow around particle
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * 4, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${a * 0.12})`;
    ctx.fill();
  });
  voidSideParticles = voidSideParticles.filter(p => p.life > 0);
  ctx.globalCompositeOperation = 'source-over';

  // Spawn rings - slowed
  trySpawnRing(performance.now());
  // Extra ring spawns on beat
  if (bi > 0.3) {
    vizRings.push({
      x: cx, y: cy,
      r: 5 + bands.bass * 50,
      alpha: 1,
      speed: 1.2 + Math.random() * 2 + bi * 2,
      width: 2.5 + bands.energy * 7
    });
    if (vizRings.length > 25) vizRings.shift();
  }

  // Draw rings with frequency-based wobble - slower expansion
  let maxAlpha = 0;
  vizRings.forEach(ring => {
    ring.r += ring.speed * (0.6 + bands.energy * 1.2);
    ring.alpha -= 0.004;
    if(ring.alpha <= 0) return;
    if(ring.alpha > maxAlpha) maxAlpha = ring.alpha;

    const rr = Math.round(157 - bi * 120);
    const rg = Math.round(78 + bi * 160);
    const rb = Math.round(221 + bi * 34);

    // Wobbling ring (distorted by frequency)
    ctx.beginPath();
    for (let a = 0; a <= Math.PI * 2; a += 0.05) {
      const freqIdx = Math.floor((a / (Math.PI * 2)) * 128);
      const wobble = freqData ? (freqData[freqIdx] || 0) / 255 * (5 + ring.r * 0.08) : 0;
      const rx = ring.x + Math.cos(a) * (ring.r + wobble);
      const ry = ring.y + Math.sin(a) * (ring.r + wobble);
      if (a === 0) ctx.moveTo(rx, ry);
      else ctx.lineTo(rx, ry);
    }
    ctx.closePath();
    ctx.strokeStyle = `rgba(${rr},${rg},${rb},${ring.alpha})`;
    ctx.lineWidth = ring.width;
    ctx.stroke();

    // Glow ring - thicker for drama
    ctx.strokeStyle = `rgba(${Math.min(255, rr + 30)},${Math.min(255, rg + 40)},${Math.min(255, rb + 34)},${ring.alpha * 0.2})`;
    ctx.lineWidth = ring.width * 6;
    ctx.stroke();
  });

  vizRings = vizRings.filter(r => r.alpha > 0);

  vizGlowIntensity = maxAlpha;
  const panel = document.getElementById('vizPanel');
  if (panel) {
    const glow = Math.round(vizGlowIntensity * 40);
    panel.style.boxShadow = `0 0 ${glow}px rgba(157,78,221,${vizGlowIntensity * 0.5}), 0 0 ${glow*2}px rgba(123,47,190,${vizGlowIntensity * 0.2})`;
  }
}

function drawTronGrid(ctx, w, h, time) {
  const horizon = h * 0.38;
  const speed = time * 0.00012 * (1 + bands.energy * 4);
  const gridLines = 32;
  const vanishX = w / 2;
  const bassBoost = bands.bass * bands.bass;
  const bi = beatIntensity;
  const pulse = Math.sin(time * 0.002) * 0.5 + 0.5;

  // Bass-reactive ground shake offset
  const bassShakeY = bands.bass > 0.4 ? Math.sin(time * 0.02) * bands.bass * 3 : 0;
  const bassShakeX = bands.bass > 0.5 ? Math.sin(time * 0.017) * bands.bass * 2 : 0;

  // === STARS (drawn first, behind everything) - 4x more, varied twinkle ===
  const starCount = 120;
  for (let i = 0; i < starCount; i++) {
    const seed = i * 7919;
    const sx = ((seed * 13) % 1000) / 1000 * w;
    const sy = ((seed * 17) % 1000) / 1000 * horizon * 0.95;
    const twinkleSpeed = 0.001 + ((seed * 3) % 100) / 100 * 0.004;
    const twinkle = Math.sin(time * twinkleSpeed + seed) * 0.5 + 0.5;
    const twinkle2 = Math.sin(time * twinkleSpeed * 1.7 + seed * 0.3) * 0.5 + 0.5;
    const combinedTwinkle = twinkle * 0.6 + twinkle2 * 0.4;
    const starAlpha = 0.1 + combinedTwinkle * 0.6 + bi * 0.25;
    const starSize = 0.4 + combinedTwinkle * 1.8;
    const colorType = (seed * 7) % 3;
    let starColor;
    if (colorType === 0) starColor = `rgba(200, 210, 255, ${starAlpha})`;
    else if (colorType === 1) starColor = `rgba(183, 110, 255, ${starAlpha * 0.9})`;
    else starColor = `rgba(0, 220, 245, ${starAlpha * 0.8})`;
    ctx.beginPath();
    ctx.arc(sx, sy, starSize, 0, Math.PI * 2);
    ctx.fillStyle = starColor;
    ctx.fill();
    // Cross-shaped twinkle flare for brightest stars
    if (combinedTwinkle > 0.75 && starSize > 1.2) {
      const flareLen = starSize * 3 + combinedTwinkle * 4;
      const flareAlpha = (combinedTwinkle - 0.75) * 2 * starAlpha * 0.5;
      ctx.strokeStyle = `rgba(200, 220, 255, ${flareAlpha})`;
      ctx.lineWidth = 0.5;
      ctx.beginPath(); ctx.moveTo(sx - flareLen, sy); ctx.lineTo(sx + flareLen, sy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(sx, sy - flareLen); ctx.lineTo(sx, sy + flareLen); ctx.stroke();
    }
  }

  // === PLANET on the horizon (immersive approach target) ===
  const planetX = vanishX;
  const planetBaseY = horizon - 20;
  const planetY = planetBaseY - 10 - Math.sin(time * 0.0003) * 8 - bands.bass * 12;
  const planetBaseR = Math.min(w, h) * 0.11;
  const planetR = planetBaseR + bands.bass * 12 + bi * 6;
  // Planet atmosphere glow
  const atmosR = planetR * 3.5;
  const atmosGrad = ctx.createRadialGradient(planetX, planetY, planetR * 0.8, planetX, planetY, atmosR);
  atmosGrad.addColorStop(0, `rgba(0, 180, 216, ${0.06 + bi * 0.08})`);
  atmosGrad.addColorStop(0.3, `rgba(123, 47, 190, ${0.03 + bi * 0.04})`);
  atmosGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = atmosGrad;
  ctx.beginPath(); ctx.arc(planetX, planetY, atmosR, 0, Math.PI * 2); ctx.fill();
  // Planet body
  const planetGrad = ctx.createRadialGradient(planetX - planetR * 0.3, planetY - planetR * 0.3, 0, planetX, planetY, planetR);
  planetGrad.addColorStop(0, `rgba(80, 50, 120, ${0.9 + bi * 0.1})`);
  planetGrad.addColorStop(0.4, `rgba(40, 20, 80, ${0.85 + bi * 0.1})`);
  planetGrad.addColorStop(0.85, 'rgba(15, 8, 40, 0.95)');
  planetGrad.addColorStop(1, 'rgba(5, 2, 15, 0.9)');
  ctx.fillStyle = planetGrad;
  ctx.beginPath(); ctx.arc(planetX, planetY, planetR, 0, Math.PI * 2); ctx.fill();
  // Planet surface bands
  ctx.save();
  ctx.beginPath(); ctx.arc(planetX, planetY, planetR, 0, Math.PI * 2); ctx.clip();
  for (let band = 0; band < 6; band++) {
    const bandY = planetY - planetR + (band / 6) * planetR * 2 + Math.sin(time * 0.0002 + band) * 2;
    const bandH = planetR * 0.12;
    const bandAlpha = 0.08 + Math.sin(time * 0.0005 + band * 1.5) * 0.04 + bi * 0.06;
    ctx.fillStyle = band % 2 === 0 ? `rgba(0, 180, 216, ${bandAlpha})` : `rgba(157, 78, 221, ${bandAlpha})`;
    ctx.fillRect(planetX - planetR, bandY, planetR * 2, bandH);
  }
  ctx.restore();
  // Planet rim light
  ctx.beginPath(); ctx.arc(planetX, planetY, planetR, 0, Math.PI * 2);
  ctx.strokeStyle = `rgba(0, 220, 245, ${0.25 + bi * 0.35 + bands.bass * 0.2})`;
  ctx.lineWidth = 1.5 + bi * 1.5; ctx.stroke();
  ctx.strokeStyle = `rgba(0, 220, 245, ${0.06 + bi * 0.1})`;
  ctx.lineWidth = 6 + bi * 6; ctx.stroke();

  // === SKY: radial vanishing-point glow ===
  const sunRadius = 80 + bi * 120 + bassBoost * 60;
  const sunGrad = ctx.createRadialGradient(vanishX, horizon, 0, vanishX, horizon, sunRadius);
  sunGrad.addColorStop(0, `rgba(183, 110, 255, ${0.35 + bi * 0.5})`);
  sunGrad.addColorStop(0.3, `rgba(0, 220, 245, ${0.15 + bi * 0.3})`);
  sunGrad.addColorStop(0.6, `rgba(123, 47, 190, ${0.06 + bi * 0.1})`);
  sunGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = sunGrad;
  ctx.fillRect(vanishX - sunRadius, horizon - sunRadius, sunRadius * 2, sunRadius * 2);

  // === HORIZONTAL GRID LINES — crisp cyan, clean and sharp ===
  for (let i = 0; i < gridLines; i++) {
    const t = (i / gridLines + speed) % 1;
    const rawY = horizon + (h - horizon) * Math.pow(t, 1.4) + bassShakeY;
    const y = Math.round(rawY) + 0.5; // Snap to pixel for crisp lines
    const proximity = Math.pow(t, 0.6);
    const alpha = proximity * (0.35 + bands.bass * 0.5 + bi * 0.3);
    const lineW = proximity > 0.3 ? 1 : 0.5; // Crisp: either 1px or 0.5px

    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y);
    ctx.strokeStyle = `rgba(0, 220, 245, ${Math.min(0.8, alpha)})`;
    ctx.lineWidth = lineW;
    ctx.stroke();
  }

  // === VERTICAL CONVERGING LINES — purple only, ultra-thin, crisp ===
  const vLines = 24;
  for (let i = -vLines; i <= vLines; i++) {
    if (i === 0) continue;
    const spread = 2.4 + bassBoost * 0.6 + bi * 0.2;
    const baseX = vanishX + i * (w / vLines) * spread + bassShakeX;
    const dist = Math.abs(i) / vLines;
    const alpha = Math.max(0, 0.12 + bands.energy * 0.15 + bands.bass * 0.08 - dist * 0.1);
    if (alpha <= 0) continue;
    const lineW = 0.3 + (1 - dist) * 0.4;

    ctx.beginPath(); ctx.moveTo(vanishX + bassShakeX, horizon + bassShakeY); ctx.lineTo(baseX, h);
    ctx.strokeStyle = `rgba(157, 78, 221, ${Math.min(0.35, alpha)})`;
    ctx.lineWidth = lineW; ctx.stroke();
  }

  // === HORIZON GLOW - stronger bass reaction ===
  const hGlowSize = 60 + bi * 50 + bands.bass * 40;
  const hGrad = ctx.createLinearGradient(0, horizon - hGlowSize, 0, horizon + hGlowSize * 0.7);
  hGrad.addColorStop(0, 'transparent');
  hGrad.addColorStop(0.4, `rgba(0, 220, 245, ${0.06 + bi * 0.15 + bands.bass * 0.1})`);
  hGrad.addColorStop(0.5, `rgba(183, 110, 255, ${0.2 + bi * 0.5 + bands.bass * 0.3})`);
  hGrad.addColorStop(0.55, `rgba(0, 220, 245, ${0.15 + bi * 0.4 + bands.bass * 0.2})`);
  hGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = hGrad;
  ctx.fillRect(0, horizon - hGlowSize, w, hGlowSize * 1.7);

  // Bright horizon line - pulses with bass
  ctx.beginPath(); ctx.moveTo(0, horizon + bassShakeY); ctx.lineTo(w, horizon + bassShakeY);
  ctx.strokeStyle = `rgba(0, 220, 245, ${0.5 + bi * 0.5 + bands.bass * 0.3})`;
  ctx.lineWidth = 1.5 + bi * 2 + bands.bass * 3; ctx.stroke();
  ctx.strokeStyle = `rgba(0, 220, 245, ${0.12 + bi * 0.15 + bands.bass * 0.1})`;
  ctx.lineWidth = 8 + bi * 16 + bands.bass * 12;
  ctx.beginPath(); ctx.moveTo(0, horizon + bassShakeY); ctx.lineTo(w, horizon + bassShakeY); ctx.stroke();

  // === PULSE WAVES — clean horizontal sweeps moving down the grid ===
  const pulseCount = 4;
  for (let p = 0; p < pulseCount; p++) {
    const pulseT = ((time * 0.00025 + p / pulseCount) % 1);
    const rawPulseY = horizon + (h - horizon) * Math.pow(pulseT, 1.3) + bassShakeY;
    const pulseY = Math.round(rawPulseY) + 0.5;
    const pulseLife = 1 - pulseT;
    const pulseAlpha = pulseLife * (0.4 + bi * 0.5 + bands.bass * 0.3);

    // Sharp bright core line
    ctx.beginPath(); ctx.moveTo(0, pulseY); ctx.lineTo(w, pulseY);
    ctx.strokeStyle = `rgba(0, 220, 245, ${Math.min(1, pulseAlpha)})`;
    ctx.lineWidth = 1.5 + pulseLife * 1.5; ctx.stroke();

    // Soft glow halo
    const haloSize = 6 + pulseLife * 10 + bi * 8;
    const haloGrad = ctx.createLinearGradient(0, pulseY - haloSize, 0, pulseY + haloSize);
    haloGrad.addColorStop(0, 'transparent');
    haloGrad.addColorStop(0.4, `rgba(0, 220, 245, ${pulseAlpha * 0.08})`);
    haloGrad.addColorStop(0.5, `rgba(0, 220, 245, ${pulseAlpha * 0.15})`);
    haloGrad.addColorStop(0.6, `rgba(0, 220, 245, ${pulseAlpha * 0.08})`);
    haloGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = haloGrad;
    ctx.fillRect(0, pulseY - haloSize, w, haloSize * 2);
  }

  // === FLOATING ORBS — slow, nebulous, clean ===
  const orbCount = 8;
  for (let i = 0; i < orbCount; i++) {
    const seed = i * 3571;
    const orbPhase = time * 0.00015 + (seed % 100) * 0.1;
    const orbX = vanishX + Math.sin(orbPhase * 0.7 + i * 1.8) * (w * 0.35) + Math.cos(orbPhase * 0.3 + i) * 40;
    const orbBaseY = horizon * 0.25 + ((seed * 13) % 100) / 100 * horizon * 0.6;
    const orbY = orbBaseY + Math.sin(orbPhase + i * 2.1) * 20;
    const breathe = Math.sin(time * 0.0008 + i * 1.4) * 0.5 + 0.5;
    const orbR = 12 + breathe * 18 + bands.energy * 8;
    const orbAlpha = 0.04 + breathe * 0.06 + bi * 0.03;

    // Outer nebulous glow
    const outerGrad = ctx.createRadialGradient(orbX, orbY, 0, orbX, orbY, orbR * 3.5);
    outerGrad.addColorStop(0, `rgba(157, 78, 221, ${orbAlpha * 1.5})`);
    outerGrad.addColorStop(0.25, `rgba(123, 47, 190, ${orbAlpha})`);
    outerGrad.addColorStop(0.6, `rgba(74, 45, 107, ${orbAlpha * 0.4})`);
    outerGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = outerGrad;
    ctx.beginPath(); ctx.arc(orbX, orbY, orbR * 3.5, 0, Math.PI * 2); ctx.fill();

    // Inner bright core
    const coreGrad = ctx.createRadialGradient(orbX, orbY, 0, orbX, orbY, orbR * 0.8);
    coreGrad.addColorStop(0, `rgba(212, 160, 255, ${orbAlpha * 4})`);
    coreGrad.addColorStop(0.5, `rgba(183, 110, 255, ${orbAlpha * 2})`);
    coreGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = coreGrad;
    ctx.beginPath(); ctx.arc(orbX, orbY, orbR * 0.8, 0, Math.PI * 2); ctx.fill();
  }

  // === Edge vignette for depth ===
  const vigL = ctx.createLinearGradient(0, 0, w * 0.15, 0);
  vigL.addColorStop(0, 'rgba(0,0,0,0.6)');
  vigL.addColorStop(1, 'transparent');
  ctx.fillStyle = vigL;
  ctx.fillRect(0, 0, w * 0.15, h);
  const vigR = ctx.createLinearGradient(w, 0, w * 0.85, 0);
  vigR.addColorStop(0, 'rgba(0,0,0,0.6)');
  vigR.addColorStop(1, 'transparent');
  ctx.fillStyle = vigR;
  ctx.fillRect(w * 0.85, 0, w * 0.15, h);
}

let fieldParticles = null;
let fieldBeatReverse = 0;
function initFieldParticles(w, h) {
  fieldParticles = [];
  for (let i = 0; i < 400; i++) {
    const angle = Math.random() * Math.PI * 2;
    const armIndex = Math.floor(Math.random() * 3); // 3 spiral arms
    const armOffset = (armIndex / 3) * Math.PI * 2;
    const dist = 20 + Math.random() * Math.min(w, h) * 0.45;
    fieldParticles.push({
      angle, dist, baseAngle: angle, baseDist: dist,
      armOffset,
      speed: 0.0004 + Math.random() * 0.001, // Much slower base speed for buttery rotation
      size: 0.8 + Math.random() * 2.2,
      alpha: 0.2 + Math.random() * 0.6,
      sparkle: Math.random(),
      sparkleSpeed: 0.002 + Math.random() * 0.005,
      // Smoothed position for buttery interpolation
      smoothX: 0, smoothY: 0, initialized: false
    });
  }
}

// Smooth interpolation state for Particle Field
let fieldSmoothedBeat = 0;

function drawParticleField(ctx, w, h, time) {
  // Longer trail for smoother look
  ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
  ctx.fillRect(0, 0, w, h);

  if (!fieldParticles) initFieldParticles(w, h);
  const cx = w / 2, cy = h / 2;
  // Smooth the beat intensity for buttery transitions
  fieldSmoothedBeat += (beatIntensity - fieldSmoothedBeat) * 0.15;
  const bi = fieldSmoothedBeat;
  // Much slower orbital speed - buttery smooth rotation
  const orbitalSpeed = 0.3 + bands.bass * 1.5 + bi * 2;
  // Gentler expansion on beat
  const explode = bi * 35;

  // Beat reverse effect - smoother decay
  if (beatIntensity > 0.5) fieldBeatReverse = 1.0;
  fieldBeatReverse *= 0.97;
  const dirMult = fieldBeatReverse > 0.3 ? -1 : 1;

  ctx.globalCompositeOperation = 'lighter';

  // Smoothing factor for position interpolation (lower = smoother)
  const smoothFactor = 0.08;

  fieldParticles.forEach(p => {
    p.angle += p.speed * orbitalSpeed * dirMult;
    const spiralTightness = 0.3 + bands.mid * 0.5;
    const spiralAngle = p.angle + p.armOffset + Math.log(p.baseDist / 20 + 1) * spiralTightness;
    const d = p.baseDist + Math.sin(time * 0.0005 + p.baseAngle) * 20 + explode;
    const targetX = cx + Math.cos(spiralAngle) * d;
    const targetY = cy + Math.sin(spiralAngle) * d;

    // Buttery smooth position interpolation
    if (!p.initialized) {
      p.smoothX = targetX;
      p.smoothY = targetY;
      p.initialized = true;
    } else {
      p.smoothX += (targetX - p.smoothX) * smoothFactor;
      p.smoothY += (targetY - p.smoothY) * smoothFactor;
    }
    const x = p.smoothX;
    const y = p.smoothY;

    // Color varies with distance and beat
    const distRatio = p.baseDist / (Math.min(w, h) * 0.45);
    const isCyan = distRatio > 0.5 || bi > 0.3;
    const r = isCyan ? Math.round(30 * distRatio) : 157;
    const g = isCyan ? Math.round(180 + 40 * distRatio) : Math.round(78 + bands.high * 80);
    const b = isCyan ? 245 : 221;
    const a = p.alpha * (0.4 + bands.energy * 1.5 + bi * 0.8);

    // Size pulses with beat (smooth)
    const beatSize = p.size * (1 + bi * 2);

    ctx.beginPath();
    ctx.arc(x, y, beatSize, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${Math.min(1, a)})`;
    ctx.fill();

    // Glow - bigger on beat
    if (p.size > 1.0) {
      ctx.beginPath();
      ctx.arc(x, y, beatSize * 4 + bi * 3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${Math.min(0.2, a * 0.12 + bi * 0.04)})`;
      ctx.fill();
    }

    // Stardust sparkle effect - more responsive to beat
    p.sparkle += p.sparkleSpeed + bi * 0.01;
    const sparkleVal = Math.sin(p.sparkle * Math.PI * 2);
    if (sparkleVal > 0.8 || bi > 0.4) {
      const sparkSize = 1 + sparkleVal * 3 + bi * 3;
      ctx.beginPath();
      ctx.arc(x, y, sparkSize, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(220, 210, 255, ${0.3 + sparkleVal * 0.4 + bi * 0.3})`;
      ctx.fill();
    }
  });

  ctx.globalCompositeOperation = 'source-over';

  // Center orb - pulses with beat (smooth)
  const orbR = 12 + bands.bass * 45 + bi * 30;
  const orbGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, orbR);
  orbGrad.addColorStop(0, `rgba(220, 200, 255, ${0.5 + bi * 0.5})`);
  orbGrad.addColorStop(0.3, `rgba(0, 220, 245, ${0.3 + bi * 0.4})`);
  orbGrad.addColorStop(0.6, `rgba(157, 78, 221, ${0.15 + bands.energy * 0.2})`);
  orbGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = orbGrad;
  ctx.beginPath();
  ctx.arc(cx, cy, orbR, 0, Math.PI * 2);
  ctx.fill();

  // Outer ring glow
  ctx.beginPath();
  ctx.arc(cx, cy, Math.min(w, h) * 0.42, 0, Math.PI * 2);
  ctx.strokeStyle = `rgba(157, 78, 221, ${0.05 + bands.energy * 0.1})`;
  ctx.lineWidth = 1;
  ctx.stroke();
}

// Smoothed bar heights for buttery Waveform Bars
let waveformSmoothedBars = null;
let waveformSmoothedBeat = 0;
let waveformSmoothedRadius = 0;

function drawWaveformBars(ctx, w, h, time) {
  // Use a subtle trail instead of full clear for smoother motion
  ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
  ctx.fillRect(0, 0, w, h);

  if (!freqData || !analyser) return;
  const cx = w / 2, cy = h / 2;
  const bars = 128;
  const radius = Math.min(w, h) * 0.2;
  const maxBarH = Math.min(w, h) * 0.28;
  const rotation = time * 0.0001 * (1 + bands.energy * 2);

  // Smooth beat intensity for buttery transitions
  waveformSmoothedBeat += (beatIntensity - waveformSmoothedBeat) * 0.12;
  const bi = waveformSmoothedBeat;

  // Initialize smoothed bars array
  if (!waveformSmoothedBars || waveformSmoothedBars.length !== bars) {
    waveformSmoothedBars = new Float32Array(bars);
  }

  // Beat-reactive radius expansion (smooth)
  const targetRadius = radius + bi * 15 + bands.bass * 20;
  waveformSmoothedRadius += (targetRadius - waveformSmoothedRadius) * 0.1;
  const activeRadius = waveformSmoothedRadius;

  for (let i = 0; i < bars; i++) {
    const angle = (i / bars) * Math.PI * 2 - Math.PI / 2 + rotation;
    const freqIdx = Math.floor((i / bars) * 256);
    const rawVal = Math.pow((freqData[freqIdx] || 0) / 255, 0.8);

    // Smooth interpolation of bar heights for buttery movement
    const targetH = rawVal * maxBarH * (1 + bi * 1.0);
    waveformSmoothedBars[i] += (targetH - waveformSmoothedBars[i]) * 0.18;
    const barH = waveformSmoothedBars[i];
    const val = barH / maxBarH; // normalized smoothed value

    // Color gradient: purple (low) to cyan (high), with beat-reactive brightness
    const t = i / bars;
    const beatColor = bi * 0.3;
    const r = Math.round(157 * (1 - t) + beatColor * 60);
    const g = Math.round(78 * (1 - t) + 220 * t + beatColor * 40);
    const b = Math.round(221 * (1 - t) + 245 * t);

    const x1 = cx + Math.cos(angle) * activeRadius;
    const y1 = cy + Math.sin(angle) * activeRadius;
    const x2 = cx + Math.cos(angle) * (activeRadius + barH);
    const y2 = cy + Math.sin(angle) * (activeRadius + barH);

    const barWidth = Math.max(1.5, (w / bars) * 0.35) + bi * 0.5;

    // Outer bar
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.5 + val * 0.5})`;
    ctx.lineWidth = barWidth;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Glow halo at bar tip - enhanced on beat
    if (val > 0.15) {
      const glowSize = 4 + val * 8 + bi * 5;
      const tipGlow = ctx.createRadialGradient(x2, y2, 0, x2, y2, glowSize);
      tipGlow.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${0.5 + val * 0.5 + bi * 0.2})`);
      tipGlow.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${0.15 + bi * 0.1})`);
      tipGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = tipGlow;
      ctx.beginPath();
      ctx.arc(x2, y2, glowSize, 0, Math.PI * 2);
      ctx.fill();
    }

    // Inner bar (mirror/reflection) - dimmer, also smoothed
    const mirrorH = barH * 0.6;
    const x3 = cx + Math.cos(angle) * (activeRadius - mirrorH);
    const y3 = cy + Math.sin(angle) * (activeRadius - mirrorH);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x3, y3);
    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.15 + val * 0.2 + bi * 0.1})`;
    ctx.lineWidth = barWidth * 0.7;
    ctx.stroke();
  }

  // Frequency label dots at key positions
  const labelPositions = [0, 0.125, 0.25, 0.5, 0.75, 1.0];
  labelPositions.forEach((pos, idx) => {
    const labelAngle = pos * Math.PI * 2 - Math.PI / 2 + rotation;
    const labelR = activeRadius + maxBarH + 12;
    const lx = cx + Math.cos(labelAngle) * labelR;
    const ly = cy + Math.sin(labelAngle) * labelR;
    const dotSize = 2 + bi * 2;
    ctx.beginPath();
    ctx.arc(lx, ly, dotSize, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(0, 220, 245, ${0.3 + bands.energy * 0.4 + bi * 0.3})`;
    ctx.fill();
  });

  // Center pulsing orb - enhanced beat reactivity
  const orbR = 18 + bands.bass * 50 + bi * 35;
  const orbGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, orbR);
  orbGrad.addColorStop(0, `rgba(220, 200, 255, ${0.5 + bi * 0.5})`);
  orbGrad.addColorStop(0.2, `rgba(0, 220, 245, ${0.35 + bi * 0.45})`);
  orbGrad.addColorStop(0.5, `rgba(157, 78, 221, ${0.2 + bands.energy * 0.3 + bi * 0.2})`);
  orbGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = orbGrad;
  ctx.beginPath();
  ctx.arc(cx, cy, orbR, 0, Math.PI * 2);
  ctx.fill();

  // Ring around bars - pulses with beat
  ctx.beginPath();
  ctx.arc(cx, cy, activeRadius, 0, Math.PI * 2);
  ctx.strokeStyle = `rgba(157, 78, 221, ${0.15 + bands.energy * 0.3 + bi * 0.2})`;
  ctx.lineWidth = 1 + bi * 1.5;
  ctx.stroke();
  // Ring glow on beat
  if (bi > 0.15) {
    ctx.strokeStyle = `rgba(157, 78, 221, ${bi * 0.1})`;
    ctx.lineWidth = 4 + bi * 8;
    ctx.stroke();
  }

  // Outer containment ring - beat reactive
  ctx.beginPath();
  ctx.arc(cx, cy, activeRadius + maxBarH + 5, 0, Math.PI * 2);
  ctx.strokeStyle = `rgba(0, 220, 245, ${0.05 + bi * 0.2})`;
  ctx.lineWidth = 0.5 + bi * 1;
  ctx.stroke();

  // Beat flash ring (expanding ring on heavy beats)
  if (bi > 0.4) {
    const flashR = activeRadius + maxBarH * (0.5 + bi * 0.5);
    ctx.beginPath();
    ctx.arc(cx, cy, flashR, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(0, 220, 245, ${(bi - 0.4) * 0.4})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }
}

// ============ PLASMA WARP (Kaleidoscopic plasma) ============
function drawPlasmaWarp(ctx, w, h, time) {
  // Render at lower resolution, upscale with smoothing for butter
  const scale = 3;
  const pw = Math.floor(w / scale);
  const ph = Math.floor(h / scale);

  // Get or create offscreen canvas
  if (!drawPlasmaWarp._canvas || drawPlasmaWarp._canvas.width !== pw || drawPlasmaWarp._canvas.height !== ph) {
    drawPlasmaWarp._canvas = document.createElement('canvas');
    drawPlasmaWarp._canvas.width = pw;
    drawPlasmaWarp._canvas.height = ph;
    drawPlasmaWarp._ctx = drawPlasmaWarp._canvas.getContext('2d');
  }
  const pCtx = drawPlasmaWarp._ctx;
  const imageData = pCtx.createImageData(pw, ph);
  const data = imageData.data;

  const t = time * 0.0005 * (1 + bands.energy * 2);
  const bassFreq = 1 + bands.bass * 3;
  const midPhase = bands.mid * Math.PI * 3;
  const highFreq = 1 + bands.high * 2;
  const bi = beatIntensity;

  // Beat ripple
  const rippleStrength = bi * 30;
  const ripplePhase = time * 0.003;

  const cx = pw / 2;
  const cy = ph / 2;

  // Kaleidoscope fold count
  const folds = 6;
  const foldAngle = Math.PI * 2 / folds;

  for (let y = 0; y < ph; y++) {
    for (let x = 0; x < pw; x++) {
      // Kaleidoscope: fold coordinates
      let dx = x - cx;
      let dy = y - cy;
      let angle = Math.atan2(dy, dx);
      const dist = Math.sqrt(dx * dx + dy * dy);

      // Fold into sector
      angle = Math.abs(((angle % foldAngle) + foldAngle) % foldAngle);
      if (angle > foldAngle / 2) angle = foldAngle - angle;

      const kx = Math.cos(angle) * dist;
      const ky = Math.sin(angle) * dist;

      // Beat ripple distortion
      const ripple = Math.sin(dist * 0.1 - ripplePhase) * rippleStrength;
      const fx = (kx + ripple) / pw * 4;
      const fy = (ky + ripple) / ph * 4;

      // Layered sine plasma
      let v = 0;
      v += Math.sin(fx * bassFreq + t);
      v += Math.sin(fy * highFreq + t * 0.7 + midPhase);
      v += Math.sin((fx + fy) * 0.7 + t * 1.3);
      v += Math.sin(Math.sqrt(fx * fx + fy * fy) * 2 + t * 0.5);
      v += Math.sin(fx * Math.sin(t * 0.3) + fy * Math.cos(t * 0.4)) * (1 + bands.energy * 2);
      v = v / 5; // normalize to -1..1 range roughly
      v = (v + 1) / 2; // 0..1

      // Color mapping: rich purple-cyan palette, brighter than before
      let r, g, b;
      if (v < 0.25) {
        const f = v * 4;
        r = Math.round(15 + 60 * f);
        g = Math.round(5 + 30 * f);
        b = Math.round(25 + 75 * f);
      } else if (v < 0.5) {
        const f = (v - 0.25) * 4;
        r = Math.round(75 + 40 * f);
        g = Math.round(35 + 55 * f);
        b = Math.round(100 + 50 * f);
      } else if (v < 0.75) {
        const f = (v - 0.5) * 4;
        r = Math.round(115 - 70 * f);
        g = Math.round(90 + 60 * f);
        b = Math.round(150 + 25 * f);
      } else {
        const f = (v - 0.75) * 4;
        r = Math.round(45 + 70 * f);
        g = Math.round(150 - 60 * f);
        b = Math.round(175 - 30 * f);
      }

      // Brighter overall with beat reactivity
      const boost = 0.7 + bands.energy * 0.2 + bi * 0.12;
      r = Math.min(210, Math.round(r * boost));
      g = Math.min(200, Math.round(g * boost));
      b = Math.min(220, Math.round(b * boost));

      const idx = (y * pw + x) * 4;
      data[idx] = r;
      data[idx + 1] = g;
      data[idx + 2] = b;
      data[idx + 3] = 255;
    }
  }

  pCtx.putImageData(imageData, 0, 0);

  // Scale up to full canvas — bilinear smoothing makes it buttery
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(drawPlasmaWarp._canvas, 0, 0, w, h);

  // Light vignette for depth, not darkness
  const vigR = Math.max(w, h) * 0.65;
  const vigGrad = ctx.createRadialGradient(w/2, h/2, vigR * 0.4, w/2, h/2, vigR);
  vigGrad.addColorStop(0, 'transparent');
  vigGrad.addColorStop(1, 'rgba(0, 0, 0, 0.25)');
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, w, h);

  // Very subtle glow overlay on beat (dramatically toned down)
  if (bi > 0.3) {
    const glowR = Math.min(w, h) * 0.3 + bi * 40;
    const glowGrad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, glowR);
    glowGrad.addColorStop(0, `rgba(100, 60, 140, ${bi * 0.08})`);
    glowGrad.addColorStop(0.5, `rgba(0, 80, 100, ${bi * 0.03})`);
    glowGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = glowGrad;
    ctx.fillRect(0, 0, w, h);
  }

  vizGlowIntensity = bands.energy * 0.3 + bi * 0.3;
  const panel = document.getElementById('vizPanel');
  if (panel) {
    const glow = Math.round(vizGlowIntensity * 20);
    panel.style.boxShadow = `0 0 ${glow}px rgba(157,78,221,${vizGlowIntensity * 0.25}), 0 0 ${glow*2}px rgba(0,220,245,${vizGlowIntensity * 0.08})`;
  }
}

// ============ NEURAL WEB ============
function initNeuralNodes(w, h) {
  neuralNodes = [];
  for (let i = 0; i < 100; i++) {
    neuralNodes.push({
      x: Math.random() * w,
      y: Math.random() * h,
      vx: (Math.random() - 0.5) * 0.5,
      vy: (Math.random() - 0.5) * 0.5,
      baseSize: 1.5 + Math.random() * 3,
      size: 2,
      isCyan: Math.random() < 0.2,
      pulsePhase: Math.random() * Math.PI * 2
    });
  }
  neuralSignals = [];
}

function drawNeuralWeb(ctx, w, h, time) {
  // Trail effect
  ctx.fillStyle = 'rgba(0, 0, 0, 0.06)';
  ctx.fillRect(0, 0, w, h);

  if (!neuralNodes) initNeuralNodes(w, h);

  const cx = w / 2, cy = h / 2;
  const bi = beatIntensity;

  // Slowly moving attractor point
  const attractX = cx + Math.sin(time * 0.0003) * w * 0.2;
  const attractY = cy + Math.cos(time * 0.0004) * h * 0.15;

  // Beat explosion
  if (bi > 0.5 && neuralBeatCooldown <= 0) {
    neuralBeatCooldown = 15;
    neuralNodes.forEach(n => {
      const dx = n.x - cx;
      const dy = n.y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy) + 1;
      n.vx += (dx / dist) * bi * 8;
      n.vy += (dy / dist) * bi * 8;
    });
    // Spawn signal pulses on beat
    for (let s = 0; s < 5; s++) {
      const fromIdx = Math.floor(Math.random() * neuralNodes.length);
      neuralSignals.push({
        fromIdx,
        toIdx: -1, // will find nearest
        progress: 0,
        speed: 0.02 + Math.random() * 0.03
      });
    }
  }
  if (neuralBeatCooldown > 0) neuralBeatCooldown--;

  // Connection distance threshold
  const maxDist = 80 + bands.energy * 60;

  // Update nodes
  neuralNodes.forEach(n => {
    // Attract towards center point
    const dx = attractX - n.x;
    const dy = attractY - n.y;
    const dist = Math.sqrt(dx * dx + dy * dy) + 1;
    n.vx += (dx / dist) * 0.02;
    n.vy += (dy / dist) * 0.02;

    // Damping
    n.vx *= 0.97;
    n.vy *= 0.97;

    n.x += n.vx * (1 + bands.energy * 3);
    n.y += n.vy * (1 + bands.energy * 3);

    // Soft boundary
    if (n.x < 10) n.vx += 0.3;
    if (n.x > w - 10) n.vx -= 0.3;
    if (n.y < 10) n.vy += 0.3;
    if (n.y > h - 10) n.vy -= 0.3;

    // Beat pulse size
    n.size = n.baseSize * (1 + bi * 3) + Math.sin(n.pulsePhase + time * 0.003) * 0.5;
  });

  // Draw connections
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < neuralNodes.length; i++) {
    const a = neuralNodes[i];
    for (let j = i + 1; j < neuralNodes.length; j++) {
      const b = neuralNodes[j];
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < maxDist) {
        const alpha = (1 - dist / maxDist) * (0.15 + bands.energy * 0.5 + bi * 0.3);
        const isCyanLine = a.isCyan || b.isCyan;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.strokeStyle = isCyanLine
          ? `rgba(0, 220, 245, ${alpha})`
          : `rgba(157, 78, 221, ${alpha})`;
        ctx.lineWidth = 0.5 + (1 - dist / maxDist) * 1.5;
        ctx.stroke();

        // Glow on stronger connections
        if (alpha > 0.2) {
          ctx.strokeStyle = isCyanLine
            ? `rgba(0, 220, 245, ${alpha * 0.15})`
            : `rgba(157, 78, 221, ${alpha * 0.15})`;
          ctx.lineWidth = 4 + (1 - dist / maxDist) * 4;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }
    }
  }

  // Draw signal pulses traveling along connections
  neuralSignals.forEach(sig => {
    sig.progress += sig.speed * (1 + bands.energy * 2);
    if (sig.progress >= 1) {
      // Jump to next node
      sig.fromIdx = sig.toIdx >= 0 ? sig.toIdx : sig.fromIdx;
      sig.toIdx = -1;
      sig.progress = 0;
      // Small chance to die
      if (Math.random() < 0.3) sig.progress = 2; // mark for removal
    }
    if (sig.progress > 1) return;

    const from = neuralNodes[sig.fromIdx];
    if (!from) return;

    // Find nearest node as target
    if (sig.toIdx < 0) {
      let minDist = Infinity;
      for (let i = 0; i < neuralNodes.length; i++) {
        if (i === sig.fromIdx) continue;
        const dx = from.x - neuralNodes[i].x;
        const dy = from.y - neuralNodes[i].y;
        const d = dx * dx + dy * dy;
        if (d < minDist && d < maxDist * maxDist) {
          minDist = d;
          sig.toIdx = i;
        }
      }
      if (sig.toIdx < 0) { sig.progress = 2; return; }
    }

    const to = neuralNodes[sig.toIdx];
    if (!to) return;
    const sx = from.x + (to.x - from.x) * sig.progress;
    const sy = from.y + (to.y - from.y) * sig.progress;

    // Bright signal dot
    const sigGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, 6 + bi * 4);
    sigGrad.addColorStop(0, `rgba(220, 230, 255, 0.9)`);
    sigGrad.addColorStop(0.3, `rgba(0, 220, 245, 0.5)`);
    sigGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = sigGrad;
    ctx.beginPath();
    ctx.arc(sx, sy, 6 + bi * 4, 0, Math.PI * 2);
    ctx.fill();
  });
  neuralSignals = neuralSignals.filter(s => s.progress <= 1);

  // Draw nodes
  neuralNodes.forEach(n => {
    const r = n.isCyan ? 0 : 157;
    const g = n.isCyan ? 220 : 78;
    const b = n.isCyan ? 245 : 221;
    const alpha = 0.5 + bands.energy * 0.5 + bi * 0.3;

    ctx.beginPath();
    ctx.arc(n.x, n.y, n.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
    ctx.fill();

    // Glow around nodes
    const nodeGlow = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.size * 4);
    nodeGlow.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha * 0.3})`);
    nodeGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = nodeGlow;
    ctx.beginPath();
    ctx.arc(n.x, n.y, n.size * 4, 0, Math.PI * 2);
    ctx.fill();
  });

  ctx.globalCompositeOperation = 'source-over';

  vizGlowIntensity = bands.energy * 0.5 + bi * 0.5;
  const panel = document.getElementById('vizPanel');
  if (panel) {
    const glow = Math.round(vizGlowIntensity * 30);
    panel.style.boxShadow = `0 0 ${glow}px rgba(157,78,221,${vizGlowIntensity * 0.4}), 0 0 ${glow*2}px rgba(0,220,245,${vizGlowIntensity * 0.15})`;
  }
}

// ============ AURORA BOREALIS ============
function drawAuroraBorealis(ctx, w, h, time) {
  // Trail fade — slow enough for ghosting trails
  ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
  ctx.fillRect(0, 0, w, h);

  const bi = beatIntensity;
  const t = time * 0.001;

  // Initialize stars
  if (!auroraStars) {
    auroraStars = [];
    for (let i = 0; i < 200; i++) {
      auroraStars.push({
        x: Math.random() * w,
        y: Math.random() * h * 0.75,
        size: Math.random() * 1.5 + 0.3,
        twinkleSpeed: Math.random() * 2 + 0.5,
        twinklePhase: Math.random() * Math.PI * 2
      });
    }
  }

  // Draw star field behind curtains
  ctx.globalCompositeOperation = 'lighter';
  auroraStars.forEach(star => {
    const twinkle = 0.3 + 0.7 * Math.abs(Math.sin(t * star.twinkleSpeed + star.twinklePhase));
    const alpha = twinkle * (0.25 + bi * 0.15);
    ctx.fillStyle = `rgba(140, 170, 220, ${alpha})`;
    ctx.beginPath();
    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
    ctx.fill();
    // Bright star glow on some
    if (star.size > 1.2 && twinkle > 0.8) {
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.size * 3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(180, 200, 240, ${alpha * 0.15})`;
      ctx.fill();
    }
  });

  // Aurora curtain layers — vivid, full intensity
  const curtainLayers = [
    { yBase: 0.12, amplitude: 0.10, speed: 0.25, waveCount: 2.5, heightMul: 0.45, colors: ['#00DCF5', '#9D4EDD'], alpha: 0.18 },
    { yBase: 0.18, amplitude: 0.07, speed: 0.45, waveCount: 3.5, heightMul: 0.35, colors: ['#9D4EDD', '#FF2D7B'], alpha: 0.15 },
    { yBase: 0.08, amplitude: 0.12, speed: 0.15, waveCount: 2,   heightMul: 0.50, colors: ['#00B4D8', '#B76EFF'], alpha: 0.20 },
    { yBase: 0.22, amplitude: 0.06, speed: 0.6,  waveCount: 5,   heightMul: 0.28, colors: ['#B76EFF', '#FF6BA8'], alpha: 0.14 },
    { yBase: 0.05, amplitude: 0.14, speed: 0.10, waveCount: 1.5, heightMul: 0.55, colors: ['#48F2FF', '#D4A0FF'], alpha: 0.10 }
  ];

  const bassExpand = 1 + bands.bass * 0.8;
  const beatFlash = bi > 0.4 ? bi * 0.25 : 0;

  curtainLayers.forEach((layer, li) => {
    const swaySpeed = layer.speed * (1 + bands.mid * 2);
    const points = [];
    const segments = 80;

    for (let i = 0; i <= segments; i++) {
      const xRatio = i / segments;
      const x = xRatio * w;
      const sway = Math.sin(xRatio * layer.waveCount * Math.PI + t * swaySpeed) * layer.amplitude
                  + Math.sin(xRatio * layer.waveCount * 1.7 * Math.PI + t * swaySpeed * 0.6) * layer.amplitude * 0.5
                  + Math.sin(xRatio * 7 + t * 0.8) * 0.015 * bands.high; // high-freq shimmer
      const y = (layer.yBase + sway) * h;
      points.push({ x, y });
    }

    const curtainHeight = layer.heightMul * h * bassExpand;

    // Main curtain body
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length - 1; i++) {
      const cpx = (points[i].x + points[i + 1].x) / 2;
      const cpy = (points[i].y + points[i + 1].y) / 2;
      ctx.quadraticCurveTo(points[i].x, points[i].y, cpx, cpy);
    }
    const lastPt = points[points.length - 1];
    ctx.lineTo(lastPt.x, lastPt.y + curtainHeight);
    ctx.lineTo(points[0].x, points[0].y + curtainHeight);
    ctx.closePath();

    // Gradient fill — vivid
    const avgY = points.reduce((s, p) => s + p.y, 0) / points.length;
    const grad = ctx.createLinearGradient(0, avgY, 0, avgY + curtainHeight);
    const topAlpha = Math.min(0.99, (layer.alpha + beatFlash) * (1 + bands.energy * 0.5));
    const midAlpha = Math.min(0.99, (layer.alpha * 0.5 + beatFlash * 0.4));
    grad.addColorStop(0, layer.colors[0] + Math.round(topAlpha * 255).toString(16).padStart(2, '0'));
    grad.addColorStop(0.3, layer.colors[1] + Math.round(midAlpha * 255).toString(16).padStart(2, '0'));
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fill();

    // Edge along the top — tinted to match curtain color, not white
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length - 1; i++) {
      const cpx = (points[i].x + points[i + 1].x) / 2;
      const cpy = (points[i].y + points[i + 1].y) / 2;
      ctx.quadraticCurveTo(points[i].x, points[i].y, cpx, cpy);
    }
    ctx.strokeStyle = layer.colors[0] + Math.round(Math.min(0.99, 0.15 + beatFlash * 0.2 + bands.energy * 0.1) * 255).toString(16).padStart(2, '0');
    ctx.lineWidth = 1 + bi * 1.5;
    ctx.stroke();

    // Vertical rays of light — tinted, streaming down from the curtain
    for (let i = 0; i < points.length; i += 3) {
      const localBright = Math.abs(Math.sin(points[i].x * 0.01 + t * swaySpeed * 2));
      if (localBright > 0.65) {
        const rayAlpha = (localBright - 0.65) / 0.35 * (0.06 + bi * 0.08 + bands.sub * 0.04);
        const rayLen = curtainHeight * 1.5 * (0.5 + bands.sub * 0.5);
        const rayGrad = ctx.createLinearGradient(points[i].x, points[i].y, points[i].x, points[i].y + rayLen);
        rayGrad.addColorStop(0, layer.colors[0] + Math.round(Math.min(0.99, rayAlpha) * 255).toString(16).padStart(2, '0'));
        rayGrad.addColorStop(0.4, layer.colors[1] + Math.round(Math.min(0.99, rayAlpha * 0.4) * 255).toString(16).padStart(2, '0'));
        rayGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = rayGrad;
        ctx.fillRect(points[i].x - 1.5, points[i].y, 3, rayLen);
      }
    }
  });

  // Shimmer particles — floating specks of light within the aurora
  const shimmerCount = 30 + Math.floor(bands.energy * 40);
  for (let i = 0; i < shimmerCount; i++) {
    const phase = t * 0.3 + i * 2.399;
    const px = (Math.sin(phase * 0.7 + i) * 0.5 + 0.5) * w;
    const py = (0.05 + Math.sin(phase * 0.4 + i * 0.3) * 0.3) * h;
    const size = 0.5 + Math.sin(phase * 3) * 0.5 + bi * 1.5;
    const alpha = (0.3 + Math.sin(phase * 5) * 0.3) * (0.4 + bands.energy * 0.4);
    if (alpha < 0.05) continue;
    ctx.beginPath();
    ctx.arc(px, py, size, 0, Math.PI * 2);
    const hue = (i / shimmerCount + t * 0.05) % 1;
    if (hue < 0.33) ctx.fillStyle = `rgba(0, 220, 245, ${alpha})`;
    else if (hue < 0.66) ctx.fillStyle = `rgba(183, 110, 255, ${alpha})`;
    else ctx.fillStyle = `rgba(255, 45, 123, ${alpha * 0.7})`;
    ctx.fill();
  }

  // Ground reflection — mirrored glow along the bottom
  const reflectY = h * 0.85;
  const reflectGrad = ctx.createLinearGradient(0, reflectY, 0, h);
  reflectGrad.addColorStop(0, 'transparent');
  reflectGrad.addColorStop(0.3, `rgba(0, 180, 216, ${0.03 + bands.energy * 0.04})`);
  reflectGrad.addColorStop(0.6, `rgba(157, 78, 221, ${0.04 + bands.energy * 0.05})`);
  reflectGrad.addColorStop(1, `rgba(0, 220, 245, ${0.02 + bi * 0.03})`);
  ctx.fillStyle = reflectGrad;
  ctx.fillRect(0, reflectY, w, h - reflectY);

  // Horizon line
  ctx.beginPath();
  ctx.moveTo(0, reflectY);
  ctx.lineTo(w, reflectY);
  ctx.strokeStyle = `rgba(0, 220, 245, ${0.06 + bands.energy * 0.08})`;
  ctx.lineWidth = 0.5;
  ctx.stroke();

  ctx.globalCompositeOperation = 'source-over';

  vizGlowIntensity = bands.energy * 0.35 + bi * 0.45;
  const panel = document.getElementById('vizPanel');
  if (panel) {
    const glow = Math.round(vizGlowIntensity * 25);
    panel.style.boxShadow = `0 0 ${glow}px rgba(0,220,245,${vizGlowIntensity * 0.3}), 0 0 ${glow*2}px rgba(157,78,221,${vizGlowIntensity * 0.15})`;
  }
}

// ============ DNA HELIX ============
function drawDnaHelix(ctx, w, h, time) {
  // Trail effect for motion blur
  ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
  ctx.fillRect(0, 0, w, h);

  const bi = beatIntensity;
  const t = time * 0.001;
  const cx = w / 2;
  const cy = h / 2;

  // Beat pulse decay — smooth, gradual swells
  if (bi > 0.4) dnaBeatPulse = Math.min(1, dnaBeatPulse + bi * 0.3);
  dnaBeatPulse *= 0.96;

  // Initialize floating particles
  if (!dnaParticles) {
    dnaParticles = [];
    for (let i = 0; i < 50; i++) {
      dnaParticles.push({
        x: (Math.random() - 0.5) * w * 0.8,
        y: (Math.random() - 0.5) * h * 0.8,
        z: (Math.random() - 0.5) * 400,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        vz: (Math.random() - 0.5) * 0.5,
        size: Math.random() * 2 + 0.5
      });
    }
  }

  // Camera slowly orbits — gentle, cinematic drift
  const bassCameraSpeed = 0.15 + bands.bass * 0.25;
  dnaCameraAngle += 0.0008 * bassCameraSpeed;
  const camAngle = dnaCameraAngle;
  const camDist = 420;
  const camX = Math.sin(camAngle) * camDist * 0.3;
  const camZ = Math.cos(camAngle) * camDist;
  const fov = 350;

  // Perspective projection function
  function project(px, py, pz) {
    // Rotate around Y axis (camera orbit)
    const rx = px * Math.cos(camAngle) - pz * Math.sin(camAngle);
    const ry = py;
    const rz = px * Math.sin(camAngle) + pz * Math.cos(camAngle);
    const z = rz + camDist;
    if (z <= 10) return null;
    const scale = fov / z;
    return {
      x: cx + rx * scale,
      y: cy + ry * scale,
      scale: scale,
      z: z,
      alpha: Math.min(1, Math.max(0.05, (z - 10) / (camDist * 2)))
    };
  }

  // Helix parameters — large, slow, majestic
  const helixRadius = (70 + bands.mid * 40) * (1 + dnaBeatPulse * 0.2);
  const twistRate = 0.05 + bands.high * 0.02;
  const rotSpeed = t * (0.12 + bands.bass * 0.18);
  const helixLen = 40;
  const nodeSpacing = 14;

  // Build helix points
  const strand1 = [];
  const strand2 = [];

  for (let i = 0; i < helixLen; i++) {
    const yPos = (i - helixLen / 2) * nodeSpacing;
    const angle = i * twistRate * Math.PI + rotSpeed;

    const x1 = Math.cos(angle) * helixRadius;
    const z1 = Math.sin(angle) * helixRadius;
    const x2 = Math.cos(angle + Math.PI) * helixRadius;
    const z2 = Math.sin(angle + Math.PI) * helixRadius;

    const p1 = project(x1, yPos, z1);
    const p2 = project(x2, yPos, z2);

    if (p1) strand1.push({ ...p1, idx: i });
    if (p2) strand2.push({ ...p2, idx: i });
  }

  ctx.globalCompositeOperation = 'lighter';

  // Draw cross-links first (behind strands)
  for (let i = 0; i < Math.min(strand1.length, strand2.length); i++) {
    const s1 = strand1[i];
    const s2 = strand2[i];
    if (s1.idx !== s2.idx) continue;
    if (s1.idx % 2 !== 0) continue; // every other rung

    const depthAlpha = Math.min(s1.alpha, s2.alpha) * 0.5;
    const linkAlpha = depthAlpha * (0.3 + bands.energy * 0.5 + bi * 0.2);

    // Magenta cross-links
    ctx.beginPath();
    ctx.moveTo(s1.x, s1.y);
    ctx.lineTo(s2.x, s2.y);
    ctx.strokeStyle = `rgba(255, 45, 123, ${linkAlpha})`;
    ctx.lineWidth = Math.max(0.5, Math.min(s1.scale, s2.scale) * 15);
    ctx.stroke();

    // Glow on cross-links
    if (linkAlpha > 0.1) {
      ctx.strokeStyle = `rgba(255, 107, 168, ${linkAlpha * 0.3})`;
      ctx.lineWidth = Math.max(1, Math.min(s1.scale, s2.scale) * 35);
      ctx.beginPath();
      ctx.moveTo(s1.x, s1.y);
      ctx.lineTo(s2.x, s2.y);
      ctx.stroke();
    }
  }

  // Draw strand connections (spine lines)
  function drawStrandLine(strandPts, r, g, b) {
    if (strandPts.length < 2) return;
    for (let i = 0; i < strandPts.length - 1; i++) {
      const a = strandPts[i];
      const bPt = strandPts[i + 1];
      const alpha = Math.min(a.alpha, bPt.alpha) * (0.3 + bands.energy * 0.4);
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(bPt.x, bPt.y);
      ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
      ctx.lineWidth = Math.max(0.5, ((a.scale + bPt.scale) / 2) * 20);
      ctx.stroke();
    }
  }

  // Strand 1: purple
  drawStrandLine(strand1, 157, 78, 221);
  // Strand 2: cyan
  drawStrandLine(strand2, 0, 220, 245);

  // Draw strand nodes (spheres/dots)
  function drawStrandNodes(strandPts, r, g, b) {
    strandPts.forEach(p => {
      const nodeSize = Math.max(1, p.scale * 25 * (1 + dnaBeatPulse * 0.5));
      const alpha = p.alpha * (0.5 + bands.energy * 0.4 + bi * 0.2);

      // Node body
      const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, nodeSize);
      grad.addColorStop(0, `rgba(${Math.min(255,r+80)}, ${Math.min(255,g+80)}, ${Math.min(255,b+80)}, ${alpha})`);
      grad.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, ${alpha * 0.6})`);
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(p.x, p.y, nodeSize, 0, Math.PI * 2);
      ctx.fill();

      // Glow
      if (alpha > 0.2) {
        const glowGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, nodeSize * 3);
        glowGrad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha * 0.15})`);
        glowGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(p.x, p.y, nodeSize * 3, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }

  drawStrandNodes(strand1, 157, 78, 221);
  drawStrandNodes(strand2, 0, 220, 245);

  // Floating energy particles
  dnaParticles.forEach(p => {
    p.x += p.vx * (0.6 + bands.energy * 0.8);
    p.y += p.vy * (0.6 + bands.energy * 0.8);
    p.z += p.vz * (0.6 + bands.energy * 0.8);

    // Soft wrap around
    if (p.x > w * 0.5) p.x = -w * 0.5;
    if (p.x < -w * 0.5) p.x = w * 0.5;
    if (p.y > h * 0.5) p.y = -h * 0.5;
    if (p.y < -h * 0.5) p.y = h * 0.5;
    if (p.z > 200) p.z = -200;
    if (p.z < -200) p.z = 200;

    // Beat push
    if (bi > 0.4) {
      p.vx += (Math.random() - 0.5) * bi * 2;
      p.vy += (Math.random() - 0.5) * bi * 2;
    }
    p.vx *= 0.98;
    p.vy *= 0.98;
    p.vz *= 0.98;

    const proj = project(p.x, p.y, p.z);
    if (!proj) return;

    const pSize = Math.max(0.5, proj.scale * p.size * 15);
    const pAlpha = proj.alpha * (0.3 + bands.energy * 0.3);
    const hueSelect = Math.random();
    const pr = hueSelect < 0.33 ? 157 : (hueSelect < 0.66 ? 0 : 255);
    const pg = hueSelect < 0.33 ? 78 : (hueSelect < 0.66 ? 220 : 45);
    const pb = hueSelect < 0.33 ? 221 : (hueSelect < 0.66 ? 245 : 123);
    ctx.fillStyle = `rgba(${pr}, ${pg}, ${pb}, ${pAlpha})`;
    ctx.beginPath();
    ctx.arc(proj.x, proj.y, pSize, 0, Math.PI * 2);
    ctx.fill();
  });

  ctx.globalCompositeOperation = 'source-over';

  vizGlowIntensity = bands.energy * 0.5 + bi * 0.5;
  const panel = document.getElementById('vizPanel');
  if (panel) {
    const glow = Math.round(vizGlowIntensity * 30);
    panel.style.boxShadow = `0 0 ${glow}px rgba(157,78,221,${vizGlowIntensity * 0.4}), 0 0 ${glow*2}px rgba(0,220,245,${vizGlowIntensity * 0.15})`;
  }
}

// ============ COSMIC MANDALA ============
function drawCosmicMandala(ctx, w, h, time) {
  // Very slow fade trail for psychedelic persistence
  ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
  ctx.fillRect(0, 0, w, h);

  const bi = beatIntensity;
  const t = time * 0.001;
  const cx = w / 2;
  const cy = h / 2;
  const minDim = Math.min(w, h);

  // Beat pulse decay
  if (bi > 0.3) mandalaBeatPulse = Math.min(1, mandalaBeatPulse + bi * 0.5);
  mandalaBeatPulse *= 0.94;

  // Color rotation based on energy — cycle through purple, magenta, cyan
  const colorPhase = t * 0.3 + bands.energy * 2;
  function getColor(offset, alpha) {
    const phase = (colorPhase + offset) % 3;
    let r, g, b;
    if (phase < 1) {
      // purple to magenta
      const m = phase;
      r = Math.round(157 + (255 - 157) * m);
      g = Math.round(78 + (45 - 78) * m);
      b = Math.round(221 + (123 - 221) * m);
    } else if (phase < 2) {
      // magenta to cyan
      const m = phase - 1;
      r = Math.round(255 + (0 - 255) * m);
      g = Math.round(45 + (220 - 45) * m);
      b = Math.round(123 + (245 - 123) * m);
    } else {
      // cyan to purple
      const m = phase - 2;
      r = Math.round(0 + (157 - 0) * m);
      g = Math.round(220 + (78 - 220) * m);
      b = Math.round(245 + (221 - 245) * m);
    }
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }

  // Initialize orbiting particles
  if (!mandalaParticles) {
    mandalaParticles = [];
    for (let i = 0; i < 60; i++) {
      const ring = Math.floor(Math.random() * 5);
      mandalaParticles.push({
        ringIdx: ring,
        angle: Math.random() * Math.PI * 2,
        speed: (Math.random() * 0.5 + 0.5) * (Math.random() < 0.5 ? 1 : -1) * 0.01,
        size: Math.random() * 1.5 + 0.5,
        offset: Math.random() * 0.1 - 0.05
      });
    }
  }

  ctx.globalCompositeOperation = 'lighter';

  const beatExpand = 1 + mandalaBeatPulse * 0.3;
  const beatGlow = mandalaBeatPulse * 0.4;

  // Ring definitions: each ring has different geometry, rotation, size, and band
  const rings = [
    { sides: 6,  baseRadius: minDim * 0.06, band: bands.bass, rotSpeed: 0.15,  dir: 1,  type: 'flower' },
    { sides: 3,  baseRadius: minDim * 0.12, band: bands.sub,  rotSpeed: -0.1,  dir: -1, type: 'star' },
    { sides: 8,  baseRadius: minDim * 0.19, band: bands.bass, rotSpeed: 0.08,  dir: 1,  type: 'polygon' },
    { sides: 12, baseRadius: minDim * 0.26, band: bands.mid,  rotSpeed: -0.05, dir: -1, type: 'flower' },
    { sides: 6,  baseRadius: minDim * 0.33, band: bands.mid,  rotSpeed: 0.12,  dir: 1,  type: 'star' },
    { sides: 5,  baseRadius: minDim * 0.40, band: bands.high, rotSpeed: -0.07, dir: -1, type: 'polygon' }
  ];

  // Central glow
  const centerGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, minDim * 0.08 * beatExpand);
  centerGlow.addColorStop(0, getColor(0, 0.4 + bi * 0.4));
  centerGlow.addColorStop(0.5, getColor(0.5, 0.15 + bi * 0.15));
  centerGlow.addColorStop(1, 'transparent');
  ctx.fillStyle = centerGlow;
  ctx.beginPath();
  ctx.arc(cx, cy, minDim * 0.08 * beatExpand, 0, Math.PI * 2);
  ctx.fill();

  // Central dot
  ctx.fillStyle = getColor(0, 0.8 + bi * 0.2);
  ctx.beginPath();
  ctx.arc(cx, cy, 2 + bands.energy * 3 + bi * 2, 0, Math.PI * 2);
  ctx.fill();

  // Draw rings
  const ringVertices = []; // store for connecting lines
  rings.forEach((ring, ri) => {
    const radius = (ring.baseRadius + ring.band * minDim * 0.08) * beatExpand;
    const rot = t * ring.rotSpeed * ring.dir * (1 + bands.energy * 0.5);
    const sides = ring.sides;
    const alpha = 0.25 + bands.energy * 0.4 + beatGlow;
    const vertices = [];

    // Calculate vertices
    for (let i = 0; i < sides; i++) {
      const angle = (i / sides) * Math.PI * 2 + rot;
      vertices.push({
        x: cx + Math.cos(angle) * radius,
        y: cy + Math.sin(angle) * radius
      });
    }
    ringVertices.push(vertices);

    if (ring.type === 'flower') {
      // Flower of life: circles at each vertex and midpoints
      const petalRadius = radius * 0.3 * (1 + ring.band * 0.5);
      vertices.forEach((v, vi) => {
        ctx.beginPath();
        ctx.arc(v.x, v.y, petalRadius, 0, Math.PI * 2);
        ctx.strokeStyle = getColor(ri * 0.4, alpha * 0.6);
        ctx.lineWidth = 0.8 + bi * 1.5;
        ctx.stroke();
      });

      // Midpoint circles
      for (let i = 0; i < sides; i++) {
        const next = (i + 1) % sides;
        const mx = (vertices[i].x + vertices[next].x) / 2;
        const my = (vertices[i].y + vertices[next].y) / 2;
        ctx.beginPath();
        ctx.arc(mx, my, petalRadius * 0.6, 0, Math.PI * 2);
        ctx.strokeStyle = getColor(ri * 0.4 + 0.2, alpha * 0.35);
        ctx.lineWidth = 0.5 + bi;
        ctx.stroke();
      }
    } else if (ring.type === 'star') {
      // Star pattern: connect every other vertex + inner star
      const innerRadius = radius * 0.5;
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        const outerAngle = (i / sides) * Math.PI * 2 + rot;
        const innerAngle = ((i + 0.5) / sides) * Math.PI * 2 + rot;
        const ox = cx + Math.cos(outerAngle) * radius;
        const oy = cy + Math.sin(outerAngle) * radius;
        const ix = cx + Math.cos(innerAngle) * innerRadius;
        const iy = cy + Math.sin(innerAngle) * innerRadius;
        if (i === 0) ctx.moveTo(ox, oy);
        else ctx.lineTo(ox, oy);
        ctx.lineTo(ix, iy);
      }
      ctx.closePath();
      ctx.strokeStyle = getColor(ri * 0.4, alpha);
      ctx.lineWidth = 0.8 + bi * 1.5;
      ctx.stroke();

      // Cross connections for star
      for (let i = 0; i < sides; i++) {
        const skipTo = (i + Math.floor(sides / 2)) % sides;
        ctx.beginPath();
        ctx.moveTo(vertices[i].x, vertices[i].y);
        ctx.lineTo(vertices[skipTo].x, vertices[skipTo].y);
        ctx.strokeStyle = getColor(ri * 0.4 + 1, alpha * 0.3);
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }
    } else {
      // Regular polygon with fractal subdivisions
      ctx.beginPath();
      ctx.moveTo(vertices[0].x, vertices[0].y);
      for (let i = 1; i < sides; i++) {
        ctx.lineTo(vertices[i].x, vertices[i].y);
      }
      ctx.closePath();
      ctx.strokeStyle = getColor(ri * 0.4, alpha);
      ctx.lineWidth = 0.8 + bi * 1.5;
      ctx.stroke();

      // Inner polygon (fractal subdivision)
      const innerScale = 0.6 + ring.band * 0.2;
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        const ix = cx + (vertices[i].x - cx) * innerScale;
        const iy = cy + (vertices[i].y - cy) * innerScale;
        if (i === 0) ctx.moveTo(ix, iy);
        else ctx.lineTo(ix, iy);
      }
      ctx.closePath();
      ctx.strokeStyle = getColor(ri * 0.4 + 0.5, alpha * 0.5);
      ctx.lineWidth = 0.5 + bi;
      ctx.stroke();

      // Connect inner to outer vertices
      for (let i = 0; i < sides; i++) {
        const ix = cx + (vertices[i].x - cx) * innerScale;
        const iy = cy + (vertices[i].y - cy) * innerScale;
        ctx.beginPath();
        ctx.moveTo(vertices[i].x, vertices[i].y);
        ctx.lineTo(ix, iy);
        ctx.strokeStyle = getColor(ri * 0.4 + 1.5, alpha * 0.25);
        ctx.lineWidth = 0.4;
        ctx.stroke();
      }
    }

    // Concentric circle for each ring
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.strokeStyle = getColor(ri * 0.4 + 0.8, alpha * 0.15);
    ctx.lineWidth = 0.3 + ring.band * 1.5;
    ctx.stroke();
  });

  // Connecting web lines between adjacent ring vertices
  for (let ri = 0; ri < ringVertices.length - 1; ri++) {
    const innerVerts = ringVertices[ri];
    const outerVerts = ringVertices[ri + 1];
    const alpha = (0.08 + bands.energy * 0.12 + beatGlow * 0.2);
    for (let i = 0; i < innerVerts.length; i++) {
      // Connect to nearest outer vertex
      let minDist = Infinity;
      let nearest = 0;
      for (let j = 0; j < outerVerts.length; j++) {
        const dx = innerVerts[i].x - outerVerts[j].x;
        const dy = innerVerts[i].y - outerVerts[j].y;
        const d = dx * dx + dy * dy;
        if (d < minDist) { minDist = d; nearest = j; }
      }
      ctx.beginPath();
      ctx.moveTo(innerVerts[i].x, innerVerts[i].y);
      ctx.lineTo(outerVerts[nearest].x, outerVerts[nearest].y);
      ctx.strokeStyle = getColor(ri * 0.6, alpha);
      ctx.lineWidth = 0.3;
      ctx.stroke();
    }
  }

  // Orbiting particles along geometric paths
  mandalaParticles.forEach(p => {
    const ri = Math.min(p.ringIdx, rings.length - 1);
    const ring = rings[ri];
    const radius = (ring.baseRadius + ring.band * minDim * 0.08) * beatExpand;
    p.angle += p.speed * (1 + bands.energy * 2) * ring.dir;
    const particleRadius = radius * (1 + p.offset);
    const px = cx + Math.cos(p.angle) * particleRadius;
    const py = cy + Math.sin(p.angle) * particleRadius;
    const pAlpha = 0.3 + bands.energy * 0.4 + bi * 0.2;

    ctx.fillStyle = getColor(p.ringIdx * 0.5, pAlpha);
    ctx.beginPath();
    ctx.arc(px, py, p.size * (1 + bi * 1.5), 0, Math.PI * 2);
    ctx.fill();

    // Small glow
    if (pAlpha > 0.3) {
      const pGlow = ctx.createRadialGradient(px, py, 0, px, py, p.size * 5);
      pGlow.addColorStop(0, getColor(p.ringIdx * 0.5, pAlpha * 0.2));
      pGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = pGlow;
      ctx.beginPath();
      ctx.arc(px, py, p.size * 5, 0, Math.PI * 2);
      ctx.fill();
    }
  });

  ctx.globalCompositeOperation = 'source-over';

  vizGlowIntensity = bands.energy * 0.5 + bi * 0.5;
  const panel = document.getElementById('vizPanel');
  if (panel) {
    const glow = Math.round(vizGlowIntensity * 35);
    panel.style.boxShadow = `0 0 ${glow}px rgba(157,78,221,${vizGlowIntensity * 0.4}), 0 0 ${glow*2}px rgba(255,45,123,${vizGlowIntensity * 0.2})`;
  }
}

// ============ BIO-GENESIS (Organic fractal flame variant) ============
let bioOrganisms = null;
let bioSmoothedBeat = 0;
function initBioOrganisms() {
  bioOrganisms = [];
  for (let i = 0; i < 8; i++) {
    const org = {
      x: 0, y: 0,
      phase: Math.random() * Math.PI * 2,
      speed: 0.0003 + Math.random() * 0.0005,
      size: 30 + Math.random() * 50,
      membrane: [], flagella: [],
      mitos: [], color: Math.random(),
      pulsePhase: Math.random() * Math.PI * 2
    };
    // Mitochondria inside the cell
    for (let m = 0; m < 3 + Math.floor(Math.random() * 4); m++) {
      org.mitos.push({
        angle: Math.random() * Math.PI * 2,
        dist: Math.random() * 0.6,
        size: 4 + Math.random() * 6,
        phase: Math.random() * Math.PI * 2,
        speed: 0.001 + Math.random() * 0.002
      });
    }
    // Flagella
    const flagCount = 1 + Math.floor(Math.random() * 3);
    for (let f = 0; f < flagCount; f++) {
      org.flagella.push({
        baseAngle: Math.random() * Math.PI * 2,
        length: 30 + Math.random() * 60,
        segments: 12 + Math.floor(Math.random() * 8),
        waveSpeed: 2 + Math.random() * 3,
        amplitude: 5 + Math.random() * 10
      });
    }
    bioOrganisms.push(org);
  }
}

function drawBioGenesis(ctx, w, h, time) {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.06)';
  ctx.fillRect(0, 0, w, h);

  if (!bioOrganisms) initBioOrganisms();
  const bi = beatIntensity;
  bioSmoothedBeat += (bi - bioSmoothedBeat) * 0.12;
  const sb = bioSmoothedBeat;

  // Background organic mesh — floating connections
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < bioOrganisms.length; i++) {
    for (let j = i + 1; j < bioOrganisms.length; j++) {
      const a = bioOrganisms[i], b = bioOrganisms[j];
      const dx = a.x - b.x, dy = a.y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 250) {
        const alpha = (1 - dist / 250) * 0.06 * (1 + sb);
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.strokeStyle = `rgba(157, 78, 221, ${alpha})`;
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }
    }
  }

  bioOrganisms.forEach((org, oi) => {
    // Drift movement — organisms float around
    org.phase += org.speed * (1 + bands.energy * 2);
    org.x = w * (0.15 + 0.7 * ((Math.sin(org.phase + oi * 1.7) * 0.5 + 0.5)));
    org.y = h * (0.15 + 0.7 * ((Math.cos(org.phase * 0.7 + oi * 2.3) * 0.5 + 0.5)));

    const pulseR = org.size * (1 + Math.sin(time * 0.002 + org.pulsePhase) * 0.15 + sb * 0.4 + bands.bass * 0.3);

    // Outer membrane — wobbly organic shape
    ctx.beginPath();
    const memPoints = 32;
    for (let i = 0; i <= memPoints; i++) {
      const a = (i / memPoints) * Math.PI * 2;
      const freqIdx = Math.floor((i / memPoints) * 128);
      const freqWob = freqData ? (freqData[freqIdx] || 0) / 255 * 8 : 0;
      const wobble = Math.sin(a * 3 + time * 0.003) * 4 + Math.sin(a * 5 + time * 0.002) * 2 + freqWob;
      const r = pulseR + wobble;
      const px = org.x + Math.cos(a) * r;
      const py = org.y + Math.sin(a) * r;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    // Cell fill — bioluminescent gradient
    const hue = (org.color + time * 0.00005) % 1;
    const gr = ctx.createRadialGradient(org.x, org.y, 0, org.x, org.y, pulseR);
    const isPurple = hue < 0.5;
    if (isPurple) {
      gr.addColorStop(0, `rgba(120, 60, 180, ${0.15 + sb * 0.15})`);
      gr.addColorStop(0.5, `rgba(80, 30, 140, ${0.08 + sb * 0.08})`);
      gr.addColorStop(1, `rgba(40, 15, 80, ${0.03})`);
    } else {
      gr.addColorStop(0, `rgba(0, 160, 190, ${0.12 + sb * 0.12})`);
      gr.addColorStop(0.5, `rgba(0, 100, 140, ${0.06 + sb * 0.06})`);
      gr.addColorStop(1, `rgba(0, 50, 80, ${0.02})`);
    }
    ctx.fillStyle = gr;
    ctx.fill();
    // Membrane stroke
    ctx.strokeStyle = isPurple ? `rgba(183, 110, 255, ${0.25 + sb * 0.3})` : `rgba(0, 220, 245, ${0.2 + sb * 0.25})`;
    ctx.lineWidth = 1.2 + sb * 1.5;
    ctx.stroke();

    // Nucleus
    const nucR = pulseR * 0.25 + sb * 5;
    const nucGrad = ctx.createRadialGradient(org.x, org.y, 0, org.x, org.y, nucR);
    nucGrad.addColorStop(0, `rgba(220, 180, 255, ${0.5 + sb * 0.3})`);
    nucGrad.addColorStop(0.5, `rgba(157, 78, 221, ${0.3 + sb * 0.2})`);
    nucGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = nucGrad;
    ctx.beginPath();
    ctx.arc(org.x, org.y, nucR, 0, Math.PI * 2);
    ctx.fill();

    // Mitochondria — floating organelles inside the cell
    org.mitos.forEach(m => {
      m.angle += m.speed * (1 + bands.mid * 3);
      m.phase += 0.02;
      const md = m.dist * pulseR;
      const mx = org.x + Math.cos(m.angle) * md;
      const my = org.y + Math.sin(m.angle) * md;
      const ms = m.size * (1 + Math.sin(m.phase) * 0.2 + sb * 0.4);
      // Elongated mitochondria shape
      ctx.save();
      ctx.translate(mx, my);
      ctx.rotate(m.angle + Math.PI / 4);
      ctx.beginPath();
      ctx.ellipse(0, 0, ms * 1.5, ms * 0.7, 0, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 80, 160, ${0.15 + sb * 0.2 + bands.energy * 0.1})`;
      ctx.fill();
      ctx.strokeStyle = `rgba(255, 120, 180, ${0.2 + sb * 0.15})`;
      ctx.lineWidth = 0.8;
      ctx.stroke();
      // Inner cristae folds
      for (let c = 0; c < 3; c++) {
        const cy = -ms * 0.4 + c * ms * 0.4;
        ctx.beginPath();
        ctx.moveTo(-ms * 0.8, cy);
        ctx.quadraticCurveTo(0, cy + ms * 0.3 * Math.sin(time * 0.003 + c), ms * 0.8, cy);
        ctx.strokeStyle = `rgba(255, 140, 200, ${0.1 + sb * 0.1})`;
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }
      ctx.restore();
    });

    // Flagella — whip-like tails
    org.flagella.forEach(f => {
      ctx.beginPath();
      const baseA = f.baseAngle + Math.sin(time * 0.001) * 0.2;
      let fx = org.x + Math.cos(baseA) * pulseR;
      let fy = org.y + Math.sin(baseA) * pulseR;
      ctx.moveTo(fx, fy);
      for (let s = 1; s <= f.segments; s++) {
        const t = s / f.segments;
        const wave = Math.sin(t * f.waveSpeed * Math.PI + time * 0.005) * f.amplitude * t;
        const perpA = baseA + Math.PI / 2;
        fx += Math.cos(baseA) * (f.length / f.segments);
        fy += Math.sin(baseA) * (f.length / f.segments);
        const wx = fx + Math.cos(perpA) * wave;
        const wy = fy + Math.sin(perpA) * wave;
        ctx.lineTo(wx, wy);
      }
      ctx.strokeStyle = isPurple ? `rgba(183, 110, 255, ${0.3 + sb * 0.2})` : `rgba(0, 220, 245, ${0.25 + sb * 0.2})`;
      ctx.lineWidth = 1.5 * (1 - 0.3);
      ctx.stroke();
    });
  });

  ctx.globalCompositeOperation = 'source-over';

  // Floating particles — spores
  for (let i = 0; i < 40; i++) {
    const seed = i * 4391;
    const px = (Math.sin(time * 0.0003 + seed) * 0.5 + 0.5) * w;
    const py = (Math.cos(time * 0.00025 + seed * 0.7) * 0.5 + 0.5) * h;
    const sz = 1 + Math.sin(time * 0.002 + seed) * 0.8 + sb * 1.5;
    const alpha = 0.15 + Math.sin(time * 0.001 + seed * 0.3) * 0.1 + sb * 0.15;
    ctx.beginPath();
    ctx.arc(px, py, sz, 0, Math.PI * 2);
    ctx.fillStyle = i % 3 === 0 ? `rgba(0, 220, 245, ${alpha})` : `rgba(183, 110, 255, ${alpha})`;
    ctx.fill();
  }

  vizGlowIntensity = bands.energy * 0.4 + sb * 0.5;
  const panel = document.getElementById('vizPanel');
  if (panel) {
    const glow = Math.round(vizGlowIntensity * 30);
    panel.style.boxShadow = `0 0 ${glow}px rgba(157,78,221,${vizGlowIntensity * 0.4}), 0 0 ${glow*2}px rgba(0,180,216,${vizGlowIntensity * 0.15})`;
  }
}

// ============ COMMAND DECK (UFO Dashboard HUD) ============
let cmdDeckSmoothedBeat = 0;
function drawCommandDeck(ctx, w, h, time) {
  ctx.clearRect(0, 0, w, h);
  const cx = w / 2, cy = h / 2;
  const bi = beatIntensity;
  cmdDeckSmoothedBeat += (bi - cmdDeckSmoothedBeat) * 0.12;
  const sb = cmdDeckSmoothedBeat;
  const minDim = Math.min(w, h);
  const t = time * 0.001;

  // === GLOW TEXT HELPER ===
  function gt(text, x, y, r, g, b, alpha, fs) {
    ctx.font = fs + 'px "JetBrains Mono"';
    ctx.fillStyle = `rgba(${r},${g},${b}, ${alpha * 0.3})`;
    ctx.filter = 'blur(3px)'; ctx.fillText(text, x, y); ctx.filter = 'none';
    ctx.fillStyle = `rgba(${r},${g},${b}, ${alpha})`;
    ctx.fillText(text, x, y);
  }

  // === DEEP SPACE AMBIENT ===
  const coreGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, minDim * 0.7);
  coreGlow.addColorStop(0, `rgba(60, 20, 120, ${0.04 + sb * 0.03})`);
  coreGlow.addColorStop(0.5, `rgba(20, 5, 50, ${0.02 + sb * 0.02})`);
  coreGlow.addColorStop(1, 'transparent');
  ctx.fillStyle = coreGlow; ctx.fillRect(0, 0, w, h);

  // === CENTRAL HOLOGRAPHIC DISC — the UFO's main display ===
  const discR = minDim * 0.32;
  const discY = cy - h * 0.02; // slightly above center

  // Outer ring — thick beveled edge
  ctx.beginPath(); ctx.arc(cx, discY, discR + 3, 0, Math.PI * 2);
  ctx.strokeStyle = `rgba(183, 110, 255, ${0.06 + sb * 0.04})`; ctx.lineWidth = 8; ctx.stroke();
  ctx.beginPath(); ctx.arc(cx, discY, discR, 0, Math.PI * 2);
  ctx.strokeStyle = `rgba(183, 110, 255, ${0.25 + sb * 0.15})`; ctx.lineWidth = 1; ctx.stroke();

  // Inner disc fill — dark with radial gradient
  const discBg = ctx.createRadialGradient(cx, discY, 0, cx, discY, discR);
  discBg.addColorStop(0, `rgba(15, 5, 30, 0.4)`);
  discBg.addColorStop(0.8, `rgba(8, 2, 20, 0.6)`);
  discBg.addColorStop(1, 'rgba(0,0,0,0.3)');
  ctx.fillStyle = discBg;
  ctx.beginPath(); ctx.arc(cx, discY, discR, 0, Math.PI * 2); ctx.fill();

  // Concentric frequency rings — pulse with audio bands
  const ringBands = [bands.sub, bands.bass, bands.mid, bands.high, bands.energy];
  const ringColors = [[157,78,221],[183,110,255],[0,220,245],[0,180,216],[255,45,123]];
  for (let i = 0; i < 5; i++) {
    const rr = (0.2 + i * 0.15) * discR + ringBands[i] * 10;
    const c = ringColors[i];
    const a = 0.08 + ringBands[i] * 0.2 + sb * 0.05;
    ctx.beginPath(); ctx.arc(cx, discY, rr, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(${c[0]},${c[1]},${c[2]}, ${a})`; ctx.lineWidth = 0.5 + ringBands[i] * 1.5; ctx.stroke();
  }

  // Rotating frequency arcs — alien symbol segments
  if (freqData) {
    ctx.save();
    ctx.beginPath(); ctx.arc(cx, discY, discR - 2, 0, Math.PI * 2); ctx.clip();
    for (let i = 0; i < 64; i++) {
      const val = freqData[i * 2] / 255;
      if (val < 0.08) continue;
      const arcAngle = (i / 64) * Math.PI * 2 + t * 0.2;
      const arcR = discR * (0.3 + val * 0.6);
      const arcLen = 0.04 + val * 0.05;
      ctx.beginPath(); ctx.arc(cx, discY, arcR, arcAngle - arcLen, arcAngle + arcLen);
      const hue = i / 64;
      if (hue < 0.33) ctx.strokeStyle = `rgba(183, 110, 255, ${val * 0.5})`;
      else if (hue < 0.66) ctx.strokeStyle = `rgba(0, 220, 245, ${val * 0.5})`;
      else ctx.strokeStyle = `rgba(255, 45, 123, ${val * 0.4})`;
      ctx.lineWidth = 1 + val * 3; ctx.stroke();
    }
    ctx.restore();
  }

  // Central core — pulsing energy orb
  const coreR = 8 + bands.energy * 15 + sb * 12;
  const coreG = ctx.createRadialGradient(cx, discY, 0, cx, discY, coreR);
  coreG.addColorStop(0, `rgba(220, 200, 255, ${0.4 + sb * 0.3})`);
  coreG.addColorStop(0.3, `rgba(183, 110, 255, ${0.25 + sb * 0.2})`);
  coreG.addColorStop(0.7, `rgba(123, 47, 190, ${0.1 + sb * 0.1})`);
  coreG.addColorStop(1, 'transparent');
  ctx.fillStyle = coreG;
  ctx.beginPath(); ctx.arc(cx, discY, coreR, 0, Math.PI * 2); ctx.fill();

  // Rotating symbol ring around outer edge
  ctx.save(); ctx.translate(cx, discY); ctx.rotate(t * 0.15);
  const symbols = '⟁⟐⟡⬡⬢◈◇⟠⟢⏣⎔⟁⟐⟡⬡⬢◈◇⟠⟢⏣⎔';
  ctx.font = '7px "JetBrains Mono"'; ctx.textAlign = 'center';
  for (let i = 0; i < symbols.length; i++) {
    const sa = (i / symbols.length) * Math.PI * 2;
    const sr = discR + 12;
    const sx2 = Math.cos(sa) * sr, sy2 = Math.sin(sa) * sr;
    const symAlpha = 0.15 + Math.sin(t * 2 + i * 0.5) * 0.1 + sb * 0.1;
    ctx.fillStyle = `rgba(183, 110, 255, ${symAlpha})`;
    ctx.fillText(symbols[i], sx2, sy2 + 3);
  }
  ctx.restore();

  // === LEFT PANEL: Frequency Waterfall ===
  const lpX = w * 0.03, lpY = h * 0.08, lpW = w * 0.18, lpH = h * 0.84;
  // Panel frame — rounded corners via path
  ctx.strokeStyle = `rgba(183, 110, 255, ${0.12 + sb * 0.06})`; ctx.lineWidth = 0.5;
  ctx.strokeRect(lpX, lpY, lpW, lpH);
  ctx.textAlign = 'left';
  gt('HARMONIC FIELD', lpX + 4, lpY - 4, 183, 110, 255, 0.5 + sb * 0.2, 6);

  // Circular frequency meters — stacked vertically like UFO gauges
  if (freqData) {
    const gaugeCount = 8;
    const gaugeSpacing = lpH / gaugeCount;
    const gaugeR = Math.min(lpW * 0.35, gaugeSpacing * 0.38);
    const freqLabels = ['20', '60', '150', '400', '1K', '3K', '8K', '16K'];
    for (let i = 0; i < gaugeCount; i++) {
      const gx = lpX + lpW / 2;
      const gy = lpY + gaugeSpacing * (i + 0.5);
      const fIdx = Math.floor((i / gaugeCount) * 128);
      const val = freqData[fIdx] / 255;
      const c = i < 3 ? [157,78,221] : i < 6 ? [0,220,245] : [255,45,123];

      // Gauge ring background
      ctx.beginPath(); ctx.arc(gx, gy, gaugeR, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${c[0]},${c[1]},${c[2]}, 0.08)`; ctx.lineWidth = 2; ctx.stroke();

      // Gauge arc — fill proportional to value
      const startA = -Math.PI * 0.75, endA = startA + val * Math.PI * 1.5;
      ctx.beginPath(); ctx.arc(gx, gy, gaugeR, startA, endA);
      ctx.strokeStyle = `rgba(${c[0]},${c[1]},${c[2]}, ${0.3 + val * 0.5})`; ctx.lineWidth = 2.5; ctx.stroke();
      // Glow on arc
      ctx.beginPath(); ctx.arc(gx, gy, gaugeR, startA, endA);
      ctx.strokeStyle = `rgba(${c[0]},${c[1]},${c[2]}, ${val * 0.1})`; ctx.lineWidth = 8; ctx.stroke();

      // Center value
      ctx.textAlign = 'center';
      gt(freqLabels[i], gx, gy + 3, c[0], c[1], c[2], 0.4 + val * 0.4, 6);
    }
  }

  // === RIGHT PANEL: Waveform + Energy Readout ===
  const rpX = w * 0.79, rpY = h * 0.08, rpW = w * 0.18, rpH = h * 0.40;
  ctx.strokeStyle = `rgba(0, 220, 245, ${0.12 + sb * 0.06})`; ctx.lineWidth = 0.5;
  ctx.strokeRect(rpX, rpY, rpW, rpH);
  ctx.textAlign = 'left';
  gt('SIGNAL TRACE', rpX + 4, rpY - 4, 0, 220, 245, 0.5 + sb * 0.2, 6);

  // Waveform oscilloscope
  const oMidY = rpY + rpH / 2;
  ctx.beginPath(); ctx.moveTo(rpX, oMidY); ctx.lineTo(rpX + rpW, oMidY);
  ctx.strokeStyle = 'rgba(0, 220, 245, 0.05)'; ctx.lineWidth = 0.3; ctx.stroke();
  if (freqData) {
    ctx.beginPath();
    for (let i = 0; i < rpW; i++) {
      const idx = Math.floor((i / rpW) * 256);
      const val = ((freqData[idx] || 128) - 128) / 128;
      const oy = oMidY + val * rpH * 0.35;
      i === 0 ? ctx.moveTo(rpX + i, oy) : ctx.lineTo(rpX + i, oy);
    }
    ctx.strokeStyle = `rgba(0, 220, 245, ${0.04 + sb * 0.03})`; ctx.lineWidth = 6; ctx.stroke();
    ctx.strokeStyle = `rgba(0, 220, 245, ${0.6 + sb * 0.3})`; ctx.lineWidth = 0.8; ctx.stroke();
  }

  // === RIGHT BOTTOM: Energy Orbs ===
  const r2X = rpX, r2Y = rpY + rpH + 14, r2W = rpW, r2H = h * 0.44;
  ctx.strokeStyle = `rgba(255, 45, 123, ${0.10 + sb * 0.06})`; ctx.lineWidth = 0.5;
  ctx.strokeRect(r2X, r2Y, r2W, r2H);
  gt('ENERGY MATRIX', r2X + 4, r2Y - 4, 255, 45, 123, 0.5 + sb * 0.2, 6);

  // 5 energy orbs in a vertical arrangement
  const orbNames = ['SUB', 'BASS', 'MID', 'HIGH', 'NRG'];
  const orbVals = [bands.sub, bands.bass, bands.mid, bands.high, bands.energy];
  const orbColors = [[157,78,221],[183,110,255],[0,220,245],[0,180,216],[255,45,123]];
  const orbSpacing = r2H / 5;
  orbNames.forEach((name, i) => {
    const ox = r2X + r2W * 0.35;
    const oy = r2Y + orbSpacing * (i + 0.5);
    const val = orbVals[i];
    const c = orbColors[i];
    const orbR = 6 + val * 12;

    // Orb glow
    const oG = ctx.createRadialGradient(ox, oy, 0, ox, oy, orbR * 2.5);
    oG.addColorStop(0, `rgba(${c[0]},${c[1]},${c[2]}, ${0.15 + val * 0.3})`);
    oG.addColorStop(0.5, `rgba(${c[0]},${c[1]},${c[2]}, ${val * 0.08})`);
    oG.addColorStop(1, 'transparent');
    ctx.fillStyle = oG; ctx.beginPath(); ctx.arc(ox, oy, orbR * 2.5, 0, Math.PI * 2); ctx.fill();
    // Orb core
    ctx.beginPath(); ctx.arc(ox, oy, orbR * 0.6, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${Math.min(255,c[0]+60)},${Math.min(255,c[1]+60)},${Math.min(255,c[2]+60)}, ${0.5 + val * 0.4})`;
    ctx.fill();

    // Label + value bar
    ctx.textAlign = 'left';
    gt(name, r2X + r2W * 0.6, oy + 3, c[0], c[1], c[2], 0.5 + val * 0.3, 6);
    const barX = r2X + r2W * 0.6, barW = r2W * 0.32 * val;
    ctx.fillStyle = `rgba(${c[0]},${c[1]},${c[2]}, ${0.2 + val * 0.3})`;
    ctx.fillRect(barX, oy + 6, barW, 2);
  });

  // === TOP STATUS BAR ===
  const statusY = h * 0.03;
  ctx.textAlign = 'left';
  gt('AETHER // UFO-NAV', w * 0.04, statusY, 183, 110, 255, 0.35 + sb * 0.15, 7);
  ctx.textAlign = 'center';
  // Rotating alien glyphs in header
  const glyphs = '⟁⟐⟡⬡◈⟠';
  const activeGlyph = glyphs[Math.floor(t * 0.5) % glyphs.length];
  gt(`${activeGlyph} HARMONIC LOCK ${(bi * 100).toFixed(0)}% ${activeGlyph}`, cx, statusY, 0, 220, 245, 0.3 + sb * 0.25, 7);
  ctx.textAlign = 'right';
  gt(`PWR ${(bands.energy * 100).toFixed(0)}%`, w * 0.96, statusY, 255, 45, 123, 0.3 + sb * 0.2, 7);

  // === BOTTOM: Scrolling alien telemetry ===
  ctx.textAlign = 'left';
  const feedY2 = h * 0.97;
  const scrollX = (time * 0.03) % (w * 2);
  const telemetry = `◈ FREQ-LOCK ${bands.mid > 0.5 ? 'ENGAGED' : 'SCANNING'} ◈ BASS-RESONANCE ${(bands.bass*100).toFixed(0)}% ◈ HARMONIC-SYNC ACTIVE ◈ NEURAL-LINK STABLE ◈ DIMENSION-SHIFT READY ◈`;
  ctx.font = '6px "JetBrains Mono"';
  ctx.fillStyle = `rgba(183, 110, 255, ${0.15 + sb * 0.08})`;
  ctx.fillText(telemetry, -scrollX, feedY2);
  ctx.fillText(telemetry, -scrollX + w * 2, feedY2);

  // === FLOATING PARTICLES — cosmic dust ===
  for (let i = 0; i < 30; i++) {
    const px = (Math.sin(t * 0.2 + i * 2.1) * 0.5 + 0.5) * w;
    const py = (Math.cos(t * 0.15 + i * 1.7) * 0.5 + 0.5) * h;
    const ps = 0.5 + Math.sin(t * 3 + i) * 0.3;
    const pa = 0.1 + Math.sin(t * 2 + i * 0.8) * 0.08;
    ctx.beginPath(); ctx.arc(px, py, ps, 0, Math.PI * 2);
    ctx.fillStyle = i % 3 === 0 ? `rgba(183,110,255,${pa})` : i % 3 === 1 ? `rgba(0,220,245,${pa})` : `rgba(255,45,123,${pa * 0.7})`;
    ctx.fill();
  }

  // === BEAT PULSE — subtle cosmic flash ===
  if (bi > 0.5) {
    const flashR = ctx.createRadialGradient(cx, discY, 0, cx, discY, discR * 1.5);
    flashR.addColorStop(0, `rgba(183, 110, 255, ${(bi - 0.5) * 0.1})`);
    flashR.addColorStop(1, 'transparent');
    ctx.fillStyle = flashR; ctx.fillRect(0, 0, w, h);
  }

  vizGlowIntensity = bands.energy * 0.3 + sb * 0.4;
  const panel = document.getElementById('vizPanel');
  if (panel) {
    const glow = Math.round(vizGlowIntensity * 25);
    panel.style.boxShadow = `0 0 ${glow}px rgba(183,110,255,${vizGlowIntensity * 0.4}), 0 0 ${glow*2}px rgba(123,47,190,${vizGlowIntensity * 0.15})`;
  }
}

// ============ SCENE 13: VOID PULSE II — Clean concentric ripples ============
let voidPulseIIRings = [];

function drawVoidPulseII(ctx, w, h, time) {
  // Very slow trail fade — long ghostly ring persistence
  ctx.fillStyle = 'rgba(0, 0, 0, 0.025)';
  ctx.fillRect(0, 0, w, h);

  const cx = w / 2, cy = h / 2;
  const bi = beatIntensity;
  const minDim = Math.min(w, h);

  // Ring color palette: purple, cyan, magenta
  const ringColors = [
    [157, 78, 221],   // purple
    [0, 220, 245],    // cyan
    [255, 45, 123],   // magenta
    [183, 110, 255],  // vivid purple
    [0, 180, 216],    // deep cyan
  ];

  // Spawn new rings on beat or periodically — slower, more dramatic
  const now = time;
  if (bi > 0.3 || (voidPulseIIRings.length === 0) || (voidPulseIIRings.length < 5 && now % 1200 < 16)) {
    const count = bi > 0.6 ? 2 : 1;
    for (let i = 0; i < count; i++) {
      const color = ringColors[Math.floor(Math.random() * ringColors.length)];
      voidPulseIIRings.push({
        radius: 5 + i * 8,
        maxRadius: Math.max(w, h) * (0.9 + Math.random() * 0.6),
        speed: 0.5 + bi * 1.5 + Math.random() * 0.4,
        alpha: 0.8 + bi * 0.2,
        lineWidth: 1.8 + bi * 3,
        born: now,
        wobbleAmp: bands.mid * 6 + bands.high * 3,
        wobbleFreq: 3 + Math.floor(Math.random() * 5),
        color: color
      });
    }
  }

  // Center glow — multi-color core
  const coreR = 30 + bands.bass * 40 + bi * 25;
  const coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR);
  coreGrad.addColorStop(0, `rgba(240, 220, 255, ${0.2 + bi * 0.3})`);
  coreGrad.addColorStop(0.2, `rgba(255, 45, 123, ${0.12 + bi * 0.15})`);
  coreGrad.addColorStop(0.5, `rgba(157, 78, 221, ${0.08 + bi * 0.1})`);
  coreGrad.addColorStop(0.8, `rgba(0, 220, 245, ${0.04 + bi * 0.06})`);
  coreGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = coreGrad;
  ctx.beginPath();
  ctx.arc(cx, cy, coreR, 0, Math.PI * 2);
  ctx.fill();

  // Draw and update rings
  ctx.globalCompositeOperation = 'lighter';
  voidPulseIIRings = voidPulseIIRings.filter(ring => {
    ring.radius += ring.speed;
    const life = 1 - ring.radius / ring.maxRadius;
    if (life <= 0) return false;

    const alpha = ring.alpha * life * life;
    const lw = ring.lineWidth * life;
    const c = ring.color;

    // Frequency-wobbled ring shape
    ctx.beginPath();
    const steps = 120;
    for (let i = 0; i <= steps; i++) {
      const angle = (i / steps) * Math.PI * 2;
      const freqIdx = Math.floor((i / steps) * 128);
      const freqWobble = freqData ? (freqData[freqIdx] || 0) / 255 * ring.wobbleAmp : 0;
      const wobble = Math.sin(angle * ring.wobbleFreq + time * 0.002) * ring.wobbleAmp * 0.3;
      const r = ring.radius + freqWobble + wobble;
      const x = cx + Math.cos(angle) * r;
      const y = cy + Math.sin(angle) * r;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();

    // Glow layer
    ctx.strokeStyle = `rgba(${c[0]}, ${c[1]}, ${c[2]}, ${alpha * 0.2})`;
    ctx.lineWidth = lw * 4;
    ctx.stroke();

    // Bright layer
    ctx.strokeStyle = `rgba(${c[0]}, ${c[1]}, ${c[2]}, ${alpha})`;
    ctx.lineWidth = lw;
    ctx.stroke();

    return true;
  });
  ctx.globalCompositeOperation = 'source-over';

  // Ambient radial glow — cyan/magenta/purple mix
  const ambientR = Math.max(w, h) * 0.55 + bands.energy * 60;
  const ambGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, ambientR);
  ambGrad.addColorStop(0, `rgba(255, 45, 123, ${0.02 + bands.energy * 0.02})`);
  ambGrad.addColorStop(0.3, `rgba(157, 78, 221, ${0.015 + bands.energy * 0.02})`);
  ambGrad.addColorStop(0.6, `rgba(0, 220, 245, ${0.01 + bands.bass * 0.015})`);
  ambGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = ambGrad;
  ctx.fillRect(0, 0, w, h);

  // Beat flash — alternating colors
  if (bi > 0.6) {
    const flashHue = Math.floor(time * 0.003) % 3;
    const flashColors = ['rgba(0, 220, 245,', 'rgba(255, 45, 123,', 'rgba(157, 78, 221,'];
    ctx.fillStyle = flashColors[flashHue] + `${(bi - 0.6) * 0.1})`;
    ctx.fillRect(0, 0, w, h);
  }

  vizGlowIntensity = bands.energy * 0.3 + bi * 0.5;
}

// ============ SCENE 14: NEURAL WEB II — Clean geometric network ============
let neuralWebIINodes = null;
let neuralWebIISignals = [];
let neuralWebIIBeatCooldown = 0;

function initNeuralWebII(w, h) {
  neuralWebIINodes = [];
  const count = 60;
  // Node color palette: purple, cyan, magenta
  const nodeColors = [
    [157, 78, 221],   // purple
    [0, 220, 245],    // cyan
    [255, 45, 123],   // magenta
    [183, 110, 255],  // vivid purple
  ];
  for (let i = 0; i < count; i++) {
    neuralWebIINodes.push({
      x: Math.random() * w,
      y: Math.random() * h,
      vx: (Math.random() - 0.5) * 0.4,
      vy: (Math.random() - 0.5) * 0.4,
      baseSize: 2 + Math.random() * 3,
      size: 2 + Math.random() * 3,
      pulse: 0,
      brightness: 0.4 + Math.random() * 0.6,
      color: nodeColors[Math.floor(Math.random() * nodeColors.length)]
    });
  }
  neuralWebIISignals = [];
}

function drawNeuralWebII(ctx, w, h, time) {
  // Trail fade
  ctx.fillStyle = 'rgba(0, 0, 0, 0.07)';
  ctx.fillRect(0, 0, w, h);

  if (!neuralWebIINodes) initNeuralWebII(w, h);

  const bi = beatIntensity;

  // Beat: pulse nodes and spawn signals — high reactivity
  if (bi > 0.2 && neuralWebIIBeatCooldown <= 0) {
    neuralWebIIBeatCooldown = 6;
    neuralWebIINodes.forEach(n => {
      n.pulse = Math.min(1.5, n.pulse + bi * 1.2);
    });
    // Spawn signal pulses — more signals for bigger beats
    const sigCount = bi > 0.6 ? 10 : bi > 0.35 ? 7 : 4;
    for (let s = 0; s < sigCount; s++) {
      const fromIdx = Math.floor(Math.random() * neuralWebIINodes.length);
      neuralWebIISignals.push({
        fromIdx,
        toIdx: -1,
        progress: 0,
        speed: 0.02 + Math.random() * 0.035 + bi * 0.02,
        alpha: 0.8 + bi * 0.2
      });
    }
  }
  // Also react to continuous energy, not just beats
  if (bands.energy > 0.3) {
    neuralWebIINodes.forEach(n => {
      n.pulse = Math.max(n.pulse, bands.energy * 0.4);
    });
  }
  if (neuralWebIIBeatCooldown > 0) neuralWebIIBeatCooldown--;

  const maxDist = 140 + bands.energy * 120;

  // Update nodes — slow drift
  neuralWebIINodes.forEach(n => {
    n.x += n.vx * (0.8 + bands.energy * 0.5);
    n.y += n.vy * (0.8 + bands.energy * 0.5);

    // Wrap around edges
    if (n.x < -20) n.x = w + 20;
    if (n.x > w + 20) n.x = -20;
    if (n.y < -20) n.y = h + 20;
    if (n.y > h + 20) n.y = -20;

    // Beat pulse decay — slow glow fade
    n.pulse *= 0.95;
    n.size = n.baseSize * (1 + n.pulse * 3.5);
  });

  // Build connection list for signal routing
  const connections = [];
  for (let i = 0; i < neuralWebIINodes.length; i++) {
    for (let j = i + 1; j < neuralWebIINodes.length; j++) {
      const a = neuralWebIINodes[i], b = neuralWebIINodes[j];
      const dx = a.x - b.x, dy = a.y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < maxDist) {
        connections.push({ i, j, dist });
      }
    }
  }

  // Draw connections — straight lines only, colored by connected nodes
  ctx.globalCompositeOperation = 'lighter';
  connections.forEach(({ i, j, dist }) => {
    const a = neuralWebIINodes[i], b = neuralWebIINodes[j];
    const alpha = (1 - dist / maxDist) * (0.15 + bands.energy * 0.5 + bi * 0.35);
    // Blend colors of connected nodes
    const c = [
      Math.floor((a.color[0] + b.color[0]) / 2),
      Math.floor((a.color[1] + b.color[1]) / 2),
      Math.floor((a.color[2] + b.color[2]) / 2)
    ];

    // Glow
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.strokeStyle = `rgba(${c[0]}, ${c[1]}, ${c[2]}, ${alpha * 0.25})`;
    ctx.lineWidth = 3 + (1 - dist / maxDist) * 3;
    ctx.stroke();

    // Crisp line
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.strokeStyle = `rgba(${c[0]}, ${c[1]}, ${c[2]}, ${alpha})`;
    ctx.lineWidth = 0.5 + (1 - dist / maxDist) * 1;
    ctx.stroke();
  });

  // Update and draw signals traveling along connections
  neuralWebIISignals = neuralWebIISignals.filter(sig => {
    // Find nearest connected node if toIdx not set
    if (sig.toIdx === -1) {
      let bestDist = Infinity, bestIdx = -1;
      const from = neuralWebIINodes[sig.fromIdx];
      neuralWebIINodes.forEach((n, idx) => {
        if (idx === sig.fromIdx) return;
        const dx = from.x - n.x, dy = from.y - n.y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < maxDist && d < bestDist) {
          bestDist = d;
          bestIdx = idx;
        }
      });
      if (bestIdx === -1) return false;
      sig.toIdx = bestIdx;
    }

    sig.progress += sig.speed;
    if (sig.progress >= 1) return false;

    const from = neuralWebIINodes[sig.fromIdx];
    const to = neuralWebIINodes[sig.toIdx];
    const sx = from.x + (to.x - from.x) * sig.progress;
    const sy = from.y + (to.y - from.y) * sig.progress;

    // Signal glow — pick color from source node
    const sigColor = neuralWebIINodes[sig.fromIdx].color;
    const sigR = 6 + bi * 4;
    const sigGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, sigR);
    sigGrad.addColorStop(0, `rgba(${sigColor[0]}, ${sigColor[1]}, ${sigColor[2]}, ${sig.alpha * 0.8})`);
    sigGrad.addColorStop(0.4, `rgba(${sigColor[0]}, ${sigColor[1]}, ${sigColor[2]}, ${sig.alpha * 0.3})`);
    sigGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = sigGrad;
    ctx.beginPath();
    ctx.arc(sx, sy, sigR, 0, Math.PI * 2);
    ctx.fill();

    return true;
  });

  // Draw nodes — each with its own color
  neuralWebIINodes.forEach(n => {
    const c = n.color;
    // Node glow
    const glowR = n.size * 4 + n.pulse * 8;
    const nodeGrad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, glowR);
    nodeGrad.addColorStop(0, `rgba(${c[0]}, ${c[1]}, ${c[2]}, ${0.15 + n.pulse * 0.3})`);
    nodeGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = nodeGrad;
    ctx.beginPath();
    ctx.arc(n.x, n.y, glowR, 0, Math.PI * 2);
    ctx.fill();

    // Node core — bright white tinted with node color
    const bright = [
      Math.min(255, c[0] + 80),
      Math.min(255, c[1] + 80),
      Math.min(255, c[2] + 80)
    ];
    ctx.beginPath();
    ctx.arc(n.x, n.y, n.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${bright[0]}, ${bright[1]}, ${bright[2]}, ${n.brightness + n.pulse * 0.4})`;
    ctx.fill();
  });
  ctx.globalCompositeOperation = 'source-over';

  // Beat flash — cyan/magenta alternating
  if (bi > 0.6) {
    const flashHue = Math.floor(time * 0.004) % 2;
    ctx.fillStyle = flashHue === 0
      ? `rgba(0, 220, 245, ${(bi - 0.6) * 0.08})`
      : `rgba(255, 45, 123, ${(bi - 0.6) * 0.08})`;
    ctx.fillRect(0, 0, w, h);
  }

  vizGlowIntensity = bands.energy * 0.3 + bi * 0.5;
}

// ============ SCENE 15: DNA HELIX II — Vertical double-strand helix ============
let dnaHelixIIPhase = 0;
let dnaHelixIIBeatPulse = 0;

function drawDnaHelixII(ctx, w, h, time) {
  // Trail fade
  ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
  ctx.fillRect(0, 0, w, h);

  const cx = w / 2, cy = h / 2;
  const bi = beatIntensity;
  const t = time * 0.001;

  // Beat pulse — slow swell
  if (bi > 0.3) dnaHelixIIBeatPulse = Math.min(1, dnaHelixIIBeatPulse + bi * 0.3);
  dnaHelixIIBeatPulse *= 0.97;

  // Slow rotation via phase shift — gentle drift
  dnaHelixIIPhase += 0.002 * (1 + bands.bass * 0.3);

  // Helix parameters
  const helixAmplitude = Math.min(w, h) * 0.15 + bands.mid * 30;
  const nodeCount = 40;
  const verticalSpacing = h / (nodeCount - 1);
  const wavelength = 6; // number of full waves visible

  // Build strand points
  const strand1 = [];
  const strand2 = [];

  for (let i = 0; i < nodeCount; i++) {
    const y = i * verticalSpacing;
    const phase = (i / nodeCount) * Math.PI * 2 * wavelength / nodeCount * nodeCount / 6 + dnaHelixIIPhase;
    const freqIdx = Math.floor((i / nodeCount) * 128);
    const freqMod = freqData ? (freqData[freqIdx] || 0) / 255 * 15 : 0;

    // Sine wave offset for each strand
    const offset1 = Math.sin(phase) * (helixAmplitude + freqMod);
    const offset2 = Math.sin(phase + Math.PI) * (helixAmplitude + freqMod);

    // Depth simulation: cos determines z-position
    const depth1 = Math.cos(phase) * 0.5 + 0.5; // 0 = far, 1 = near
    const depth2 = Math.cos(phase + Math.PI) * 0.5 + 0.5;

    strand1.push({ x: cx + offset1, y, depth: depth1, idx: i });
    strand2.push({ x: cx + offset2, y, depth: depth2, idx: i });
  }

  // Sort all elements by depth for proper layering
  const allElements = [];

  // Cross-links every 4 rungs
  for (let i = 0; i < nodeCount; i++) {
    if (i % 4 === 0) {
      const s1 = strand1[i], s2 = strand2[i];
      const avgDepth = (s1.depth + s2.depth) / 2;
      allElements.push({ type: 'link', s1, s2, depth: avgDepth, idx: i });
    }
  }

  // Strand segments
  for (let i = 0; i < nodeCount - 1; i++) {
    allElements.push({ type: 'seg1', from: strand1[i], to: strand1[i + 1], depth: (strand1[i].depth + strand1[i + 1].depth) / 2 });
    allElements.push({ type: 'seg2', from: strand2[i], to: strand2[i + 1], depth: (strand2[i].depth + strand2[i + 1].depth) / 2 });
  }

  // Nodes
  for (let i = 0; i < nodeCount; i++) {
    allElements.push({ type: 'node1', point: strand1[i], depth: strand1[i].depth });
    allElements.push({ type: 'node2', point: strand2[i], depth: strand2[i].depth });
  }

  // Sort back-to-front
  allElements.sort((a, b) => a.depth - b.depth);

  ctx.globalCompositeOperation = 'lighter';

  // Draw all elements — strand 1 = cyan, strand 2 = magenta, links = purple
  allElements.forEach(el => {
    const depthAlpha = 0.15 + el.depth * 0.85;
    const depthScale = 0.5 + el.depth * 0.5;
    const beatMod = 1 + dnaHelixIIBeatPulse * 0.3;

    if (el.type === 'link') {
      // Cross-link — purple
      const linkAlpha = depthAlpha * (0.2 + bands.energy * 0.3 + bi * 0.15) * beatMod;
      // Glow
      ctx.beginPath();
      ctx.moveTo(el.s1.x, el.s1.y);
      ctx.lineTo(el.s2.x, el.s2.y);
      ctx.strokeStyle = `rgba(183, 110, 255, ${linkAlpha * 0.3})`;
      ctx.lineWidth = 4 * depthScale;
      ctx.stroke();
      // Crisp
      ctx.beginPath();
      ctx.moveTo(el.s1.x, el.s1.y);
      ctx.lineTo(el.s2.x, el.s2.y);
      ctx.strokeStyle = `rgba(220, 160, 255, ${linkAlpha})`;
      ctx.lineWidth = 1 * depthScale;
      ctx.stroke();
    } else if (el.type === 'seg1' || el.type === 'seg2') {
      // Strand 1 = cyan, Strand 2 = magenta
      const segAlpha = depthAlpha * (0.25 + bands.energy * 0.4) * beatMod;
      const isCyan = el.type === 'seg1';
      // Glow
      ctx.beginPath();
      ctx.moveTo(el.from.x, el.from.y);
      ctx.lineTo(el.to.x, el.to.y);
      ctx.strokeStyle = isCyan
        ? `rgba(0, 220, 245, ${segAlpha * 0.2})`
        : `rgba(255, 45, 123, ${segAlpha * 0.2})`;
      ctx.lineWidth = 5 * depthScale;
      ctx.stroke();
      // Crisp
      ctx.beginPath();
      ctx.moveTo(el.from.x, el.from.y);
      ctx.lineTo(el.to.x, el.to.y);
      ctx.strokeStyle = isCyan
        ? `rgba(0, 240, 255, ${segAlpha})`
        : `rgba(255, 80, 150, ${segAlpha})`;
      ctx.lineWidth = 1.5 * depthScale;
      ctx.stroke();
    } else if (el.type === 'node1' || el.type === 'node2') {
      // Nodes: strand 1 = cyan, strand 2 = magenta
      const p = el.point;
      const nodeSize = (3 + dnaHelixIIBeatPulse * 3) * depthScale * beatMod;
      const nodeAlpha = depthAlpha * (0.5 + bi * 0.3);
      const isCyan = el.type === 'node1';
      const nc = isCyan ? [0, 220, 245] : [255, 45, 123];

      // Glow halo
      const glowR = nodeSize * 4;
      const nodeGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowR);
      nodeGrad.addColorStop(0, `rgba(${nc[0]}, ${nc[1]}, ${nc[2]}, ${nodeAlpha * 0.25})`);
      nodeGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = nodeGrad;
      ctx.beginPath();
      ctx.arc(p.x, p.y, glowR, 0, Math.PI * 2);
      ctx.fill();

      // Core — bright
      const bright = [Math.min(255, nc[0] + 80), Math.min(255, nc[1] + 80), Math.min(255, nc[2] + 80)];
      ctx.beginPath();
      ctx.arc(p.x, p.y, nodeSize, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${bright[0]}, ${bright[1]}, ${bright[2]}, ${nodeAlpha})`;
      ctx.fill();
    }
  });
  ctx.globalCompositeOperation = 'source-over';

  // Ambient vertical glow — cyan/magenta split
  const ambGrad = ctx.createLinearGradient(cx - helixAmplitude * 2, 0, cx + helixAmplitude * 2, 0);
  ambGrad.addColorStop(0, 'transparent');
  ambGrad.addColorStop(0.2, `rgba(0, 220, 245, ${0.015 + bands.energy * 0.015})`);
  ambGrad.addColorStop(0.5, `rgba(157, 78, 221, ${0.02 + bands.bass * 0.02})`);
  ambGrad.addColorStop(0.8, `rgba(255, 45, 123, ${0.015 + bands.energy * 0.015})`);
  ambGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = ambGrad;
  ctx.fillRect(0, 0, w, h);

  // Beat flash — alternating cyan/magenta
  if (bi > 0.6) {
    const flashHue = Math.floor(time * 0.003) % 2;
    ctx.fillStyle = flashHue === 0
      ? `rgba(0, 220, 245, ${(bi - 0.6) * 0.08})`
      : `rgba(255, 45, 123, ${(bi - 0.6) * 0.08})`;
    ctx.fillRect(0, 0, w, h);
  }

  vizGlowIntensity = bands.energy * 0.3 + bi * 0.5;
}

// ============ SCENE 16: LYRIC RAIN — Matrix-style falling letters with lyrics ============
let lyricRainColumns = null;
let lyricRainChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@#$%&*!?><{}[]|/\\~^`';
let lyricRainLastTrackId = null;
let lyricRainLyrics = '';
let lyricRainLyricWords = [];
let lyricRainWordIndex = 0;
let lyricRainWordTimer = 0;
let lyricRainActiveWords = []; // words materializing on screen
let lyricRainFontSize = 14;

function initLyricRain(w, h) {
  lyricRainFontSize = Math.max(10, Math.min(16, Math.floor(w / 80)));
  const cols = Math.floor(w / lyricRainFontSize);
  lyricRainColumns = [];
  for (let i = 0; i < cols; i++) {
    lyricRainColumns.push({
      y: Math.random() * h,
      speed: 1 + Math.random() * 3,
      chars: [],
      brightness: 0.3 + Math.random() * 0.7,
      isCyan: Math.random() > 0.4, // 60% cyan, 40% purple
    });
    // Pre-fill column with chars
    const charCount = Math.floor(h / lyricRainFontSize);
    for (let j = 0; j < charCount; j++) {
      lyricRainColumns[i].chars.push(lyricRainChars[Math.floor(Math.random() * lyricRainChars.length)]);
    }
  }
}

let lyricFetchInProgress = false;

async function fetchLyrics() {
  const t = currentQueue[currentQueueIndex];
  if (!t) return;
  if (t.id === lyricRainLastTrackId && lyricRainLyrics) return;
  if (lyricFetchInProgress) return;
  lyricFetchInProgress = true;
  lyricRainLastTrackId = t.id;
  lyricRainLyricWords = [];
  lyricRainWordIndex = 0;

  const artist = t.artist || '';
  const title = t.title || '';
  let source = '';

  // Try LRCLIB exact match (free lyrics API, no key needed)
  if (artist && title) {
    try {
      const lrcUrl = `https://lrclib.net/api/get?artist_name=${encodeURIComponent(artist)}&track_name=${encodeURIComponent(title)}`;
      const res = await Promise.race([
        fetch(lrcUrl),
        new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 6000))
      ]);
      if (res.ok) {
        const data = await res.json();
        if (data.plainLyrics && data.plainLyrics.length > 10) {
          lyricRainLyrics = data.plainLyrics;
          source = 'LRCLIB-exact';
        } else if (data.syncedLyrics) {
          // Strip timestamp tags from synced lyrics
          lyricRainLyrics = data.syncedLyrics.replace(/\[\d{2}:\d{2}\.\d{2,3}\]\s*/g, '');
          source = 'LRCLIB-synced';
        }
      }
    } catch(e) {
      console.warn('LRCLIB exact:', e.message);
    }
  }

  // Try LRCLIB search (fuzzy — catches remixes, live versions, slight mismatches)
  if (!lyricRainLyrics && artist && title) {
    try {
      const q = `${artist} ${title}`.replace(/\(.*?\)/g, '').trim();
      const searchUrl = `https://lrclib.net/api/search?q=${encodeURIComponent(q)}`;
      const res = await Promise.race([
        fetch(searchUrl),
        new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 6000))
      ]);
      if (res.ok) {
        const results = await res.json();
        if (Array.isArray(results) && results.length > 0) {
          const titleLow = title.toLowerCase().replace(/\(.*?\)/g, '').trim();
          const artistLow = artist.toLowerCase();
          const match = results.find(r =>
            r.plainLyrics &&
            r.artistName?.toLowerCase().includes(artistLow) &&
            r.trackName?.toLowerCase().includes(titleLow)
          ) || results.find(r =>
            r.plainLyrics && r.trackName?.toLowerCase().includes(titleLow)
          ) || results.find(r => r.plainLyrics);
          if (match?.plainLyrics) {
            lyricRainLyrics = match.plainLyrics;
            source = 'LRCLIB-search';
          } else if (match?.syncedLyrics) {
            lyricRainLyrics = match.syncedLyrics.replace(/\[\d{2}:\d{2}\.\d{2,3}\]\s*/g, '');
            source = 'LRCLIB-search-synced';
          }
        }
      }
    } catch(e) {
      console.warn('LRCLIB search:', e.message);
    }
  }

  // Fallback: try Subsonic getLyrics
  if (!lyricRainLyrics) {
    try {
      const resp = await SUBSONIC.get('getLyrics', { artist, title });
      if (resp?.lyrics?.value && resp.lyrics.value.length > 20) {
        lyricRainLyrics = resp.lyrics.value;
        source = 'Subsonic';
      }
    } catch(e) {}
  }

  // Final fallback: generate atmospheric text from track info
  if (!lyricRainLyrics) {
    const words = [];
    if (title) words.push(...title.split(/\s+/));
    if (artist) words.push(...artist.split(/\s+/));
    const album = t.album;
    if (album) words.push(...album.split(/\s+/));
    const expanded = [];
    for (let i = 0; i < 8; i++) expanded.push(...words);
    lyricRainLyrics = expanded.join(' ');
    source = 'fallback';
  }

  // Split into words
  lyricRainLyricWords = lyricRainLyrics.split(/\s+/).filter(w => w.length > 0);
  if (lyricRainLyricWords.length === 0) lyricRainLyricWords = ['AETHER'];
  lyricFetchInProgress = false;
  console.log(`Lyrics [${source}]: ${lyricRainLyricWords.length} words for "${artist} - ${title}"`);
}

function drawLyricRain(ctx, w, h, time) {
  // Dark fade — trail persistence (faster clear on beats for snappier feel)
  const fadeAlpha = 0.05 + bands.energy * 0.03 + beatIntensity * 0.04;
  ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
  ctx.fillRect(0, 0, w, h);

  if (!lyricRainColumns) initLyricRain(w, h);

  const bi = beatIntensity;
  const fs = lyricRainFontSize;
  const tt = time * 0.001;

  // Fetch lyrics for current track (non-blocking)
  const t = currentQueue[currentQueueIndex];
  if (t && t.id !== lyricRainLastTrackId) fetchLyrics();

  // Speed multiplier based on audio — more dramatic range
  const speedMul = 0.6 + bands.energy * 2.0 + bi * 1.2;

  // === BASS SHOCKWAVE — horizontal ripple traveling down screen on bass hits ===
  if (!drawLyricRain._shockwaves) drawLyricRain._shockwaves = [];
  if (bands.bass > 0.6 && bi > 0.45 && Math.random() < 0.3) {
    drawLyricRain._shockwaves.push({ y: 0, born: time, speed: 3 + bands.bass * 5 });
  }
  drawLyricRain._shockwaves = drawLyricRain._shockwaves.filter(sw => {
    sw.y += sw.speed * (1 + bi);
    if (sw.y > h + 30) return false;
    const swAge = (time - sw.born) / 1500;
    const swAlpha = Math.max(0, 0.4 - swAge * 0.4);
    // Horizontal glow line
    const swGrad = ctx.createLinearGradient(0, sw.y - 15, 0, sw.y + 15);
    swGrad.addColorStop(0, 'transparent');
    swGrad.addColorStop(0.4, `rgba(0, 220, 245, ${swAlpha * 0.3})`);
    swGrad.addColorStop(0.5, `rgba(0, 255, 255, ${swAlpha})`);
    swGrad.addColorStop(0.6, `rgba(0, 220, 245, ${swAlpha * 0.3})`);
    swGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = swGrad;
    ctx.fillRect(0, sw.y - 15, w, 30);
    return true;
  });

  // === BEAT COLUMN SURGE — random columns accelerate on beats ===
  if (!drawLyricRain._surgeColumns) drawLyricRain._surgeColumns = new Set();
  if (bi > 0.5 && Math.random() < 0.4) {
    const surgeCount = 3 + Math.floor(bi * 8);
    for (let s = 0; s < surgeCount; s++) {
      const idx = Math.floor(Math.random() * lyricRainColumns.length);
      drawLyricRain._surgeColumns.add(idx);
      lyricRainColumns[idx]._surgeUntil = time + 300 + bi * 400;
      lyricRainColumns[idx]._surgeSpeed = 4 + Math.random() * 6;
    }
  }

  // Draw falling columns
  ctx.font = `${fs}px "JetBrains Mono", monospace`;
  ctx.textAlign = 'center';

  // Global brightness pulse on beat
  const beatBrightPulse = 1 + bi * 0.6;

  lyricRainColumns.forEach((col, colIdx) => {
    const x = colIdx * fs + fs / 2;
    const isSurging = col._surgeUntil && time < col._surgeUntil;
    const colSpeed = isSurging ? col._surgeSpeed : col.speed;

    // Advance column
    col.y += colSpeed * speedMul;
    if (col.y > h + fs * 5) {
      col.y = -fs * (5 + Math.random() * 10);
      col.speed = 1 + Math.random() * 3;
      col.isCyan = Math.random() > 0.4;
      col._surgeUntil = 0;
    }

    // Mutation rate scales with energy — more chaotic when loud
    const mutRate = 0.03 + bands.energy * 0.08 + bi * 0.06;
    if (Math.random() < mutRate) {
      const mutIdx = Math.floor(Math.random() * col.chars.length);
      col.chars[mutIdx] = lyricRainChars[Math.floor(Math.random() * lyricRainChars.length)];
    }

    // Frequency-mapped brightness per column (low freq cols = bass, high = treble)
    const freqIdx = Math.floor((colIdx / lyricRainColumns.length) * 128);
    const freqVal = freqData ? (freqData[freqIdx] / 255) : 0;
    const freqBoost = 1 + freqVal * 0.8;

    // Draw characters in this column
    const startRow = Math.floor(col.y / fs);
    const tailLen = 12 + Math.floor(bands.energy * 14) + Math.floor(freqVal * 5);
    for (let j = 0; j < tailLen; j++) {
      const rowY = (startRow - j) * fs;
      if (rowY < -fs || rowY > h + fs) continue;
      const charIdx = ((startRow - j) % col.chars.length + col.chars.length) % col.chars.length;
      const ch = col.chars[charIdx];

      const fade = 1 - j / tailLen;
      if (j === 0) {
        // Head — bright, frequency-reactive glow
        const headAlpha = Math.min(1, (0.9 + bi * 0.1) * col.brightness * beatBrightPulse);
        if (isSurging) {
          // Surging columns get hot white heads
          ctx.fillStyle = `rgba(255, 255, 255, ${headAlpha})`;
          ctx.shadowColor = 'rgba(200, 240, 255, 0.95)';
          ctx.shadowBlur = 20 + bi * 15;
        } else {
          ctx.fillStyle = col.isCyan
            ? `rgba(200, 255, 255, ${headAlpha})`
            : `rgba(230, 200, 255, ${headAlpha})`;
          ctx.shadowColor = col.isCyan ? 'rgba(0, 220, 245, 0.8)' : 'rgba(183, 110, 255, 0.8)';
          ctx.shadowBlur = 12 + bi * 12 + freqVal * 8;
        }
      } else if (j < 3) {
        // Near-head — frequency-tinted brightness
        const nearAlpha = Math.min(1, fade * (0.8 + freqVal * 0.3) * col.brightness * beatBrightPulse);
        ctx.fillStyle = col.isCyan
          ? `rgba(0, ${200 + Math.floor(freqVal * 55)}, 255, ${nearAlpha})`
          : `rgba(${150 + Math.floor(freqVal * 55)}, 110, 255, ${nearAlpha})`;
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
      } else {
        // Trail — bass columns glow warmer, treble columns shimmer
        const trailAlpha = Math.min(1, fade * fade * (0.5 + freqVal * 0.3) * col.brightness * freqBoost);
        ctx.fillStyle = col.isCyan
          ? `rgba(0, ${140 + Math.floor(freqVal * 60)}, ${180 + Math.floor(freqVal * 40)}, ${trailAlpha})`
          : `rgba(${90 + Math.floor(freqVal * 50)}, ${40 + Math.floor(freqVal * 30)}, ${150 + Math.floor(freqVal * 50)}, ${trailAlpha})`;
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
      }
      ctx.fillText(ch, x, rowY);
    }
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';
  });

  // === FREQUENCY SPECTRUM REFLECTION — subtle bar graph at bottom ===
  if (freqData) {
    const barCount = 64;
    const barW = w / barCount;
    for (let i = 0; i < barCount; i++) {
      const val = freqData[i * 2] / 255;
      if (val < 0.05) continue;
      const barH = val * h * 0.08;
      const bx = i * barW;
      const by = h - barH;
      const hueShift = i / barCount;
      const r = hueShift < 0.33 ? 157 : hueShift < 0.66 ? 0 : 183;
      const g = hueShift < 0.33 ? 78 : hueShift < 0.66 ? 220 : 110;
      const b2 = hueShift < 0.33 ? 221 : hueShift < 0.66 ? 245 : 255;
      ctx.fillStyle = `rgba(${r},${g},${b2}, ${0.06 + val * 0.12})`;
      ctx.fillRect(bx, by, barW - 1, barH);
    }
  }

  // === HORIZONTAL SCAN LINE — sweeps with the beat ===
  if (!drawLyricRain._scanY) drawLyricRain._scanY = 0;
  drawLyricRain._scanY += (1.5 + bands.energy * 3) * speedMul * 0.3;
  if (drawLyricRain._scanY > h) drawLyricRain._scanY = 0;
  const scanAlpha = 0.03 + bi * 0.06;
  ctx.fillStyle = `rgba(0, 220, 245, ${scanAlpha})`;
  ctx.fillRect(0, drawLyricRain._scanY - 1, w, 2);
  // Scan line glow
  const scanGlow = ctx.createLinearGradient(0, drawLyricRain._scanY - 8, 0, drawLyricRain._scanY + 8);
  scanGlow.addColorStop(0, 'transparent');
  scanGlow.addColorStop(0.5, `rgba(0, 220, 245, ${scanAlpha * 0.3})`);
  scanGlow.addColorStop(1, 'transparent');
  ctx.fillStyle = scanGlow;
  ctx.fillRect(0, drawLyricRain._scanY - 8, w, 16);

  // ═══ LYRIC WORDS materializing out of the rain ═══
  // Spawn new words on beat or periodically — more responsive timing
  const wordInterval = 900 - bands.energy * 500; // ms between words
  if (lyricRainLyricWords.length > 0 && (time - lyricRainWordTimer > wordInterval || bi > 0.45)) {
    if (time - lyricRainWordTimer > Math.max(200, wordInterval) || bi > 0.55) {
      lyricRainWordTimer = time;
      const word = lyricRainLyricWords[lyricRainWordIndex % lyricRainLyricWords.length];
      lyricRainWordIndex++;

      // Position: random horizontal, centered vertical band
      lyricRainActiveWords.push({
        text: word,
        x: w * 0.12 + Math.random() * w * 0.76,
        y: h * 0.2 + Math.random() * h * 0.55,
        born: time,
        duration: 2200 + word.length * 80,
        size: Math.max(24, Math.min(64, w * 0.035 + bi * 20)),
        isCyan: Math.random() > 0.35,
        revealed: 0,
        beatBorn: bi, // remember beat intensity at birth for scaling
      });

      // On strong beats, also spawn a second word for burst effect
      if (bi > 0.7 && lyricRainLyricWords.length > 1) {
        const word2 = lyricRainLyricWords[lyricRainWordIndex % lyricRainLyricWords.length];
        lyricRainWordIndex++;
        lyricRainActiveWords.push({
          text: word2,
          x: w * 0.12 + Math.random() * w * 0.76,
          y: h * 0.2 + Math.random() * h * 0.55,
          born: time,
          duration: 2200 + word2.length * 80,
          size: Math.max(20, Math.min(50, w * 0.028 + bi * 12)),
          isCyan: Math.random() > 0.35,
          revealed: 0,
          beatBorn: bi,
        });
      }
    }
  }

  // Draw and update active lyric words
  lyricRainActiveWords = lyricRainActiveWords.filter(word => {
    const age = time - word.born;
    if (age > word.duration) return false;

    const life = age / word.duration;
    const revealPhase = Math.min(1, life / 0.4);
    const charsToShow = Math.ceil(revealPhase * word.text.length);
    const fadeOut = life > 0.75 ? 1 - (life - 0.75) / 0.25 : 1;
    const fadeIn = Math.min(1, life / 0.1);
    const alpha = fadeIn * fadeOut;

    // Word scale pulses subtly with current beat
    const wordScale = 1 + bi * 0.08;
    const scaledSize = word.size * wordScale;

    ctx.font = `bold ${scaledSize}px "Orbitron", sans-serif`;
    ctx.textAlign = 'center';

    // Each character
    for (let c = 0; c < word.text.length; c++) {
      const ch = word.text[c];
      const charX = word.x + (c - word.text.length / 2) * (scaledSize * 0.65);
      // Slight vertical wave per character reacting to audio
      const charWave = Math.sin(tt * 4 + c * 0.8) * bands.energy * 3;
      const charY = word.y + charWave;

      if (c < charsToShow) {
        const charAge = revealPhase - (c / word.text.length);
        const freshness = Math.max(0, 1 - charAge * 3);

        // Glow — intensified with current beat
        ctx.shadowColor = word.isCyan ? `rgba(0, 220, 245, ${0.8 + bi * 0.2})` : `rgba(183, 110, 255, ${0.8 + bi * 0.2})`;
        ctx.shadowBlur = 15 + freshness * 25 + bi * 15;

        const bright = freshness > 0.3 ? 255 : (word.isCyan ? 0 : 183);
        const g = freshness > 0.3 ? 255 : (word.isCyan ? 240 : 110);
        const b = freshness > 0.3 ? 255 : (word.isCyan ? 255 : 255);
        ctx.fillStyle = `rgba(${bright}, ${g}, ${b}, ${alpha * (0.85 + freshness * 0.15)})`;
        ctx.fillText(ch, charX, charY);

        // Double-strike glow layer on beats for revealed chars
        if (bi > 0.4 && freshness > 0.1) {
          ctx.shadowBlur = 30 + bi * 20;
          ctx.globalAlpha = alpha * 0.15 * bi;
          ctx.fillText(ch, charX, charY);
          ctx.globalAlpha = 1;
        }
      } else {
        const rndCh = lyricRainChars[Math.floor(Math.random() * lyricRainChars.length)];
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
        ctx.fillStyle = word.isCyan
          ? `rgba(0, 180, 200, ${alpha * 0.15})`
          : `rgba(120, 60, 180, ${alpha * 0.15})`;
        ctx.fillText(rndCh, charX, charY);
      }
    }
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';

    return true;
  });

  // === AMBIENT GLOW — reactive bottom and top gradients ===
  const ambH = h * 0.35;
  const ambGrad = ctx.createLinearGradient(0, h, 0, h - ambH);
  ambGrad.addColorStop(0, `rgba(0, 180, 216, ${0.03 + bands.bass * 0.04 + bi * 0.02})`);
  ambGrad.addColorStop(0.5, `rgba(123, 47, 190, ${0.015 + bands.energy * 0.025})`);
  ambGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = ambGrad;
  ctx.fillRect(0, h - ambH, w, ambH);
  // Top glow on treble
  const topH = h * 0.15;
  const topGrad = ctx.createLinearGradient(0, 0, 0, topH);
  topGrad.addColorStop(0, `rgba(183, 110, 255, ${0.01 + bands.high * 0.03})`);
  topGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = topGrad;
  ctx.fillRect(0, 0, w, topH);

  // === BEAT FLASH — stronger, with color variation ===
  if (bi > 0.5) {
    const flashStrength = (bi - 0.5) * 0.12;
    // Alternate between cyan and purple flash
    if (Math.sin(tt * 8) > 0) {
      ctx.fillStyle = `rgba(0, 220, 245, ${flashStrength})`;
    } else {
      ctx.fillStyle = `rgba(183, 110, 255, ${flashStrength * 0.8})`;
    }
    ctx.fillRect(0, 0, w, h);
  }

  // === CORNER VIGNETTE — darkens edges, brightens center focus ===
  const vigGrad = ctx.createRadialGradient(w / 2, h / 2, h * 0.3, w / 2, h / 2, h * 0.9);
  vigGrad.addColorStop(0, 'transparent');
  vigGrad.addColorStop(1, `rgba(0, 0, 0, ${0.15 + bands.energy * 0.1})`);
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, w, h);

  vizGlowIntensity = bands.energy * 0.3 + bi * 0.5;
}

function drawViz(time) {
  // Scenes that use trails handle their own clearing.
  // Only clear for scenes that need a full clear each frame.
  const trailScenes = [0, 1, 3, 5, 6, 7, 8, 9, 11, 13, 14, 15, 16]; // FRACTAL FLAME, VOID PULSE, PARTICLE FIELD, PLASMA WARP, NEURAL WEB, AURORA BOREALIS, DNA HELIX, COSMIC MANDALA, BIO-GENESIS, VOID PULSE II, NEURAL WEB II, DNA HELIX II, LYRIC RAIN
  const sheepVideo = document.getElementById('sheepVideo');
  if (currentScene === 10) {
    // Electric Sheep mode — video plays behind, canvas overlays on top
    sheepVideo.style.display = 'block';
    vizCtx.clearRect(0, 0, vizW, vizH);
  } else {
    sheepVideo.style.display = 'none';
    sheepVideo.style.filter = '';
    sheepVideo.style.transform = '';
    if (!trailScenes.includes(currentScene)) {
      vizCtx.clearRect(0, 0, vizW, vizH);
    }
  }
  switch (currentScene) {
    case 0: drawFractalFlame(vizCtx, vizW, vizH, time); break;
    case 1: drawVoidPulse(vizCtx, vizW, vizH, time); break;
    case 2: drawTronGrid(vizCtx, vizW, vizH, time); break;
    case 3: drawParticleField(vizCtx, vizW, vizH, time); break;
    case 4: drawWaveformBars(vizCtx, vizW, vizH, time); break;
    case 5: drawPlasmaWarp(vizCtx, vizW, vizH, time); break;
    case 6: drawNeuralWeb(vizCtx, vizW, vizH, time); break;
    case 7: drawAuroraBorealis(vizCtx, vizW, vizH, time); break;
    case 8: drawDnaHelix(vizCtx, vizW, vizH, time); break;
    case 9: drawCosmicMandala(vizCtx, vizW, vizH, time); break;
    case 10: drawElectricSheepOverlay(vizCtx, vizW, vizH, time); break;
    case 11: drawBioGenesis(vizCtx, vizW, vizH, time); break;
    case 12: drawCommandDeck(vizCtx, vizW, vizH, time); break;
    case 13: drawVoidPulseII(vizCtx, vizW, vizH, time); break;
    case 14: drawNeuralWebII(vizCtx, vizW, vizH, time); break;
    case 15: drawDnaHelixII(vizCtx, vizW, vizH, time); break;
    case 16: drawLyricRain(vizCtx, vizW, vizH, time); break;
  }
  requestAnimationFrame(drawViz);
}
requestAnimationFrame(drawViz);

function switchScene(index) {
  if (index === undefined) {
    currentScene = (currentScene + 1) % SCENES.length;
  } else {
    currentScene = Math.max(0, Math.min(SCENES.length - 1, index));
  }
  fieldParticles = null; // Reset particles
  neuralNodes = null; // Reset neural web
  flameInitialized = false; // Reset fractal flame
  flameSystems = null;
  flameDensityBuffer = null;
  auroraStars = null; // Reset aurora borealis
  dnaParticles = null; // Reset DNA helix
  dnaBeatPulse = 0;
  dnaCameraAngle = 0;
  mandalaParticles = null; // Reset cosmic mandala
  mandalaBeatPulse = 0;
  bioOrganisms = null; // Reset bio-genesis
  bioSmoothedBeat = 0;
  cmdDeckSmoothedBeat = 0; // Reset command deck
  voidPulseIIRings = []; // Reset void pulse II
  neuralWebIINodes = null; // Reset neural web II
  neuralWebIISignals = []; // Reset neural web II signals
  dnaHelixIIPhase = 0; // Reset DNA helix II
  dnaHelixIIBeatPulse = 0;
  // Hide/show sheep video
  const sv = document.getElementById('sheepVideo');
  if (currentScene === 10) {
    sv.style.display = 'block';
    if (sheepVideos.length > 0 && sv.paused) {
      sheepVideoIdx = sheepVideoIdx % sheepVideos.length;
      sv.src = sheepVideos[sheepVideoIdx];
      console.log('Sheep: playing', sv.src);
      sv.play().catch(e => console.warn('Sheep play error:', e.message));
    }
  } else {
    sv.style.display = 'none';
    if (!sv.paused) sv.pause();
  }
  vizCtx.clearRect(0, 0, vizW, vizH); // Clear canvas on scene switch
  document.getElementById('vizSceneName').textContent = SCENES[currentScene];
  // Flash the scene name
  const sn = document.getElementById('vizSceneName');
  sn.style.opacity = '1';
  setTimeout(() => sn.style.opacity = '0.7', 2000);
  showToast(`Visualizer: ${SCENES[currentScene]}`);
}

document.getElementById('vizPanel').addEventListener('click', (e) => {
  if (e.target.closest('.viz-expand')) return; // Don't cycle when clicking fullscreen btn
  switchScene();
});

document.querySelector('.viz-expand').addEventListener('click', (e) => {
  e.stopPropagation();
  vizFullscreen = !vizFullscreen;
  document.getElementById('vizPanel').classList.toggle('viz-fullscreen', vizFullscreen);
  // Resize canvas
  setTimeout(() => {
    const rect = document.getElementById('vizPanel').getBoundingClientRect();
    const c = document.getElementById('vizCanvas');
    c.width = rect.width;
    c.height = rect.height;
    vizW = c.width;
    vizH = c.height;
  }, 50);
});

// ============ ELECTRON WINDOW CONTROLS ============
(function() {
  if (!window.electronAPI) {
    document.getElementById('titlebar').style.display = 'none';
    document.querySelector('.app-shell').style.top = '0';
    return;
  }
  document.getElementById('tbMin').addEventListener('click', () => window.electronAPI.minimize());
  document.getElementById('tbMax').addEventListener('click', () => window.electronAPI.maximize());
  document.getElementById('tbClose').addEventListener('click', () => window.electronAPI.close());

  window.electronAPI.onWindowState?.((state) => {
    const icon = document.getElementById('tbMaxIcon');
    icon.innerHTML = state === 'maximized'
      ? '<rect x="2" y="0" width="8" height="8" rx="0.5" fill="none"/><rect x="0" y="2" width="8" height="8" rx="0.5" fill="none"/>'
      : '<rect x="0.5" y="0.5" width="9" height="9" rx="1" fill="none"/>';
  });

  document.getElementById('titlebar').addEventListener('dblclick', (e) => {
    if (!e.target.closest('.titlebar-controls')) window.electronAPI.maximize();
  });
})();

// ============ INIT (WITH SPLASH SCREEN) ============
(async function init() {
  const delay = ms => new Promise(r => setTimeout(r, ms));

  splashProgress(5, 'BOOTING AETHER ENGINE');
  await delay(400);

  splashProgress(15, 'INITIALIZING AUDIO SUBSYSTEM');
  generateWaveform();
  await delay(300);

  splashProgress(30, 'CONNECTING TO NAVIDROME');
  await delay(200);

  try {
    // 8s timeout on ping only — prevents splash from hanging forever
    const pingController = new AbortController();
    const pingTimeout = setTimeout(() => pingController.abort(), 8000);
    const pingUrl = `${SUBSONIC.baseUrl}/rest/ping?${SUBSONIC.auth()}`;
    const pingRes = await fetch(pingUrl, { signal: pingController.signal });
    clearTimeout(pingTimeout);
    const pingData = await pingRes.json();
    const ping = pingData['subsonic-response'];
    console.log('Navidrome connected:', ping.status, ping.serverVersion);

    splashProgress(50, 'HANDSHAKE COMPLETE — v' + (ping.serverVersion || '?'));
    await delay(400);

    splashProgress(60, 'TRIGGERING LIBRARY SCAN');
    SUBSONIC.get('startScan').then(() => console.log('Navidrome library scan triggered')).catch(() => {});
    await delay(300);

    splashProgress(75, 'LOADING PLAYLISTS');
    loadPlaylists();
    await delay(300);

    splashProgress(90, 'LOADING LIBRARY');
    loadLibraryView();
    await delay(400);

    splashProgress(100, 'ALL SYSTEMS ONLINE');
    await delay(600);

    dismissSplash();
  } catch(err) {
    console.error('Navidrome connection failed:', err);
    splashProgress(100, 'CONNECTION FAILED — ENTERING OFFLINE');
    await delay(1200);
    dismissSplash();
    document.getElementById('dynamicContent').innerHTML = `
      <div style="padding:40px;text-align:center;">
        <div style="font-family:var(--font-display);color:var(--purple-vivid);font-size:1.2rem;margin-bottom:12px;">CONNECTION FAILED</div>
        <div style="font-family:var(--font-mono);color:var(--purple-muted);font-size:0.8rem;">Could not reach Navidrome at localhost:4533</div>
        <div style="font-family:var(--font-mono);color:var(--purple-dim);font-size:0.7rem;margin-top:8px;">${err.message}</div>
      </div>`;
  }
})();

// ============ ELECTRIC SHEEP AUTO-SCAN ============
(async function initElectricSheep() {
  // Video error handler
  const sv = document.getElementById('sheepVideo');
  sv.addEventListener('error', (e) => {
    console.error('Sheep video error:', sv.error?.message, 'code:', sv.error?.code, 'src:', sv.src);
    // Try next video on error
    if (sheepVideos.length > 1) {
      sheepVideoIdx = (sheepVideoIdx + 1) % sheepVideos.length;
      sv.src = sheepVideos[sheepVideoIdx];
      sv.play().catch(() => {});
    }
  });
  sv.addEventListener('loadeddata', () => {
    console.log('Sheep video loaded OK:', sv.src);
  });

  // Load saved folder from localStorage, fallback to C:\Sheep
  const savedFolder = localStorage.getItem('aether_sheep_folder');
  const scanPath = savedFolder || 'C:\\Sheep';
  console.log('Electric Sheep: scanning', scanPath);
  if (window.electronAPI && window.electronAPI.scanSheepFolder) {
    try {
      const files = await window.electronAPI.scanSheepFolder(scanPath);
      console.log('Electric Sheep scan result:', files?.length, 'files');
      if (files && files.length > 0) {
        sheepVideos = files.map(f => 'file:///' + encodeURI(f).replace(/#/g, '%23'));
        sheepFolder = scanPath;
        console.log('Electric Sheep: loaded', sheepVideos.length, 'videos, first:', sheepVideos[0]);
        updateSheepStatus();
        showToast(`Electric Sheep: ${sheepVideos.length} video${sheepVideos.length === 1 ? '' : 's'} loaded from ${scanPath}`);
        // Auto-start first video so it's ready when user switches to scene 10
        const sv2 = document.getElementById('sheepVideo');
        sv2.src = sheepVideos[0];
        sv2.load();
      } else {
        console.warn('Electric Sheep: scan returned 0 files from', scanPath);
        showToast('Electric Sheep: no videos found in ' + scanPath);
      }
    } catch(e) {
      console.error('Electric Sheep scan error:', e);
      showToast('Electric Sheep: scan error — ' + e.message);
    }
  } else {
    console.warn('Electric Sheep: electronAPI.scanSheepFolder not available');
  }
  updateSheepStatus();

  // Drag and drop video files onto the visualizer
  const vizPanel = document.getElementById('vizPanel');
  vizPanel.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.stopPropagation();
    vizPanel.style.outline = '2px solid var(--purple-bright)';
    vizPanel.style.outlineOffset = '-2px';
  });
  vizPanel.addEventListener('dragleave', () => {
    vizPanel.style.outline = '';
    vizPanel.style.outlineOffset = '';
  });
  vizPanel.addEventListener('drop', (e) => {
    e.preventDefault();
    e.stopPropagation();
    vizPanel.style.outline = '';
    vizPanel.style.outlineOffset = '';
    const files = Array.from(e.dataTransfer.files);
    const videos = files.filter(f => /\.(mp4|webm|mkv|avi|mov|m4v)$/i.test(f.name));
    if (videos.length > 0) {
      videos.forEach(f => {
        sheepVideos.push('file:///' + encodeURI(f.path.replace(/\\/g, '/')).replace(/#/g, '%23'));
      });
      showToast(`Electric Sheep: added ${videos.length} video${videos.length === 1 ? '' : 's'}`);
      updateSheepStatus();
      // Auto-switch to Electric Sheep scene
      switchScene(10);
      const sv = document.getElementById('sheepVideo');
      sv.src = sheepVideos[sheepVideoIdx % sheepVideos.length];
      sv.play().catch(() => {});
    }
  });
})();

// ============ AMBIENT FLOATING PARTICLES ============
(function initAmbientParticles() {
  const canvas = document.getElementById('ambientParticles');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const particles = [];
  const PARTICLE_COUNT = 60;

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  for (let i = 0; i < PARTICLE_COUNT; i++) {
    particles.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      vx: (Math.random() - 0.5) * 0.3,
      vy: (Math.random() - 0.5) * 0.2 - 0.1,
      size: Math.random() * 2 + 0.5,
      alpha: Math.random() * 0.4 + 0.1,
      hue: Math.random() > 0.8 ? 190 : Math.random() > 0.5 ? 330 : 275, // cyan, magenta, or purple
      pulseSpeed: Math.random() * 0.002 + 0.001,
      pulseOffset: Math.random() * Math.PI * 2,
    });
  }

  function drawParticles(time) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const beat = parseFloat(document.documentElement.style.getPropertyValue('--beat')) || 0;
    const energy = parseFloat(document.documentElement.style.getPropertyValue('--energy')) || 0;

    for (const p of particles) {
      p.x += p.vx + beat * (Math.random() - 0.5) * 2;
      p.y += p.vy;

      // Wrap around
      if (p.x < -10) p.x = canvas.width + 10;
      if (p.x > canvas.width + 10) p.x = -10;
      if (p.y < -10) p.y = canvas.height + 10;
      if (p.y > canvas.height + 10) p.y = -10;

      const pulse = Math.sin(time * p.pulseSpeed + p.pulseOffset) * 0.5 + 0.5;
      const a = p.alpha * (0.5 + pulse * 0.5) + beat * 0.3;
      const s = p.size + energy * 2 + beat * 1.5;

      // Glow
      ctx.beginPath();
      ctx.arc(p.x, p.y, s * 3, 0, Math.PI * 2);
      ctx.fillStyle = p.hue === 190 ? `rgba(0, 220, 245, ${a * 0.08})`
        : p.hue === 330 ? `rgba(255, 45, 123, ${a * 0.08})`
        : `rgba(157, 78, 221, ${a * 0.08})`;
      ctx.fill();

      // Core
      ctx.beginPath();
      ctx.arc(p.x, p.y, s, 0, Math.PI * 2);
      ctx.fillStyle = p.hue === 190 ? `rgba(0, 220, 245, ${a})`
        : p.hue === 330 ? `rgba(255, 107, 168, ${a})`
        : `rgba(183, 110, 255, ${a})`;
      ctx.fill();
    }

    // Draw faint connecting lines between nearby particles
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const dx = particles[i].x - particles[j].x;
        const dy = particles[i].y - particles[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 120) {
          const lineAlpha = (1 - dist / 120) * 0.06 * (1 + energy * 2);
          ctx.beginPath();
          ctx.moveTo(particles[i].x, particles[i].y);
          ctx.lineTo(particles[j].x, particles[j].y);
          ctx.strokeStyle = `rgba(157, 78, 221, ${lineAlpha})`;
          ctx.lineWidth = 0.5;
          ctx.stroke();
        }
      }
    }

    requestAnimationFrame(drawParticles);
  }
  requestAnimationFrame(drawParticles);
})();
</script>
</body>
</html>
